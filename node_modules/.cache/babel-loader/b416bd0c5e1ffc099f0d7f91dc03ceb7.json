{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar generate = require('regjsgen').generate;\n\nvar parse = require('regjsparser').parse;\n\nvar regenerate = require('regenerate');\n\nvar unicodeMatchProperty = require('unicode-match-property-ecmascript');\n\nvar unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nvar iuMappings = require('./data/iu-mappings.js');\n\nvar ESCAPE_SETS = require('./data/character-class-escape-sets.js'); // Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\n\n\nvar UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\n\nvar BMP_SET = regenerate().addRange(0x0, 0xFFFF); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\n\nvar DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A, // Line Feed <LF>\n0x000D, // Carriage Return <CR>\n0x2028, // Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./` (only BMP code points).\n\nvar DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET);\n\nvar getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n\n  return ESCAPE_SETS.REGULAR.get(character);\n};\n\nvar getDotSet = function getDotSet(unicode, dotAll) {\n  if (dotAll) {\n    return unicode ? UNICODE_SET : BMP_SET;\n  }\n\n  return unicode ? DOT_SET_UNICODE : DOT_SET;\n};\n\nvar getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {\n  var path = value ? \"\".concat(property, \"/\").concat(value) : \"Binary_Property/\".concat(property);\n\n  try {\n    return require(\"regenerate-unicode-properties/\".concat(path, \".js\"));\n  } catch (exception) {\n    throw new Error(\"Failed to recognize value `\".concat(value, \"` for property \") + \"`\".concat(property, \"`.\"));\n  }\n};\n\nvar handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    var _property = 'General_Category';\n    var category = unicodeMatchPropertyValue(_property, value);\n    return getUnicodePropertyValueSet(_property, category);\n  } catch (exception) {} // It’s not a `General_Category` value, so check if it’s a binary\n  // property. Note: `unicodeMatchProperty` throws on invalid properties.\n\n\n  var property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\n\nvar getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {\n  var parts = value.split('=');\n  var firstPart = parts[0];\n  var set;\n\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    var property = unicodeMatchProperty(firstPart);\n\n    var _value = unicodeMatchPropertyValue(property, parts[1]);\n\n    set = getUnicodePropertyValueSet(property, _value);\n  }\n\n  if (isNegative) {\n    return UNICODE_SET.clone().remove(set);\n  }\n\n  return set.clone();\n}; // Given a range of code points, add any case-folded code points in that range\n// to a set.\n\n\nregenerate.prototype.iuAddRange = function (min, max) {\n  var $this = this;\n\n  do {\n    var folded = caseFold(min);\n\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nvar update = function update(item, pattern) {\n  var tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n\n  Object.assign(item, tree);\n};\n\nvar wrap = function wrap(tree, pattern) {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': \"(?:\".concat(pattern, \")\")\n  };\n};\n\nvar caseFold = function caseFold(codePoint) {\n  return iuMappings.get(codePoint) || false;\n};\n\nvar processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {\n  var set = regenerate();\n\n  var _iterator = _createForOfIteratorHelper(characterClassItem.body),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n\n      switch (item.type) {\n        case 'value':\n          set.add(item.codePoint);\n\n          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n            var folded = caseFold(item.codePoint);\n\n            if (folded) {\n              set.add(folded);\n            }\n          }\n\n          break;\n\n        case 'characterClassRange':\n          var min = item.min.codePoint;\n          var max = item.max.codePoint;\n          set.addRange(min, max);\n\n          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n            set.iuAddRange(min, max);\n          }\n\n          break;\n\n        case 'characterClassEscape':\n          set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));\n          break;\n\n        case 'unicodePropertyEscape':\n          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n          break;\n        // The `default` clause is only here as a safeguard; it should never be\n        // reached. Code coverage tools should ignore it.\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown term type: \".concat(item.type));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (characterClassItem.negative) {\n    set = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n  }\n\n  update(characterClassItem, set.toString(regenerateOptions));\n  return characterClassItem;\n};\n\nvar updateNamedReference = function updateNamedReference(item, index) {\n  delete item.name;\n  item.matchIndex = index;\n};\n\nvar assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {\n  var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(\"Unknown group names: \".concat(unmatchedReferencesNames));\n  }\n};\n\nvar processTerm = function processTerm(item, regenerateOptions, groups) {\n  switch (item.type) {\n    case 'dot':\n      update(item, getDotSet(config.unicode, config.dotAll).toString(regenerateOptions));\n      break;\n\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n\n    case 'unicodePropertyEscape':\n      update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));\n      break;\n\n    case 'characterClassEscape':\n      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));\n      break;\n\n    case 'group':\n      groups.lastIndex++;\n\n      if (item.name) {\n        var name = item.name.value;\n\n        if (groups.names[name]) {\n          throw new Error(\"Multiple groups with the same name (\".concat(name, \") are not allowed.\"));\n        }\n\n        var index = groups.lastIndex;\n        delete item.name;\n        groups.names[name] = index;\n\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n\n        if (groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name].forEach(function (reference) {\n            updateNamedReference(reference, index);\n          });\n          delete groups.unmatchedReferences[name];\n        }\n      }\n\n    /* falls through */\n\n    case 'alternative':\n    case 'disjunction':\n    case 'quantifier':\n      item.body = item.body.map(function (term) {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'value':\n      var codePoint = item.codePoint;\n      var set = regenerate(codePoint);\n\n      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n        var folded = caseFold(codePoint);\n\n        if (folded) {\n          set.add(folded);\n        }\n      }\n\n      update(item, set.toString(regenerateOptions));\n      break;\n\n    case 'reference':\n      if (item.name) {\n        var _name = item.name.value;\n        var _index = groups.names[_name];\n\n        if (_index) {\n          updateNamedReference(item, _index);\n          break;\n        }\n\n        if (!groups.unmatchedReferences[_name]) {\n          groups.unmatchedReferences[_name] = [];\n        } // Keep track of references used before the corresponding group.\n\n\n        groups.unmatchedReferences[_name].push(item);\n      }\n\n      break;\n\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(\"Unknown term type: \".concat(item.type));\n  }\n\n  return item;\n};\n\nvar config = {\n  'ignoreCase': false,\n  'unicode': false,\n  'dotAll': false,\n  'useUnicodeFlag': false\n};\n\nvar rewritePattern = function rewritePattern(pattern, flags, options) {\n  var regjsparserFeatures = {\n    'unicodePropertyEscape': options && options.unicodePropertyEscape,\n    'namedGroups': options && options.namedGroup,\n    'lookbehind': options && options.lookbehind\n  };\n  config.ignoreCase = flags && flags.includes('i');\n  config.unicode = flags && flags.includes('u');\n  var supportDotAllFlag = options && options.dotAllFlag;\n  config.dotAll = supportDotAllFlag && flags && flags.includes('s');\n  config.useUnicodeFlag = options && options.useUnicodeFlag;\n  var regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.unicode\n  };\n  var groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: index }\n    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\n  };\n  var tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.\n\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\n\nmodule.exports = rewritePattern;","map":{"version":3,"sources":["D:/DEVELOPMENT/react-project/Quiz-react/react-quiz-app/node_modules/buble/node_modules/regexpu-core/rewrite-pattern.js"],"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","DOT_SET","intersection","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","prototype","iuAddRange","min","max","$this","folded","caseFold","add","update","item","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","processCharacterClass","characterClassItem","regenerateOptions","body","negative","toString","updateNamedReference","index","name","matchIndex","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","lastIndex","names","onNamedGroup","call","forEach","reference","map","term","push","rewritePattern","flags","options","regjsparserFeatures","unicodePropertyEscape","namedGroup","lookbehind","includes","supportDotAllFlag","dotAllFlag","create","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./` (only BMP code points).\nconst DOT_SET = DOT_SET_UNICODE.clone()\n\t.intersection(BMP_SET);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getDotSet = (unicode, dotAll) => {\n\tif (dotAll) {\n\t\treturn unicode ? UNICODE_SET : BMP_SET;\n\t}\n\treturn unicode ? DOT_SET_UNICODE : DOT_SET;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a binary\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\treturn UNICODE_SET.clone().remove(set);\n\t}\n\treturn set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet set = regenerate();\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\t}\n\tif (characterClassItem.negative) {\n\t\tset = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n\t}\n\tupdate(characterClassItem, set.toString(regenerateOptions));\n\treturn characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n\tdelete item.name;\n\titem.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetDotSet(config.unicode, config.dotAll).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\n\t\t\t\t\t.toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tgroups.lastIndex++;\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.names[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tdelete item.name;\n\n\t\t\t\tgroups.names[name] = index;\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\n\t\t\t\t\t\tupdateNamedReference(reference, index);\n\t\t\t\t\t});\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst index = groups.names[name];\n\t\t\t\tif (index) {\n\t\t\t\t\tupdateNamedReference(item, index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\n\t\t\t\t}\n\t\t\t\t// Keep track of references used before the corresponding group.\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'ignoreCase': false,\n\t'unicode': false,\n\t'dotAll': false,\n\t'useUnicodeFlag': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n\tconst regjsparserFeatures = {\n\t\t'unicodePropertyEscape': options && options.unicodePropertyEscape,\n\t\t'namedGroups': options && options.namedGroup,\n\t\t'lookbehind': options && options.lookbehind\n\t};\n\tconfig.ignoreCase = flags && flags.includes('i');\n\tconfig.unicode = flags && flags.includes('u');\n\tconst supportDotAllFlag = options && options.dotAllFlag;\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.unicode\n\t};\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: index }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\t};\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _getPrototypeOf = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _inherits = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:\\\\DEVELOPMENT\\\\react-project\\\\Quiz-react\\\\react-quiz-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar XHTMLEntities = require('./xhtml');\n\nvar hexNumber = /^[\\da-fA-F]+$/;\nvar decimalNumber = /^\\d+$/; // The map to `acorn-jsx` tokens from `acorn` namespace objects.\n\nvar acornJsxMap = new WeakMap(); // Get the original tokens for the given `acorn` namespace object.\n\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  var acornJsx = acornJsxMap.get(acorn);\n\n  if (!acornJsx) {\n    var tt = acorn.tokTypes;\n    var TokContext = acorn.TokContext;\n    var TokenType = acorn.TokenType;\n    var tc_oTag = new TokContext('<tag', false);\n    var tc_cTag = new TokContext('</tag', false);\n    var tc_expr = new TokContext('<tag>...</tag>', true, true);\n    var tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    var tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {\n        beforeExpr: true\n      }),\n      jsxTagStart: new TokenType('jsxTagStart'),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function () {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n\n      this.context.push(tc_oTag); // start opening tag context\n\n      this.exprAllowed = false;\n    };\n\n    tokTypes.jsxTagEnd.updateContext = function (prevType) {\n      var out = this.context.pop();\n\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = {\n      tokContexts: tokContexts,\n      tokTypes: tokTypes\n    };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n} // Transforms JSX element name to string.\n\n\nfunction getQualifiedJSXName(object) {\n  if (!object) return object;\n  if (object.type === 'JSXIdentifier') return object.name;\n  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;\n  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function (options) {\n  options = options || {};\n  return function (Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n}; // This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\n\n\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  var acorn = Parser.acorn || require(\"acorn\");\n\n  var acornJsx = getJsxTokens(acorn);\n  var tt = acorn.tokTypes;\n  var tok = acornJsx.tokTypes;\n  var tokContexts = acorn.tokContexts;\n  var tc_oTag = acornJsx.tokContexts.tc_oTag;\n  var tc_cTag = acornJsx.tokContexts.tc_cTag;\n  var tc_expr = acornJsx.tokContexts.tc_expr;\n  var isNewLine = acorn.isNewLine;\n  var isIdentifierStart = acorn.isIdentifierStart;\n  var isIdentifierChar = acorn.isIdentifierChar;\n  return /*#__PURE__*/function (_Parser) {\n    _inherits(_class, _Parser);\n\n    var _super = _createSuper(_class);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(_class, [{\n      key: \"jsx_readToken\",\n      // Reads inline JSX contents token.\n      value: function jsx_readToken() {\n        var out = '',\n            chunkStart = this.pos;\n\n        for (;;) {\n          if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');\n          var ch = this.input.charCodeAt(this.pos);\n\n          switch (ch) {\n            case 60: // '<'\n\n            case 123:\n              // '{'\n              if (this.pos === this.start) {\n                if (ch === 60 && this.exprAllowed) {\n                  ++this.pos;\n                  return this.finishToken(tok.jsxTagStart);\n                }\n\n                return this.getTokenFromCode(ch);\n              }\n\n              out += this.input.slice(chunkStart, this.pos);\n              return this.finishToken(tok.jsxText, out);\n\n            case 38:\n              // '&'\n              out += this.input.slice(chunkStart, this.pos);\n              out += this.jsx_readEntity();\n              chunkStart = this.pos;\n              break;\n\n            case 62: // '>'\n\n            case 125:\n              // '}'\n              this.raise(this.pos, \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" + (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\");\n\n            default:\n              if (isNewLine(ch)) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.jsx_readNewLine(true);\n                chunkStart = this.pos;\n              } else {\n                ++this.pos;\n              }\n\n          }\n        }\n      }\n    }, {\n      key: \"jsx_readNewLine\",\n      value: function jsx_readNewLine(normalizeCRLF) {\n        var ch = this.input.charCodeAt(this.pos);\n        var out;\n        ++this.pos;\n\n        if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n          ++this.pos;\n          out = normalizeCRLF ? '\\n' : '\\r\\n';\n        } else {\n          out = String.fromCharCode(ch);\n        }\n\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n\n        return out;\n      }\n    }, {\n      key: \"jsx_readString\",\n      value: function jsx_readString(quote) {\n        var out = '',\n            chunkStart = ++this.pos;\n\n        for (;;) {\n          if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');\n          var ch = this.input.charCodeAt(this.pos);\n          if (ch === quote) break;\n\n          if (ch === 38) {\n            // '&'\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readEntity();\n            chunkStart = this.pos;\n          } else if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(false);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.pos++);\n        return this.finishToken(tt.string, out);\n      }\n    }, {\n      key: \"jsx_readEntity\",\n      value: function jsx_readEntity() {\n        var str = '',\n            count = 0,\n            entity;\n        var ch = this.input[this.pos];\n        if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');\n        var startPos = ++this.pos;\n\n        while (this.pos < this.input.length && count++ < 10) {\n          ch = this.input[this.pos++];\n\n          if (ch === ';') {\n            if (str[0] === '#') {\n              if (str[1] === 'x') {\n                str = str.substr(2);\n                if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));\n              } else {\n                str = str.substr(1);\n                if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));\n              }\n            } else {\n              entity = XHTMLEntities[str];\n            }\n\n            break;\n          }\n\n          str += ch;\n        }\n\n        if (!entity) {\n          this.pos = startPos;\n          return '&';\n        }\n\n        return entity;\n      } // Read a JSX identifier (valid tag or attribute name).\n      //\n      // Optimized version since JSX identifiers can't contain\n      // escape characters and so can be read as single slice.\n      // Also assumes that first character was already checked\n      // by isIdentifierStart in readToken.\n\n    }, {\n      key: \"jsx_readWord\",\n      value: function jsx_readWord() {\n        var ch,\n            start = this.pos;\n\n        do {\n          ch = this.input.charCodeAt(++this.pos);\n        } while (isIdentifierChar(ch) || ch === 45); // '-'\n\n\n        return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n      } // Parse next token as JSX identifier\n\n    }, {\n      key: \"jsx_parseIdentifier\",\n      value: function jsx_parseIdentifier() {\n        var node = this.startNode();\n        if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();\n        this.next();\n        return this.finishNode(node, 'JSXIdentifier');\n      } // Parse namespaced identifier.\n\n    }, {\n      key: \"jsx_parseNamespacedName\",\n      value: function jsx_parseNamespacedName() {\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var name = this.jsx_parseIdentifier();\n        if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n        var node = this.startNodeAt(startPos, startLoc);\n        node.namespace = name;\n        node.name = this.jsx_parseIdentifier();\n        return this.finishNode(node, 'JSXNamespacedName');\n      } // Parses element name in any form - namespaced, member\n      // or single identifier.\n\n    }, {\n      key: \"jsx_parseElementName\",\n      value: function jsx_parseElementName() {\n        if (this.type === tok.jsxTagEnd) return '';\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var node = this.jsx_parseNamespacedName();\n\n        if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n          this.unexpected();\n        }\n\n        while (this.eat(tt.dot)) {\n          var newNode = this.startNodeAt(startPos, startLoc);\n          newNode.object = node;\n          newNode.property = this.jsx_parseIdentifier();\n          node = this.finishNode(newNode, 'JSXMemberExpression');\n        }\n\n        return node;\n      } // Parses any type of JSX attribute value.\n\n    }, {\n      key: \"jsx_parseAttributeValue\",\n      value: function jsx_parseAttributeValue() {\n        switch (this.type) {\n          case tt.braceL:\n            var node = this.jsx_parseExpressionContainer();\n            if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n            return node;\n\n          case tok.jsxTagStart:\n          case tt.string:\n            return this.parseExprAtom();\n\n          default:\n            this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n        }\n      } // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n      // and so it should start at the end of last read token (left brace) and finish\n      // at the beginning of the next one (right brace).\n\n    }, {\n      key: \"jsx_parseEmptyExpression\",\n      value: function jsx_parseEmptyExpression() {\n        var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n        return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n      } // Parses JSX expression enclosed into curly brackets.\n\n    }, {\n      key: \"jsx_parseExpressionContainer\",\n      value: function jsx_parseExpressionContainer() {\n        var node = this.startNode();\n        this.next();\n        node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXExpressionContainer');\n      } // Parses following JSX attribute name-value pair.\n\n    }, {\n      key: \"jsx_parseAttribute\",\n      value: function jsx_parseAttribute() {\n        var node = this.startNode();\n\n        if (this.eat(tt.braceL)) {\n          this.expect(tt.ellipsis);\n          node.argument = this.parseMaybeAssign();\n          this.expect(tt.braceR);\n          return this.finishNode(node, 'JSXSpreadAttribute');\n        }\n\n        node.name = this.jsx_parseNamespacedName();\n        node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n        return this.finishNode(node, 'JSXAttribute');\n      } // Parses JSX opening tag starting after '<'.\n\n    }, {\n      key: \"jsx_parseOpeningElementAt\",\n      value: function jsx_parseOpeningElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.attributes = [];\n        var nodeName = this.jsx_parseElementName();\n        if (nodeName) node.name = nodeName;\n\n        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) {\n          node.attributes.push(this.jsx_parseAttribute());\n        }\n\n        node.selfClosing = this.eat(tt.slash);\n        this.expect(tok.jsxTagEnd);\n        return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n      } // Parses JSX closing tag starting after '</'.\n\n    }, {\n      key: \"jsx_parseClosingElementAt\",\n      value: function jsx_parseClosingElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        var nodeName = this.jsx_parseElementName();\n        if (nodeName) node.name = nodeName;\n        this.expect(tok.jsxTagEnd);\n        return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n      } // Parses entire JSX element, including it's opening tag\n      // (starting after '<'), attributes, contents and closing tag.\n\n    }, {\n      key: \"jsx_parseElementAt\",\n      value: function jsx_parseElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        var children = [];\n        var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n        var closingElement = null;\n\n        if (!openingElement.selfClosing) {\n          contents: for (;;) {\n            switch (this.type) {\n              case tok.jsxTagStart:\n                startPos = this.start;\n                startLoc = this.startLoc;\n                this.next();\n\n                if (this.eat(tt.slash)) {\n                  closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n                  break contents;\n                }\n\n                children.push(this.jsx_parseElementAt(startPos, startLoc));\n                break;\n\n              case tok.jsxText:\n                children.push(this.parseExprAtom());\n                break;\n\n              case tt.braceL:\n                children.push(this.jsx_parseExpressionContainer());\n                break;\n\n              default:\n                this.unexpected();\n            }\n          }\n\n          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n            this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n          }\n        }\n\n        var fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n        node['opening' + fragmentOrElement] = openingElement;\n        node['closing' + fragmentOrElement] = closingElement;\n        node.children = children;\n\n        if (this.type === tt.relational && this.value === \"<\") {\n          this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n        }\n\n        return this.finishNode(node, 'JSX' + fragmentOrElement);\n      } // Parse JSX text\n\n    }, {\n      key: \"jsx_parseText\",\n      value: function jsx_parseText() {\n        var node = this.parseLiteral(this.value);\n        node.type = \"JSXText\";\n        return node;\n      } // Parses entire JSX element from current position.\n\n    }, {\n      key: \"jsx_parseElement\",\n      value: function jsx_parseElement() {\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        this.next();\n        return this.jsx_parseElementAt(startPos, startLoc);\n      }\n    }, {\n      key: \"parseExprAtom\",\n      value: function parseExprAtom(refShortHandDefaultPos) {\n        if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return _get(_getPrototypeOf(_class.prototype), \"parseExprAtom\", this).call(this, refShortHandDefaultPos);\n      }\n    }, {\n      key: \"readToken\",\n      value: function readToken(code) {\n        var context = this.curContext();\n        if (context === tc_expr) return this.jsx_readToken();\n\n        if (context === tc_oTag || context === tc_cTag) {\n          if (isIdentifierStart(code)) return this.jsx_readWord();\n\n          if (code == 62) {\n            ++this.pos;\n            return this.finishToken(tok.jsxTagEnd);\n          }\n\n          if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);\n        }\n\n        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagStart);\n        }\n\n        return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n      }\n    }, {\n      key: \"updateContext\",\n      value: function updateContext(prevType) {\n        if (this.type == tt.braceL) {\n          var curContext = this.curContext();\n          if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else _get(_getPrototypeOf(_class.prototype), \"updateContext\", this).call(this, prevType);\n          this.exprAllowed = true;\n        } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n\n          this.context.push(tc_cTag); // reconsider as closing tag context\n\n          this.exprAllowed = false;\n        } else {\n          return _get(_getPrototypeOf(_class.prototype), \"updateContext\", this).call(this, prevType);\n        }\n      }\n    }], [{\n      key: \"acornJsx\",\n      // Expose actual `tokTypes` and `tokContexts` to other plugins.\n      get: function get() {\n        return acornJsx;\n      }\n    }]);\n\n    return _class;\n  }(Parser);\n}","map":{"version":3,"sources":["D:/DEVELOPMENT/react-project/Quiz-react/react-quiz-app/node_modules/acorn-jsx/index.js"],"names":["XHTMLEntities","require","hexNumber","decimalNumber","acornJsxMap","WeakMap","getJsxTokens","acorn","Parser","acornJsx","get","tt","tokTypes","TokContext","TokenType","tc_oTag","tc_cTag","tc_expr","tokContexts","jsxName","jsxText","beforeExpr","jsxTagStart","jsxTagEnd","updateContext","context","push","exprAllowed","prevType","out","pop","slash","curContext","set","getQualifiedJSXName","object","type","name","namespace","property","module","exports","options","plugin","allowNamespaces","allowNamespacedObjects","Object","defineProperty","get_tokTypes","configurable","enumerable","tok","isNewLine","isIdentifierStart","isIdentifierChar","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","jsx_readNewLine","normalizeCRLF","String","fromCharCode","locations","curLine","lineStart","quote","string","str","count","entity","startPos","substr","test","parseInt","node","startNode","value","keyword","unexpected","next","finishNode","startLoc","jsx_parseIdentifier","eat","colon","startNodeAt","jsx_parseNamespacedName","dot","newNode","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","jsx_parseEmptyExpression","parseExpression","expect","ellipsis","argument","parseMaybeAssign","eq","jsx_parseAttributeValue","attributes","nodeName","jsx_parseElementName","jsx_parseAttribute","selfClosing","children","openingElement","jsx_parseOpeningElementAt","closingElement","contents","jsx_parseClosingElementAt","jsx_parseElementAt","fragmentOrElement","relational","parseLiteral","refShortHandDefaultPos","jsx_parseText","jsx_parseElement","code","jsx_readToken","jsx_readWord","jsx_readString","b_expr","b_tmpl"],"mappings":"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","sourcesContent":["'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {beforeExpr: true}),\n      jsxTagStart: new TokenType('jsxTagStart'),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function() {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object)\n    return object;\n\n  if (object.type === 'JSXIdentifier')\n    return object.name;\n\n  if (object.type === 'JSXNamespacedName')\n    return object.namespace.name + ':' + object.name.name;\n\n  if (object.type === 'JSXMemberExpression')\n    return getQualifiedJSXName(object.object) + '.' +\n    getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function(options) {\n  options = options || {};\n  return function(Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '', chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n        case 60: // '<'\n        case 123: // '{'\n          if (this.pos === this.start) {\n            if (ch === 60 && this.exprAllowed) {\n              ++this.pos;\n              return this.finishToken(tok.jsxTagStart);\n            }\n            return this.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.pos);\n          return this.finishToken(tok.jsxText, out);\n\n        case 38: // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n          break;\n\n        case 62: // '>'\n        case 125: // '}'\n          this.raise(\n            this.pos,\n            \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\n              (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\n          );\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(true);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '', chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) { // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '', count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&')\n        this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName)\n        node.name = this.value;\n      else if (this.type.keyword)\n        node.name = this.type.keyword;\n      else\n        this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n      case tt.braceL:\n        let node = this.jsx_parseExpressionContainer();\n        if (node.expression.type === 'JSXEmptyExpression')\n          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n        return node;\n\n      case tok.jsxTagStart:\n      case tt.string:\n        return this.parseExprAtom();\n\n      default:\n        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR\n        ? this.jsx_parseEmptyExpression()\n        : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n          case tok.jsxTagStart:\n            startPos = this.start; startLoc = this.startLoc;\n            this.next();\n            if (this.eat(tt.slash)) {\n              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n            children.push(this.jsx_parseElementAt(startPos, startLoc));\n            break;\n\n          case tok.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case tt.braceL:\n            children.push(this.jsx_parseExpressionContainer());\n            break;\n\n          default:\n            this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText)\n        return this.jsx_parseText();\n      else if (this.type === tok.jsxTagStart)\n        return this.jsx_parseElement();\n      else\n        return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag)\n          return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n        else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}
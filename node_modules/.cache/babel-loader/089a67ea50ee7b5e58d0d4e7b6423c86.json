{"ast":null,"code":"import \"core-js/modules/es.array.for-each\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.assign\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport isFinite from 'lodash/isFinite';\nimport filterComponentExamples from './filterComponentExamples';\nimport filterComponentsInSectionsByExactName from './filterComponentsInSectionsByExactName';\nimport filterSectionExamples from './filterSectionExamples';\nimport findSection from './findSection';\nimport getInfoFromHash from './getInfoFromHash';\nimport { DisplayModes } from '../consts';\n/**\n * Return sections / components / examples to show on a screen according to a current route.\n *\n * Default: show all sections and components.\n * #!/Button: show only Button section or Button component\n * #!/Button/1: show only the second example (index 1) of Button component\n *\n * @param {object} sections\n * @param {string} hash\n * @param {boolean} pagePerSection\n * @returns {object}\n */\n\nexport default function getRouteData(sections, hash, pagePerSection) {\n  if (pagePerSection === void 0) {\n    pagePerSection = false;\n  } // Parse URL hash to check if the components list must be filtered\n\n\n  var infoFromHash = getInfoFromHash(hash); // Name of the filtered component/section to show isolated (/#!/Button → Button)\n\n  var targetName = infoFromHash.targetName,\n      hashArray = infoFromHash.hashArray;\n  var targetIndex = infoFromHash.targetIndex,\n      isolate = infoFromHash.isolate;\n  var displayMode = isolate ? DisplayModes.example : DisplayModes.all;\n\n  if (pagePerSection && !targetName && sections[0] && sections[0].name) {\n    // For default takes the first section when pagePerSection enabled\n    targetName = sections[0].name;\n    hashArray = [targetName];\n  }\n\n  if (targetName) {\n    var filteredSections = [];\n\n    if (pagePerSection && hashArray) {\n      // hashArray could be an array as [\"Documentation\", \"Files\", \"Button\"]\n      // each hashArray's element represent each section name with the same deep\n      // so it should be filter each section to trying to find each one of array on the same deep\n      hashArray.forEach(function (hashName, index) {\n        // Filter the requested component if required but only on the first depth\n        // so in the next time of iteration, it will be trying to filter only on the second depth and so on\n        filteredSections = filterComponentsInSectionsByExactName(sections, hashName, !!isolate); // If filteredSections exists, its because is an array of an component\n        // else it is an array of sections and depending his sectionDepth\n        // his children could be filtered or not\n\n        if (filteredSections.length) {\n          sections = filteredSections;\n        } else {\n          var section = findSection(sections, hashName);\n\n          if (section) {\n            // Only if hashName is the last of hashArray his children should be filtered\n            // because else there are possibilities to keep on filtering to try find the next section\n            var isLastHashName = !hashArray || !hashArray[index + 1]; // When sectionDepth is bigger than 0, their children should be filtered\n\n            var shouldFilterTheirChildren = (section.sectionDepth || 0) > 0 && isLastHashName;\n\n            if (shouldFilterTheirChildren) {\n              // Filter his sections and components\n              section = Object.assign({}, section, {\n                sections: [],\n                components: []\n              });\n            }\n\n            sections = [section];\n          } else {\n            sections = [];\n          }\n        }\n      });\n\n      if (!sections.length) {\n        displayMode = DisplayModes.notFound;\n      } // The targetName takes the last of hashArray\n\n\n      targetName = hashArray[hashArray.length - 1];\n    } else {\n      // Filter the requested component if required\n      filteredSections = filterComponentsInSectionsByExactName(sections, targetName, true);\n\n      if (filteredSections.length) {\n        sections = filteredSections;\n        displayMode = DisplayModes.component;\n      } else {\n        var section = findSection(sections, targetName);\n        sections = section ? [section] : [];\n        displayMode = DisplayModes.section;\n      }\n    } // If a single component or section is filtered and a fenced block index is specified hide all other examples\n\n\n    if (isFinite(targetIndex)) {\n      if (filteredSections.length === 1) {\n        var filteredComponents = filteredSections[0].components;\n        sections = [Object.assign({}, filteredSections[0], {\n          components: filteredComponents && typeof targetIndex === 'number' ? [filterComponentExamples(filteredComponents[0], targetIndex)] : []\n        })];\n        displayMode = DisplayModes.example;\n      } else if (sections.length === 1) {\n        sections = [filterSectionExamples(sections[0], targetIndex)];\n        displayMode = DisplayModes.example;\n      }\n    }\n  }\n\n  return {\n    sections: sections,\n    displayMode: displayMode\n  };\n}","map":{"version":3,"sources":["D:/DEVELOPMENT/react-project/Quiz-react/react-quiz-app/node_modules/react-styleguidist/lib/client/utils/getRouteData.js"],"names":["isFinite","filterComponentExamples","filterComponentsInSectionsByExactName","filterSectionExamples","findSection","getInfoFromHash","DisplayModes","getRouteData","sections","hash","pagePerSection","infoFromHash","targetName","hashArray","targetIndex","isolate","displayMode","example","all","name","filteredSections","forEach","hashName","index","length","section","isLastHashName","shouldFilterTheirChildren","sectionDepth","Object","assign","components","notFound","component","filteredComponents"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.for-each\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.assign\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport isFinite from 'lodash/isFinite';\nimport filterComponentExamples from './filterComponentExamples';\nimport filterComponentsInSectionsByExactName from './filterComponentsInSectionsByExactName';\nimport filterSectionExamples from './filterSectionExamples';\nimport findSection from './findSection';\nimport getInfoFromHash from './getInfoFromHash';\nimport { DisplayModes } from '../consts';\n\n/**\n * Return sections / components / examples to show on a screen according to a current route.\n *\n * Default: show all sections and components.\n * #!/Button: show only Button section or Button component\n * #!/Button/1: show only the second example (index 1) of Button component\n *\n * @param {object} sections\n * @param {string} hash\n * @param {boolean} pagePerSection\n * @returns {object}\n */\nexport default function getRouteData(sections, hash, pagePerSection) {\n  if (pagePerSection === void 0) {\n    pagePerSection = false;\n  }\n\n  // Parse URL hash to check if the components list must be filtered\n  var infoFromHash = getInfoFromHash(hash); // Name of the filtered component/section to show isolated (/#!/Button → Button)\n\n  var targetName = infoFromHash.targetName,\n      hashArray = infoFromHash.hashArray;\n  var targetIndex = infoFromHash.targetIndex,\n      isolate = infoFromHash.isolate;\n  var displayMode = isolate ? DisplayModes.example : DisplayModes.all;\n\n  if (pagePerSection && !targetName && sections[0] && sections[0].name) {\n    // For default takes the first section when pagePerSection enabled\n    targetName = sections[0].name;\n    hashArray = [targetName];\n  }\n\n  if (targetName) {\n    var filteredSections = [];\n\n    if (pagePerSection && hashArray) {\n      // hashArray could be an array as [\"Documentation\", \"Files\", \"Button\"]\n      // each hashArray's element represent each section name with the same deep\n      // so it should be filter each section to trying to find each one of array on the same deep\n      hashArray.forEach(function (hashName, index) {\n        // Filter the requested component if required but only on the first depth\n        // so in the next time of iteration, it will be trying to filter only on the second depth and so on\n        filteredSections = filterComponentsInSectionsByExactName(sections, hashName, !!isolate); // If filteredSections exists, its because is an array of an component\n        // else it is an array of sections and depending his sectionDepth\n        // his children could be filtered or not\n\n        if (filteredSections.length) {\n          sections = filteredSections;\n        } else {\n          var section = findSection(sections, hashName);\n\n          if (section) {\n            // Only if hashName is the last of hashArray his children should be filtered\n            // because else there are possibilities to keep on filtering to try find the next section\n            var isLastHashName = !hashArray || !hashArray[index + 1]; // When sectionDepth is bigger than 0, their children should be filtered\n\n            var shouldFilterTheirChildren = (section.sectionDepth || 0) > 0 && isLastHashName;\n\n            if (shouldFilterTheirChildren) {\n              // Filter his sections and components\n              section = Object.assign({}, section, {\n                sections: [],\n                components: []\n              });\n            }\n\n            sections = [section];\n          } else {\n            sections = [];\n          }\n        }\n      });\n\n      if (!sections.length) {\n        displayMode = DisplayModes.notFound;\n      } // The targetName takes the last of hashArray\n\n\n      targetName = hashArray[hashArray.length - 1];\n    } else {\n      // Filter the requested component if required\n      filteredSections = filterComponentsInSectionsByExactName(sections, targetName, true);\n\n      if (filteredSections.length) {\n        sections = filteredSections;\n        displayMode = DisplayModes.component;\n      } else {\n        var section = findSection(sections, targetName);\n        sections = section ? [section] : [];\n        displayMode = DisplayModes.section;\n      }\n    } // If a single component or section is filtered and a fenced block index is specified hide all other examples\n\n\n    if (isFinite(targetIndex)) {\n      if (filteredSections.length === 1) {\n        var filteredComponents = filteredSections[0].components;\n        sections = [Object.assign({}, filteredSections[0], {\n          components: filteredComponents && typeof targetIndex === 'number' ? [filterComponentExamples(filteredComponents[0], targetIndex)] : []\n        })];\n        displayMode = DisplayModes.example;\n      } else if (sections.length === 1) {\n        sections = [filterSectionExamples(sections[0], targetIndex)];\n        displayMode = DisplayModes.example;\n      }\n    }\n  }\n\n  return {\n    sections: sections,\n    displayMode: displayMode\n  };\n}"]},"metadata":{},"sourceType":"module"}
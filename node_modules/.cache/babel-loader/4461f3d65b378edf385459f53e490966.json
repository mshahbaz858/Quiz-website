{"ast":null,"code":"import { Parser } from 'acorn';\nimport acornJsx from 'acorn-jsx';\nimport acornDynamicImport from 'acorn-dynamic-import';\nimport MagicString from 'magic-string';\nimport rewritePattern from 'regexpu-core'; // used for debugging, without the noise created by\n// circular references\n\nfunction toJSON(node) {\n  var obj = {};\n  Object.keys(node).forEach(function (key) {\n    if (key === 'parent' || key === 'program' || key === 'keys' || key === '__wrapped') {\n      return;\n    }\n\n    if (Array.isArray(node[key])) {\n      obj[key] = node[key].map(toJSON);\n    } else if (node[key] && node[key].toJSON) {\n      obj[key] = node[key].toJSON();\n    } else {\n      obj[key] = node[key];\n    }\n  });\n  return obj;\n}\n\nvar Node = function Node() {};\n\nNode.prototype.ancestor = function ancestor(level) {\n  var node = this;\n\n  while (level--) {\n    node = node.parent;\n\n    if (!node) {\n      return null;\n    }\n  }\n\n  return node;\n};\n\nNode.prototype.contains = function contains(node) {\n  while (node) {\n    if (node === this) {\n      return true;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n};\n\nNode.prototype.findLexicalBoundary = function findLexicalBoundary() {\n  return this.parent.findLexicalBoundary();\n};\n\nNode.prototype.findNearest = function findNearest(type) {\n  if (typeof type === 'string') {\n    type = new RegExp(\"^\" + type + \"$\");\n  }\n\n  if (type.test(this.type)) {\n    return this;\n  }\n\n  return this.parent.findNearest(type);\n};\n\nNode.prototype.unparenthesizedParent = function unparenthesizedParent() {\n  var node = this.parent;\n\n  while (node && node.type === 'ParenthesizedExpression') {\n    node = node.parent;\n  }\n\n  return node;\n};\n\nNode.prototype.unparenthesize = function unparenthesize() {\n  var node = this;\n\n  while (node.type === 'ParenthesizedExpression') {\n    node = node.expression;\n  }\n\n  return node;\n};\n\nNode.prototype.findScope = function findScope(functionScope) {\n  return this.parent.findScope(functionScope);\n};\n\nNode.prototype.getIndentation = function getIndentation() {\n  return this.parent.getIndentation();\n};\n\nNode.prototype.initialise = function initialise(transforms) {\n  for (var i = 0, list = this.keys; i < list.length; i += 1) {\n    var key = list[i];\n    var value = this[key];\n\n    if (Array.isArray(value)) {\n      value.forEach(function (node) {\n        return node && node.initialise(transforms);\n      });\n    } else if (value && typeof value === 'object') {\n      value.initialise(transforms);\n    }\n  }\n};\n\nNode.prototype.toJSON = function toJSON$1() {\n  return toJSON(this);\n};\n\nNode.prototype.toString = function toString() {\n  return this.program.magicString.original.slice(this.start, this.end);\n};\n\nNode.prototype.transpile = function transpile(code, transforms) {\n  for (var i = 0, list = this.keys; i < list.length; i += 1) {\n    var key = list[i];\n    var value = this[key];\n\n    if (Array.isArray(value)) {\n      value.forEach(function (node) {\n        return node && node.transpile(code, transforms);\n      });\n    } else if (value && typeof value === 'object') {\n      value.transpile(code, transforms);\n    }\n  }\n};\n\nfunction extractNames(node) {\n  var names = [];\n  extractors[node.type](names, node);\n  return names;\n}\n\nvar extractors = {\n  Identifier: function Identifier(names, node) {\n    names.push(node);\n  },\n  ObjectPattern: function ObjectPattern(names, node) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      extractors[prop.type](names, prop);\n    }\n  },\n  Property: function Property(names, node) {\n    extractors[node.value.type](names, node.value);\n  },\n  ArrayPattern: function ArrayPattern(names, node) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var element = list[i];\n\n      if (element) {\n        extractors[element.type](names, element);\n      }\n    }\n  },\n  RestElement: function RestElement(names, node) {\n    extractors[node.argument.type](names, node.argument);\n  },\n  AssignmentPattern: function AssignmentPattern(names, node) {\n    extractors[node.left.type](names, node.left);\n  }\n};\nvar reserved = Object.create(null);\n'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'.split(' ').forEach(function (word) {\n  return reserved[word] = true;\n});\n\nfunction Scope(options) {\n  options = options || {};\n  this.parent = options.parent;\n  this.isBlockScope = !!options.block;\n  this.createDeclarationCallback = options.declare;\n  var scope = this;\n\n  while (scope.isBlockScope) {\n    scope = scope.parent;\n  }\n\n  this.functionScope = scope;\n  this.identifiers = [];\n  this.declarations = Object.create(null);\n  this.references = Object.create(null);\n  this.blockScopedDeclarations = this.isBlockScope ? null : Object.create(null);\n  this.aliases = Object.create(null);\n}\n\nScope.prototype = {\n  addDeclaration: function addDeclaration(node, kind) {\n    for (var i = 0, list = extractNames(node); i < list.length; i += 1) {\n      var identifier = list[i];\n      var name = identifier.name;\n      var declaration = {\n        name: name,\n        node: identifier,\n        kind: kind,\n        instances: []\n      };\n      this.declarations[name] = declaration;\n\n      if (this.isBlockScope) {\n        if (!this.functionScope.blockScopedDeclarations[name]) {\n          this.functionScope.blockScopedDeclarations[name] = [];\n        }\n\n        this.functionScope.blockScopedDeclarations[name].push(declaration);\n      }\n    }\n  },\n  addReference: function addReference(identifier) {\n    if (this.consolidated) {\n      this.consolidateReference(identifier);\n    } else {\n      this.identifiers.push(identifier);\n    }\n  },\n  consolidate: function consolidate() {\n    for (var i = 0; i < this.identifiers.length; i += 1) {\n      // we might push to the array during consolidation, so don't cache length\n      var identifier = this.identifiers[i];\n      this.consolidateReference(identifier);\n    }\n\n    this.consolidated = true; // TODO understand why this is necessary... seems bad\n  },\n  consolidateReference: function consolidateReference(identifier) {\n    var declaration = this.declarations[identifier.name];\n\n    if (declaration) {\n      declaration.instances.push(identifier);\n    } else {\n      this.references[identifier.name] = true;\n\n      if (this.parent) {\n        this.parent.addReference(identifier);\n      }\n    }\n  },\n  contains: function contains(name) {\n    return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n  },\n  createIdentifier: function createIdentifier(base) {\n    if (typeof base === 'number') {\n      base = base.toString();\n    }\n\n    base = base.replace(/\\s/g, '').replace(/\\[([^\\]]+)\\]/g, '_$1').replace(/[^a-zA-Z0-9_$]/g, '_').replace(/_{2,}/, '_');\n    var name = base;\n    var counter = 1;\n\n    while (this.declarations[name] || this.references[name] || this.aliases[name] || name in reserved) {\n      name = base + \"$\" + counter++;\n    }\n\n    this.aliases[name] = true;\n    return name;\n  },\n  createDeclaration: function createDeclaration(base) {\n    var id = this.createIdentifier(base);\n    this.createDeclarationCallback(id);\n    return id;\n  },\n  findDeclaration: function findDeclaration(name) {\n    return this.declarations[name] || this.parent && this.parent.findDeclaration(name);\n  },\n  // Sometimes, block scope declarations change name during transpilation\n  resolveName: function resolveName(name) {\n    var declaration = this.findDeclaration(name);\n    return declaration ? declaration.name : name;\n  }\n};\n\nfunction locate(source, index) {\n  var lines = source.split('\\n');\n  var len = lines.length;\n  var lineStart = 0;\n  var i;\n\n  for (i = 0; i < len; i += 1) {\n    var line = lines[i];\n    var lineEnd = lineStart + line.length + 1; // +1 for newline\n\n    if (lineEnd > index) {\n      return {\n        line: i + 1,\n        column: index - lineStart,\n        char: i\n      };\n    }\n\n    lineStart = lineEnd;\n  }\n\n  throw new Error('Could not determine location of character');\n}\n\nfunction pad(num, len) {\n  var result = String(num);\n  return result + repeat(' ', len - result.length);\n}\n\nfunction repeat(str, times) {\n  var result = '';\n\n  while (times--) {\n    result += str;\n  }\n\n  return result;\n}\n\nfunction getSnippet(source, loc, length) {\n  if (length === void 0) length = 1;\n  var first = Math.max(loc.line - 5, 0);\n  var last = loc.line;\n  var numDigits = String(last).length;\n  var lines = source.split('\\n').slice(first, last);\n  var lastLine = lines[lines.length - 1];\n  var offset = lastLine.slice(0, loc.column).replace(/\\t/g, '  ').length;\n  var snippet = lines.map(function (line, i) {\n    return pad(i + first + 1, numDigits) + \" : \" + line.replace(/\\t/g, '  ');\n  }).join('\\n');\n  snippet += '\\n' + repeat(' ', numDigits + 3 + offset) + repeat('^', length);\n  return snippet;\n}\n\nvar CompileError = /*@__PURE__*/function (Error) {\n  function CompileError(message, node) {\n    Error.call(this, message);\n    this.name = 'CompileError';\n\n    if (!node) {\n      return;\n    }\n\n    var source = node.program.magicString.original;\n    var loc = locate(source, node.start);\n    this.message = message + \" (\" + loc.line + \":\" + loc.column + \")\";\n    this.stack = new Error().stack.replace(new RegExp(\".+new \" + this.name + \".+\\\\n\", 'm'), '');\n    this.loc = loc;\n    this.snippet = getSnippet(source, loc, node.end - node.start);\n  }\n\n  if (Error) CompileError.__proto__ = Error;\n  CompileError.prototype = Object.create(Error && Error.prototype);\n  CompileError.prototype.constructor = CompileError;\n\n  CompileError.prototype.toString = function toString() {\n    return this.name + \": \" + this.message + \"\\n\" + this.snippet;\n  };\n\n  CompileError.missingTransform = function missingTransform(feature, transformKey, node, dangerousKey) {\n    if (dangerousKey === void 0) dangerousKey = null;\n    var maybeDangerous = dangerousKey ? \", or `transforms: { \" + dangerousKey + \": true }` if you know what you're doing\" : '';\n    throw new CompileError(\"Transforming \" + feature + \" is not \" + (dangerousKey ? \"fully supported\" : \"implemented\") + \". Use `transforms: { \" + transformKey + \": false }` to skip transformation and disable this error\" + maybeDangerous + \".\", node);\n  };\n\n  return CompileError;\n}(Error);\n\nfunction findIndex(array, fn) {\n  for (var i = 0; i < array.length; i += 1) {\n    if (fn(array[i], i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nvar handlers = {\n  Identifier: destructureIdentifier,\n  AssignmentPattern: destructureAssignmentPattern,\n  ArrayPattern: destructureArrayPattern,\n  ObjectPattern: destructureObjectPattern\n};\n\nfunction destructure(code, createIdentifier, resolveName, node, ref, inline, statementGenerators) {\n  handlers[node.type](code, createIdentifier, resolveName, node, ref, inline, statementGenerators);\n}\n\nfunction destructureIdentifier(code, createIdentifier, resolveName, node, ref, inline, statementGenerators) {\n  statementGenerators.push(function (start, prefix, suffix) {\n    code.overwrite(node.start, node.end, (inline ? prefix : prefix + \"var \") + resolveName(node) + \" = \" + ref + suffix);\n    code.move(node.start, node.end, start);\n  });\n}\n\nfunction destructureMemberExpression(code, createIdentifier, resolveName, node, ref, inline, statementGenerators) {\n  statementGenerators.push(function (start, prefix, suffix) {\n    code.prependRight(node.start, inline ? prefix : prefix + \"var \");\n    code.appendLeft(node.end, \" = \" + ref + suffix);\n    code.move(node.start, node.end, start);\n  });\n}\n\nfunction destructureAssignmentPattern(code, createIdentifier, resolveName, node, ref, inline, statementGenerators) {\n  var isIdentifier = node.left.type === 'Identifier';\n  var name = isIdentifier ? node.left.name : ref;\n\n  if (!inline) {\n    statementGenerators.push(function (start, prefix, suffix) {\n      code.prependRight(node.left.end, prefix + \"if ( \" + name + \" === void 0 ) \" + name);\n      code.move(node.left.end, node.right.end, start);\n      code.appendLeft(node.right.end, suffix);\n    });\n  }\n\n  if (!isIdentifier) {\n    destructure(code, createIdentifier, resolveName, node.left, ref, inline, statementGenerators);\n  }\n}\n\nfunction destructureArrayPattern(code, createIdentifier, resolveName, node, ref, inline, statementGenerators) {\n  var c = node.start;\n  node.elements.forEach(function (element, i) {\n    if (!element) {\n      return;\n    }\n\n    if (element.type === 'RestElement') {\n      handleProperty(code, createIdentifier, resolveName, c, element.argument, ref + \".slice(\" + i + \")\", inline, statementGenerators);\n    } else {\n      handleProperty(code, createIdentifier, resolveName, c, element, ref + \"[\" + i + \"]\", inline, statementGenerators);\n    }\n\n    c = element.end;\n  });\n  code.remove(c, node.end);\n}\n\nfunction destructureObjectPattern(code, createIdentifier, resolveName, node, ref, inline, statementGenerators) {\n  var this$1 = this;\n  var c = node.start;\n  var nonRestKeys = [];\n  node.properties.forEach(function (prop) {\n    var value;\n    var content;\n\n    if (prop.type === 'Property') {\n      content = prop.value;\n\n      if (!prop.computed && prop.key.type === 'Identifier') {\n        value = ref + \".\" + prop.key.name;\n        nonRestKeys.push(\"\\\"\" + prop.key.name + \"\\\"\");\n      } else if (!prop.computed && prop.key.type === 'Literal') {\n        value = ref + \"[\" + prop.key.raw + \"]\";\n        nonRestKeys.push(JSON.stringify(String(prop.key.value)));\n      } else {\n        var expr = code.slice(prop.key.start, prop.key.end);\n        value = ref + \"[\" + expr + \"]\";\n        nonRestKeys.push(\"String(\" + expr + \")\");\n      }\n    } else if (prop.type === 'RestElement') {\n      content = prop.argument;\n      value = createIdentifier('rest');\n      statementGenerators.push(function (start, prefix, suffix) {\n        var helper = prop.program.getObjectWithoutPropertiesHelper(code);\n        code.overwrite(prop.start, c = prop.argument.start, (inline ? prefix : prefix + \"var \") + value + \" = \" + helper + \"( \" + ref + \", [\" + nonRestKeys.join(', ') + \"] )\" + suffix);\n        code.move(prop.start, c, start);\n      });\n    } else {\n      throw new CompileError(this$1, \"Unexpected node of type \" + prop.type + \" in object pattern\");\n    }\n\n    handleProperty(code, createIdentifier, resolveName, c, content, value, inline, statementGenerators);\n    c = prop.end;\n  });\n  code.remove(c, node.end);\n}\n\nfunction handleProperty(code, createIdentifier, resolveName, c, node, value, inline, statementGenerators) {\n  switch (node.type) {\n    case 'Identifier':\n      {\n        code.remove(c, node.start);\n        destructureIdentifier(code, createIdentifier, resolveName, node, value, inline, statementGenerators);\n        break;\n      }\n\n    case 'MemberExpression':\n      code.remove(c, node.start);\n      destructureMemberExpression(code, createIdentifier, resolveName, node, value, true, statementGenerators);\n      break;\n\n    case 'AssignmentPattern':\n      {\n        var name;\n        var isIdentifier = node.left.type === 'Identifier';\n\n        if (isIdentifier) {\n          name = resolveName(node.left);\n        } else {\n          name = createIdentifier(value);\n        }\n\n        statementGenerators.push(function (start, prefix, suffix) {\n          if (inline) {\n            code.prependRight(node.right.start, name + \" = \" + value + \", \" + name + \" = \" + name + \" === void 0 ? \");\n            code.appendLeft(node.right.end, \" : \" + name + suffix);\n          } else {\n            code.prependRight(node.right.start, prefix + \"var \" + name + \" = \" + value + \"; if ( \" + name + \" === void 0 ) \" + name + \" = \");\n            code.appendLeft(node.right.end, suffix);\n          }\n\n          code.move(node.right.start, node.right.end, start);\n        });\n\n        if (isIdentifier) {\n          code.remove(c, node.right.start);\n        } else {\n          code.remove(c, node.left.start);\n          code.remove(node.left.end, node.right.start);\n          handleProperty(code, createIdentifier, resolveName, c, node.left, name, inline, statementGenerators);\n        }\n\n        break;\n      }\n\n    case 'ObjectPattern':\n      {\n        code.remove(c, c = node.start);\n        var ref = value;\n\n        if (node.properties.length > 1) {\n          ref = createIdentifier(value);\n          statementGenerators.push(function (start, prefix, suffix) {\n            // this feels a tiny bit hacky, but we can't do a\n            // straightforward appendLeft and keep correct order...\n            code.prependRight(node.start, (inline ? '' : prefix + \"var \") + ref + \" = \");\n            code.overwrite(node.start, c = node.start + 1, value);\n            code.appendLeft(c, suffix);\n            code.overwrite(node.start, c = node.start + 1, (inline ? '' : prefix + \"var \") + ref + \" = \" + value + suffix);\n            code.move(node.start, c, start);\n          });\n        }\n\n        destructureObjectPattern(code, createIdentifier, resolveName, node, ref, inline, statementGenerators);\n        break;\n      }\n\n    case 'ArrayPattern':\n      {\n        code.remove(c, c = node.start);\n\n        if (node.elements.filter(Boolean).length > 1) {\n          var ref$1 = createIdentifier(value);\n          statementGenerators.push(function (start, prefix, suffix) {\n            code.prependRight(node.start, (inline ? '' : prefix + \"var \") + ref$1 + \" = \");\n            code.overwrite(node.start, c = node.start + 1, value, {\n              contentOnly: true\n            });\n            code.appendLeft(c, suffix);\n            code.move(node.start, c, start);\n          });\n          node.elements.forEach(function (element, i) {\n            if (!element) {\n              return;\n            }\n\n            if (element.type === 'RestElement') {\n              handleProperty(code, createIdentifier, resolveName, c, element.argument, ref$1 + \".slice(\" + i + \")\", inline, statementGenerators);\n            } else {\n              handleProperty(code, createIdentifier, resolveName, c, element, ref$1 + \"[\" + i + \"]\", inline, statementGenerators);\n            }\n\n            c = element.end;\n          });\n        } else {\n          var index = findIndex(node.elements, Boolean);\n          var element = node.elements[index];\n\n          if (element.type === 'RestElement') {\n            handleProperty(code, createIdentifier, resolveName, c, element.argument, value + \".slice(\" + index + \")\", inline, statementGenerators);\n          } else {\n            handleProperty(code, createIdentifier, resolveName, c, element, value + \"[\" + index + \"]\", inline, statementGenerators);\n          }\n\n          c = element.end;\n        }\n\n        code.remove(c, node.end);\n        break;\n      }\n\n    default:\n      {\n        throw new Error(\"Unexpected node type in destructuring (\" + node.type + \")\");\n      }\n  }\n}\n\nfunction isUseStrict(node) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.type !== 'ExpressionStatement') {\n    return false;\n  }\n\n  if (node.expression.type !== 'Literal') {\n    return false;\n  }\n\n  return node.expression.value === 'use strict';\n}\n\nvar BlockStatement = /*@__PURE__*/function (Node) {\n  function BlockStatement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) BlockStatement.__proto__ = Node;\n  BlockStatement.prototype = Object.create(Node && Node.prototype);\n  BlockStatement.prototype.constructor = BlockStatement;\n\n  BlockStatement.prototype.createScope = function createScope() {\n    var this$1 = this;\n    this.parentIsFunction = /Function/.test(this.parent.type);\n    this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';\n    this.scope = new Scope({\n      block: !this.isFunctionBlock,\n      parent: this.parent.findScope(false),\n      declare: function declare(id) {\n        return this$1.createdDeclarations.push(id);\n      }\n    });\n\n    if (this.parentIsFunction) {\n      this.parent.params.forEach(function (node) {\n        this$1.scope.addDeclaration(node, 'param');\n      });\n    }\n  };\n\n  BlockStatement.prototype.initialise = function initialise(transforms) {\n    this.thisAlias = null;\n    this.argumentsAlias = null;\n    this.defaultParameters = [];\n    this.createdDeclarations = []; // normally the scope gets created here, during initialisation,\n    // but in some cases (e.g. `for` statements), we need to create\n    // the scope early, as it pertains to both the init block and\n    // the body of the statement\n\n    if (!this.scope) {\n      this.createScope();\n    }\n\n    this.body.forEach(function (node) {\n      return node.initialise(transforms);\n    });\n    this.scope.consolidate();\n  };\n\n  BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary() {\n    if (this.type === 'Program') {\n      return this;\n    }\n\n    if (/^Function/.test(this.parent.type)) {\n      return this;\n    }\n\n    return this.parent.findLexicalBoundary();\n  };\n\n  BlockStatement.prototype.findScope = function findScope(functionScope) {\n    if (functionScope && !this.isFunctionBlock) {\n      return this.parent.findScope(functionScope);\n    }\n\n    return this.scope;\n  };\n\n  BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias() {\n    if (!this.argumentsAlias) {\n      this.argumentsAlias = this.scope.createIdentifier('arguments');\n    }\n\n    return this.argumentsAlias;\n  };\n\n  BlockStatement.prototype.getArgumentsArrayAlias = function getArgumentsArrayAlias() {\n    if (!this.argumentsArrayAlias) {\n      this.argumentsArrayAlias = this.scope.createIdentifier('argsArray');\n    }\n\n    return this.argumentsArrayAlias;\n  };\n\n  BlockStatement.prototype.getThisAlias = function getThisAlias() {\n    if (!this.thisAlias) {\n      this.thisAlias = this.scope.createIdentifier('this');\n    }\n\n    return this.thisAlias;\n  };\n\n  BlockStatement.prototype.getIndentation = function getIndentation() {\n    if (this.indentation === undefined) {\n      var source = this.program.magicString.original;\n      var useOuter = this.synthetic || !this.body.length;\n      var c = useOuter ? this.start : this.body[0].start;\n\n      while (c && source[c] !== '\\n') {\n        c -= 1;\n      }\n\n      this.indentation = ''; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        c += 1;\n        var char = source[c];\n\n        if (char !== ' ' && char !== '\\t') {\n          break;\n        }\n\n        this.indentation += char;\n      }\n\n      var indentString = this.program.magicString.getIndentString(); // account for dedented class constructors\n\n      var parent = this.parent;\n\n      while (parent) {\n        if (parent.kind === 'constructor' && !parent.parent.parent.superClass) {\n          this.indentation = this.indentation.replace(indentString, '');\n        }\n\n        parent = parent.parent;\n      }\n\n      if (useOuter) {\n        this.indentation += indentString;\n      }\n    }\n\n    return this.indentation;\n  };\n\n  BlockStatement.prototype.transpile = function transpile(code, transforms) {\n    var this$1 = this;\n    var indentation = this.getIndentation();\n    var introStatementGenerators = [];\n\n    if (this.argumentsAlias) {\n      introStatementGenerators.push(function (start, prefix, suffix) {\n        var assignment = prefix + \"var \" + this$1.argumentsAlias + \" = arguments\" + suffix;\n        code.appendLeft(start, assignment);\n      });\n    }\n\n    if (this.thisAlias) {\n      introStatementGenerators.push(function (start, prefix, suffix) {\n        var assignment = prefix + \"var \" + this$1.thisAlias + \" = this\" + suffix;\n        code.appendLeft(start, assignment);\n      });\n    }\n\n    if (this.argumentsArrayAlias) {\n      introStatementGenerators.push(function (start, prefix, suffix) {\n        var i = this$1.scope.createIdentifier('i');\n        var assignment = prefix + \"var \" + i + \" = arguments.length, \" + this$1.argumentsArrayAlias + \" = Array(\" + i + \");\\n\" + indentation + \"while ( \" + i + \"-- ) \" + this$1.argumentsArrayAlias + \"[\" + i + \"] = arguments[\" + i + \"]\" + suffix;\n        code.appendLeft(start, assignment);\n      });\n    }\n\n    if (/Function/.test(this.parent.type)) {\n      this.transpileParameters(this.parent.params, code, transforms, indentation, introStatementGenerators);\n    } else if ('CatchClause' === this.parent.type) {\n      this.transpileParameters([this.parent.param], code, transforms, indentation, introStatementGenerators);\n    }\n\n    if (transforms.letConst && this.isFunctionBlock) {\n      this.transpileBlockScopedIdentifiers(code);\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (this.createdDeclarations.length) {\n      introStatementGenerators.push(function (start, prefix, suffix) {\n        var assignment = prefix + \"var \" + this$1.createdDeclarations.join(', ') + suffix;\n        code.appendLeft(start, assignment);\n      });\n    }\n\n    if (this.synthetic) {\n      if (this.parent.type === 'ArrowFunctionExpression') {\n        var expr = this.body[0];\n\n        if (introStatementGenerators.length) {\n          code.appendLeft(this.start, \"{\").prependRight(this.end, this.parent.getIndentation() + \"}\");\n          code.prependRight(expr.start, \"\\n\" + indentation + \"return \");\n          code.appendLeft(expr.end, \";\\n\");\n        } else if (transforms.arrow) {\n          code.prependRight(expr.start, \"{ return \");\n          code.appendLeft(expr.end, \"; }\");\n        }\n      } else if (introStatementGenerators.length) {\n        code.prependRight(this.start, \"{\").appendLeft(this.end, \"}\");\n      }\n    }\n\n    var start;\n\n    if (isUseStrict(this.body[0])) {\n      start = this.body[0].end;\n    } else if (this.synthetic || this.parent.type === 'Root') {\n      start = this.start;\n    } else {\n      start = this.start + 1;\n    }\n\n    var prefix = \"\\n\" + indentation;\n    var suffix = ';';\n    introStatementGenerators.forEach(function (fn, i) {\n      if (i === introStatementGenerators.length - 1) {\n        suffix = \";\\n\";\n      }\n\n      fn(start, prefix, suffix);\n    });\n  };\n\n  BlockStatement.prototype.transpileParameters = function transpileParameters(params, code, transforms, indentation, introStatementGenerators) {\n    var this$1 = this;\n    params.forEach(function (param) {\n      if (param.type === 'AssignmentPattern' && param.left.type === 'Identifier') {\n        if (transforms.defaultParameter) {\n          introStatementGenerators.push(function (start, prefix, suffix) {\n            var lhs = prefix + \"if ( \" + param.left.name + \" === void 0 ) \" + param.left.name;\n            code.prependRight(param.left.end, lhs).move(param.left.end, param.right.end, start).appendLeft(param.right.end, suffix);\n          });\n        }\n      } else if (param.type === 'RestElement') {\n        if (transforms.spreadRest) {\n          introStatementGenerators.push(function (start, prefix, suffix) {\n            var penultimateParam = params[params.length - 2];\n\n            if (penultimateParam) {\n              code.remove(penultimateParam ? penultimateParam.end : param.start, param.end);\n            } else {\n              var start$1 = param.start,\n                  end = param.end; // TODO https://gitlab.com/Rich-Harris/buble/issues/8\n\n              while (/\\s/.test(code.original[start$1 - 1])) {\n                start$1 -= 1;\n              }\n\n              while (/\\s/.test(code.original[end])) {\n                end += 1;\n              }\n\n              code.remove(start$1, end);\n            }\n\n            var name = param.argument.name;\n            var len = this$1.scope.createIdentifier('len');\n            var count = params.length - 1;\n\n            if (count) {\n              code.prependRight(start, prefix + \"var \" + name + \" = [], \" + len + \" = arguments.length - \" + count + \";\\n\" + indentation + \"while ( \" + len + \"-- > 0 ) \" + name + \"[ \" + len + \" ] = arguments[ \" + len + \" + \" + count + \" ]\" + suffix);\n            } else {\n              code.prependRight(start, prefix + \"var \" + name + \" = [], \" + len + \" = arguments.length;\\n\" + indentation + \"while ( \" + len + \"-- ) \" + name + \"[ \" + len + \" ] = arguments[ \" + len + \" ]\" + suffix);\n            }\n          });\n        }\n      } else if (param.type !== 'Identifier') {\n        if (transforms.parameterDestructuring) {\n          var ref = this$1.scope.createIdentifier('ref');\n          destructure(code, function (id) {\n            return this$1.scope.createIdentifier(id);\n          }, function (ref) {\n            var name = ref.name;\n            return this$1.scope.resolveName(name);\n          }, param, ref, false, introStatementGenerators);\n          code.prependRight(param.start, ref);\n        }\n      }\n    });\n  };\n\n  BlockStatement.prototype.transpileBlockScopedIdentifiers = function transpileBlockScopedIdentifiers(code) {\n    var this$1 = this;\n    Object.keys(this.scope.blockScopedDeclarations).forEach(function (name) {\n      var declarations = this$1.scope.blockScopedDeclarations[name];\n\n      for (var i$2 = 0, list$2 = declarations; i$2 < list$2.length; i$2 += 1) {\n        var declaration = list$2[i$2];\n        var cont = false; // TODO implement proper continue...\n\n        if (declaration.kind === 'for.let') {\n          // special case\n          var forStatement = declaration.node.findNearest('ForStatement');\n\n          if (forStatement.shouldRewriteAsFunction) {\n            var outerAlias = this$1.scope.createIdentifier(name);\n            var innerAlias = forStatement.reassigned[name] ? this$1.scope.createIdentifier(name) : name;\n            declaration.name = outerAlias;\n            code.overwrite(declaration.node.start, declaration.node.end, outerAlias, {\n              storeName: true\n            });\n            forStatement.aliases[name] = {\n              outer: outerAlias,\n              inner: innerAlias\n            };\n\n            for (var i = 0, list = declaration.instances; i < list.length; i += 1) {\n              var identifier = list[i];\n              var alias = forStatement.body.contains(identifier) ? innerAlias : outerAlias;\n\n              if (name !== alias) {\n                code.overwrite(identifier.start, identifier.end, alias, {\n                  storeName: true\n                });\n              }\n            }\n\n            cont = true;\n          }\n        }\n\n        if (!cont) {\n          var alias$1 = this$1.scope.createIdentifier(name);\n\n          if (name !== alias$1) {\n            var declarationParent = declaration.node.parent;\n            declaration.name = alias$1;\n            code.overwrite(declaration.node.start, declaration.node.end, alias$1, {\n              storeName: true\n            });\n\n            if (declarationParent.type === 'Property' && declarationParent.shorthand) {\n              declarationParent.shorthand = false;\n              code.prependLeft(declaration.node.start, name + \": \");\n            }\n\n            for (var i$1 = 0, list$1 = declaration.instances; i$1 < list$1.length; i$1 += 1) {\n              var identifier$1 = list$1[i$1];\n              identifier$1.rewritten = true;\n              var identifierParent = identifier$1.parent;\n              code.overwrite(identifier$1.start, identifier$1.end, alias$1, {\n                storeName: true\n              });\n\n              if (identifierParent.type === 'Property' && identifierParent.shorthand) {\n                identifierParent.shorthand = false;\n                code.prependLeft(identifier$1.start, name + \": \");\n              }\n            }\n          }\n        }\n      }\n    });\n  };\n\n  return BlockStatement;\n}(Node);\n\nfunction isArguments(node) {\n  return node.type === 'Identifier' && node.name === 'arguments';\n}\n\nfunction inlineSpreads(code, node, elements) {\n  var i = elements.length;\n\n  while (i--) {\n    var element = elements[i];\n\n    if (!element || element.type !== 'SpreadElement') {\n      continue;\n    }\n\n    var argument = element.argument;\n\n    if (argument.type !== 'ArrayExpression') {\n      continue;\n    }\n\n    var subelements = argument.elements;\n\n    if (subelements.some(function (subelement) {\n      return subelement === null;\n    })) {\n      // Not even going to try inlining spread arrays with holes.\n      // It's a lot of work (got to be VERY careful in comma counting for\n      // ArrayExpression, and turn blanks into undefined for\n      // CallExpression and NewExpression), and probably literally no one\n      // would ever benefit from it.\n      continue;\n    } // We can inline it: drop the `...[` and `]` and sort out any commas.\n\n\n    var isLast = i === elements.length - 1;\n\n    if (subelements.length === 0) {\n      code.remove(isLast && i !== 0 ? elements[i - 1].end // Take the previous comma too\n      : element.start, isLast ? node.end - 1 // Must remove trailing comma; element.end wouldn’t\n      : elements[i + 1].start);\n    } else {\n      // Strip the `...[` and the `]` with a possible trailing comma before it,\n      // leaving just the possible trailing comma after it.\n      code.remove(element.start, subelements[0].start);\n      code.remove( // Strip a possible trailing comma after the last element\n      subelements[subelements.length - 1].end, // And also a possible trailing comma after the spread\n      isLast ? node.end - 1 : element.end);\n    }\n\n    elements.splice.apply(elements, [i, 1].concat(subelements));\n    i += subelements.length;\n  }\n} // Returns false if it’s safe to simply append a method call to the node,\n// e.g. `a` → `a.concat()`.\n//\n// Returns true if it may not be and so parentheses should be employed,\n// e.g. `a ? b : c` → `a ? b : c.concat()` would be wrong.\n//\n// This test may be overcautious; if desired it can be refined over time.\n\n\nfunction needsParentheses(node) {\n  switch (node.type) {\n    // Currently whitelisted are all relevant ES5 node types ('Literal' and\n    // 'ObjectExpression' are skipped as irrelevant for array/call spread.)\n    case 'ArrayExpression':\n    case 'CallExpression':\n    case 'Identifier':\n    case 'ParenthesizedExpression':\n    case 'ThisExpression':\n      return false;\n\n    default:\n      return true;\n  }\n}\n\nfunction spread(code, elements, start, argumentsArrayAlias, isNew) {\n  var i = elements.length;\n  var firstSpreadIndex = -1;\n\n  while (i--) {\n    var element$1 = elements[i];\n\n    if (element$1 && element$1.type === 'SpreadElement') {\n      if (isArguments(element$1.argument)) {\n        code.overwrite(element$1.argument.start, element$1.argument.end, argumentsArrayAlias);\n      }\n\n      firstSpreadIndex = i;\n    }\n  }\n\n  if (firstSpreadIndex === -1) {\n    return false;\n  } // false indicates no spread elements\n\n\n  if (isNew) {\n    for (i = 0; i < elements.length; i += 1) {\n      var element$2 = elements[i];\n\n      if (element$2.type === 'SpreadElement') {\n        code.remove(element$2.start, element$2.argument.start);\n      } else {\n        code.prependRight(element$2.start, '[');\n        code.prependRight(element$2.end, ']');\n      }\n    }\n\n    return true; // true indicates some spread elements\n  }\n\n  var element = elements[firstSpreadIndex];\n  var previousElement = elements[firstSpreadIndex - 1];\n\n  if (!previousElement) {\n    // We may need to parenthesize it to handle ternaries like [...a ? b : c].\n    var addClosingParen;\n\n    if (start !== element.start) {\n      if (addClosingParen = needsParentheses(element.argument)) {\n        code.overwrite(start, element.start, '( ');\n      } else {\n        code.remove(start, element.start);\n      }\n    } else if (element.parent.type === 'CallExpression') {\n      // CallExpression inserts `( ` itself, we add the ).\n      // (Yeah, CallExpression did the needsParentheses call already,\n      // but we don’t have its result handy, so do it again. It’s cheap.)\n      addClosingParen = needsParentheses(element.argument);\n    } else {\n      // Should be unreachable, but doing this is more robust.\n      throw new CompileError('Unsupported spread construct, please raise an issue at https://github.com/bublejs/buble/issues', element);\n    }\n\n    code.overwrite(element.end, elements[1].start, addClosingParen ? ' ).concat( ' : '.concat( ');\n  } else {\n    code.overwrite(previousElement.end, element.start, ' ].concat( ');\n  }\n\n  for (i = firstSpreadIndex; i < elements.length; i += 1) {\n    element = elements[i];\n\n    if (element) {\n      if (element.type === 'SpreadElement') {\n        code.remove(element.start, element.argument.start);\n      } else {\n        code.appendLeft(element.start, '[');\n        code.appendLeft(element.end, ']');\n      }\n    }\n  }\n\n  return true; // true indicates some spread elements\n}\n\nvar ArrayExpression = /*@__PURE__*/function (Node) {\n  function ArrayExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ArrayExpression.__proto__ = Node;\n  ArrayExpression.prototype = Object.create(Node && Node.prototype);\n  ArrayExpression.prototype.constructor = ArrayExpression;\n\n  ArrayExpression.prototype.initialise = function initialise(transforms) {\n    if (transforms.spreadRest && this.elements.length) {\n      var lexicalBoundary = this.findLexicalBoundary();\n      var i = this.elements.length;\n\n      while (i--) {\n        var element = this.elements[i];\n\n        if (element && element.type === 'SpreadElement' && isArguments(element.argument)) {\n          this.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();\n        }\n      }\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  ArrayExpression.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (transforms.spreadRest) {\n      inlineSpreads(code, this, this.elements); // erase trailing comma after last array element if not an array hole\n\n      if (this.elements.length) {\n        var lastElement = this.elements[this.elements.length - 1];\n\n        if (lastElement && /\\s*,/.test(code.original.slice(lastElement.end, this.end))) {\n          code.overwrite(lastElement.end, this.end - 1, ' ');\n        }\n      }\n\n      if (this.elements.length === 1) {\n        var element = this.elements[0];\n\n        if (element && element.type === 'SpreadElement') {\n          // special case – [ ...arguments ]\n          if (isArguments(element.argument)) {\n            code.overwrite(this.start, this.end, \"[].concat( \" + this.argumentsArrayAlias + \" )\"); // TODO if this is the only use of argsArray, don't bother concating\n          } else {\n            code.overwrite(this.start, element.argument.start, '[].concat( ');\n            code.overwrite(element.end, this.end, ' )');\n          }\n        }\n      } else {\n        var hasSpreadElements = spread(code, this.elements, this.start, this.argumentsArrayAlias);\n\n        if (hasSpreadElements) {\n          code.overwrite(this.end - 1, this.end, ')');\n        }\n      }\n    }\n  };\n\n  return ArrayExpression;\n}(Node);\n\nfunction removeTrailingComma(code, c) {\n  while (code.original[c] !== ')') {\n    if (code.original[c] === ',') {\n      code.remove(c, c + 1);\n      return;\n    }\n\n    if (code.original[c] === '/') {\n      if (code.original[c + 1] === '/') {\n        c = code.original.indexOf('\\n', c);\n      } else {\n        c = code.original.indexOf('*/', c) + 1;\n      }\n    }\n\n    c += 1;\n  }\n}\n\nvar ArrowFunctionExpression = /*@__PURE__*/function (Node) {\n  function ArrowFunctionExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ArrowFunctionExpression.__proto__ = Node;\n  ArrowFunctionExpression.prototype = Object.create(Node && Node.prototype);\n  ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression;\n\n  ArrowFunctionExpression.prototype.initialise = function initialise(transforms) {\n    if (this.async && transforms.asyncAwait) {\n      CompileError.missingTransform(\"async arrow functions\", \"asyncAwait\", this);\n    }\n\n    this.body.createScope();\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  ArrowFunctionExpression.prototype.transpile = function transpile(code, transforms) {\n    var openParensPos = this.start;\n\n    for (var end = (this.body || this.params[0]).start - 1; code.original[openParensPos] !== '(' && openParensPos < end;) {\n      ++openParensPos;\n    }\n\n    if (code.original[openParensPos] !== '(') {\n      openParensPos = -1;\n    }\n\n    var naked = openParensPos === -1;\n\n    if (transforms.arrow || this.needsArguments(transforms)) {\n      // remove arrow\n      var charIndex = this.body.start;\n\n      while (code.original[charIndex] !== '=') {\n        charIndex -= 1;\n      }\n\n      code.remove(charIndex, this.body.start);\n      Node.prototype.transpile.call(this, code, transforms); // wrap naked parameter\n\n      if (naked) {\n        code.prependRight(this.params[0].start, '(');\n        code.appendLeft(this.params[0].end, ')');\n      } // standalone expression statement\n\n\n      var standalone = this.parent && this.parent.type === 'ExpressionStatement';\n      var start,\n          text = standalone ? '!' : '';\n\n      if (this.async) {\n        text += 'async ';\n      }\n\n      text += 'function';\n\n      if (!standalone) {\n        text += ' ';\n      }\n\n      if (naked) {\n        start = this.params[0].start;\n      } else {\n        start = openParensPos;\n      } // add function\n\n\n      if (start > this.start) {\n        code.overwrite(this.start, start, text);\n      } else {\n        code.prependRight(this.start, text);\n      }\n    } else {\n      Node.prototype.transpile.call(this, code, transforms);\n    }\n\n    if (transforms.trailingFunctionCommas && this.params.length && !naked) {\n      removeTrailingComma(code, this.params[this.params.length - 1].end);\n    }\n  }; // Returns whether any transforms that will happen use `arguments`\n\n\n  ArrowFunctionExpression.prototype.needsArguments = function needsArguments(transforms) {\n    return transforms.spreadRest && this.params.filter(function (param) {\n      return param.type === 'RestElement';\n    }).length > 0;\n  };\n\n  return ArrowFunctionExpression;\n}(Node);\n\nfunction checkConst(identifier, scope) {\n  var declaration = scope.findDeclaration(identifier.name);\n\n  if (declaration && declaration.kind === 'const') {\n    throw new CompileError(identifier.name + \" is read-only\", identifier);\n  }\n}\n\nvar AssignmentExpression = /*@__PURE__*/function (Node) {\n  function AssignmentExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) AssignmentExpression.__proto__ = Node;\n  AssignmentExpression.prototype = Object.create(Node && Node.prototype);\n  AssignmentExpression.prototype.constructor = AssignmentExpression;\n\n  AssignmentExpression.prototype.initialise = function initialise(transforms) {\n    if (this.left.type === 'Identifier') {\n      var declaration = this.findScope(false).findDeclaration(this.left.name); // special case – https://gitlab.com/Rich-Harris/buble/issues/11\n\n      var statement = declaration && declaration.node.ancestor(3);\n\n      if (statement && statement.type === 'ForStatement' && statement.body.contains(this)) {\n        statement.reassigned[this.left.name] = true;\n      }\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  AssignmentExpression.prototype.transpile = function transpile(code, transforms) {\n    if (this.left.type === 'Identifier') {\n      // Do this check after everything has been initialized to find\n      // shadowing declarations after this expression\n      checkConst(this.left, this.findScope(false));\n    }\n\n    if (this.operator === '**=' && transforms.exponentiation) {\n      this.transpileExponentiation(code, transforms);\n    } else if (/Pattern/.test(this.left.type) && transforms.destructuring) {\n      this.transpileDestructuring(code);\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  AssignmentExpression.prototype.transpileDestructuring = function transpileDestructuring(code) {\n    var this$1 = this;\n    var writeScope = this.findScope(true);\n    var lookupScope = this.findScope(false);\n    var assign = writeScope.createDeclaration('assign');\n    code.appendRight(this.left.end, \"(\" + assign);\n    code.appendLeft(this.right.end, ', ');\n    var statementGenerators = [];\n    destructure(code, function (id) {\n      return writeScope.createDeclaration(id);\n    }, function (node) {\n      var name = lookupScope.resolveName(node.name);\n      checkConst(node, lookupScope);\n      return name;\n    }, this.left, assign, true, statementGenerators);\n    var suffix = ', ';\n    statementGenerators.forEach(function (fn, j) {\n      if (j === statementGenerators.length - 1) {\n        suffix = '';\n      }\n\n      fn(this$1.end, '', suffix);\n    });\n\n    if (this.unparenthesizedParent().type === 'ExpressionStatement') {\n      // no rvalue needed for expression statement\n      code.prependRight(this.end, \")\");\n    } else {\n      // destructuring is part of an expression - need an rvalue\n      code.appendRight(this.end, \", \" + assign + \")\");\n    }\n  };\n\n  AssignmentExpression.prototype.transpileExponentiation = function transpileExponentiation(code) {\n    var scope = this.findScope(false); // first, the easy part – `**=` -> `=`\n\n    var charIndex = this.left.end;\n\n    while (code.original[charIndex] !== '*') {\n      charIndex += 1;\n    }\n\n    code.remove(charIndex, charIndex + 2); // how we do the next part depends on a number of factors – whether\n    // this is a top-level statement, and whether we're updating a\n    // simple or complex reference\n\n    var base;\n    var left = this.left.unparenthesize();\n\n    if (left.type === 'Identifier') {\n      base = scope.resolveName(left.name);\n    } else if (left.type === 'MemberExpression') {\n      var object;\n      var needsObjectVar = false;\n      var property;\n      var needsPropertyVar = false;\n      var statement = this.findNearest(/(?:Statement|Declaration)$/);\n      var i0 = statement.getIndentation();\n\n      if (left.property.type === 'Identifier') {\n        property = left.computed ? scope.resolveName(left.property.name) : left.property.name;\n      } else {\n        property = scope.createDeclaration('property');\n        needsPropertyVar = true;\n      }\n\n      if (left.object.type === 'Identifier') {\n        object = scope.resolveName(left.object.name);\n      } else {\n        object = scope.createDeclaration('object');\n        needsObjectVar = true;\n      }\n\n      if (left.start === statement.start) {\n        if (needsObjectVar && needsPropertyVar) {\n          code.prependRight(statement.start, object + \" = \");\n          code.overwrite(left.object.end, left.property.start, \";\\n\" + i0 + property + \" = \");\n          code.overwrite(left.property.end, left.end, \";\\n\" + i0 + object + \"[\" + property + \"]\");\n        } else if (needsObjectVar) {\n          code.prependRight(statement.start, object + \" = \");\n          code.appendLeft(left.object.end, \";\\n\" + i0);\n          code.appendLeft(left.object.end, object);\n        } else if (needsPropertyVar) {\n          code.prependRight(left.property.start, property + \" = \");\n          code.appendLeft(left.property.end, \";\\n\" + i0);\n          code.move(left.property.start, left.property.end, this.start);\n          code.appendLeft(left.object.end, \"[\" + property + \"]\");\n          code.remove(left.object.end, left.property.start);\n          code.remove(left.property.end, left.end);\n        }\n      } else {\n        if (needsObjectVar && needsPropertyVar) {\n          code.prependRight(left.start, \"( \" + object + \" = \");\n          code.overwrite(left.object.end, left.property.start, \", \" + property + \" = \");\n          code.overwrite(left.property.end, left.end, \", \" + object + \"[\" + property + \"]\");\n        } else if (needsObjectVar) {\n          code.prependRight(left.start, \"( \" + object + \" = \");\n          code.appendLeft(left.object.end, \", \" + object);\n        } else if (needsPropertyVar) {\n          code.prependRight(left.property.start, \"( \" + property + \" = \");\n          code.appendLeft(left.property.end, \", \");\n          code.move(left.property.start, left.property.end, left.start);\n          code.overwrite(left.object.end, left.property.start, \"[\" + property + \"]\");\n          code.remove(left.property.end, left.end);\n        }\n\n        if (needsPropertyVar) {\n          code.appendLeft(this.end, \" )\");\n        }\n      }\n\n      base = object + (left.computed || needsPropertyVar ? \"[\" + property + \"]\" : \".\" + property);\n    }\n\n    code.prependRight(this.right.start, \"Math.pow( \" + base + \", \");\n    code.appendLeft(this.right.end, \" )\");\n  };\n\n  return AssignmentExpression;\n}(Node);\n\nvar AwaitExpression = /*@__PURE__*/function (Node) {\n  function AwaitExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) AwaitExpression.__proto__ = Node;\n  AwaitExpression.prototype = Object.create(Node && Node.prototype);\n  AwaitExpression.prototype.constructor = AwaitExpression;\n\n  AwaitExpression.prototype.initialise = function initialise(transforms) {\n    if (transforms.asyncAwait) {\n      CompileError.missingTransform(\"await\", \"asyncAwait\", this);\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return AwaitExpression;\n}(Node);\n\nvar BinaryExpression = /*@__PURE__*/function (Node) {\n  function BinaryExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) BinaryExpression.__proto__ = Node;\n  BinaryExpression.prototype = Object.create(Node && Node.prototype);\n  BinaryExpression.prototype.constructor = BinaryExpression;\n\n  BinaryExpression.prototype.transpile = function transpile(code, transforms) {\n    if (this.operator === '**' && transforms.exponentiation) {\n      code.prependRight(this.start, \"Math.pow( \");\n      code.overwrite(this.left.end, this.right.start, \", \");\n      code.appendLeft(this.end, \" )\");\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return BinaryExpression;\n}(Node);\n\nvar loopStatement = /(?:For(?:In|Of)?|While)Statement/;\n\nvar BreakStatement = /*@__PURE__*/function (Node) {\n  function BreakStatement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) BreakStatement.__proto__ = Node;\n  BreakStatement.prototype = Object.create(Node && Node.prototype);\n  BreakStatement.prototype.constructor = BreakStatement;\n\n  BreakStatement.prototype.initialise = function initialise() {\n    var loop = this.findNearest(loopStatement);\n    var switchCase = this.findNearest('SwitchCase');\n\n    if (loop && (!switchCase || loop.depth > switchCase.depth)) {\n      loop.canBreak = true;\n      this.loop = loop;\n    }\n  };\n\n  BreakStatement.prototype.transpile = function transpile(code) {\n    if (this.loop && this.loop.shouldRewriteAsFunction) {\n      if (this.label) {\n        throw new CompileError('Labels are not currently supported in a loop with locally-scoped variables', this);\n      }\n\n      code.overwrite(this.start, this.start + 5, \"return 'break'\");\n    }\n  };\n\n  return BreakStatement;\n}(Node);\n\nvar CallExpression = /*@__PURE__*/function (Node) {\n  function CallExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) CallExpression.__proto__ = Node;\n  CallExpression.prototype = Object.create(Node && Node.prototype);\n  CallExpression.prototype.constructor = CallExpression;\n\n  CallExpression.prototype.initialise = function initialise(transforms) {\n    if (transforms.spreadRest && this.arguments.length > 1) {\n      var lexicalBoundary = this.findLexicalBoundary();\n      var i = this.arguments.length;\n\n      while (i--) {\n        var arg = this.arguments[i];\n\n        if (arg.type === 'SpreadElement' && isArguments(arg.argument)) {\n          this.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();\n        }\n      }\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  CallExpression.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.spreadRest && this.arguments.length) {\n      inlineSpreads(code, this, this.arguments); // this.arguments.length may have changed, must retest.\n    }\n\n    if (transforms.spreadRest && this.arguments.length) {\n      var hasSpreadElements = false;\n      var context;\n      var firstArgument = this.arguments[0];\n\n      if (this.arguments.length === 1) {\n        if (firstArgument.type === 'SpreadElement') {\n          code.remove(firstArgument.start, firstArgument.argument.start);\n          hasSpreadElements = true;\n        }\n      } else {\n        hasSpreadElements = spread(code, this.arguments, firstArgument.start, this.argumentsArrayAlias);\n      }\n\n      if (hasSpreadElements) {\n        // we need to handle super() and super.method() differently\n        // due to its instance\n        var _super = null;\n\n        if (this.callee.type === 'Super') {\n          _super = this.callee;\n        } else if (this.callee.type === 'MemberExpression' && this.callee.object.type === 'Super') {\n          _super = this.callee.object;\n        }\n\n        if (!_super && this.callee.type === 'MemberExpression') {\n          if (this.callee.object.type === 'Identifier') {\n            context = this.callee.object.name;\n          } else {\n            context = this.findScope(true).createDeclaration('ref');\n            var callExpression = this.callee.object;\n            code.prependRight(callExpression.start, \"(\" + context + \" = \");\n            code.appendLeft(callExpression.end, \")\");\n          }\n        } else {\n          context = 'void 0';\n        }\n\n        code.appendLeft(this.callee.end, '.apply');\n\n        if (_super) {\n          _super.noCall = true; // bit hacky...\n\n          if (this.arguments.length > 1) {\n            if (firstArgument.type === 'SpreadElement') {\n              if (needsParentheses(firstArgument.argument)) {\n                code.prependRight(firstArgument.start, \"( \");\n              }\n            } else {\n              code.prependRight(firstArgument.start, \"[ \");\n            }\n\n            code.appendLeft(this.arguments[this.arguments.length - 1].end, ' )');\n          }\n        } else if (this.arguments.length === 1) {\n          code.prependRight(firstArgument.start, context + \", \");\n        } else {\n          if (firstArgument.type === 'SpreadElement') {\n            if (needsParentheses(firstArgument.argument)) {\n              code.appendLeft(firstArgument.start, context + \", ( \");\n            } else {\n              code.appendLeft(firstArgument.start, context + \", \");\n            }\n          } else {\n            code.appendLeft(firstArgument.start, context + \", [ \");\n          }\n\n          code.appendLeft(this.arguments[this.arguments.length - 1].end, ' )');\n        }\n      }\n    }\n\n    if (transforms.trailingFunctionCommas && this.arguments.length) {\n      removeTrailingComma(code, this.arguments[this.arguments.length - 1].end);\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return CallExpression;\n}(Node);\n\nvar CatchClause = /*@__PURE__*/function (Node) {\n  function CatchClause() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) CatchClause.__proto__ = Node;\n  CatchClause.prototype = Object.create(Node && Node.prototype);\n  CatchClause.prototype.constructor = CatchClause;\n\n  CatchClause.prototype.initialise = function initialise(transforms) {\n    var this$1 = this;\n    this.createdDeclarations = [];\n    this.scope = new Scope({\n      block: true,\n      parent: this.parent.findScope(false),\n      declare: function declare(id) {\n        return this$1.createdDeclarations.push(id);\n      }\n    });\n    this.scope.addDeclaration(this.param, 'catch');\n    Node.prototype.initialise.call(this, transforms);\n    this.scope.consolidate();\n  };\n\n  CatchClause.prototype.findScope = function findScope(functionScope) {\n    return functionScope ? this.parent.findScope(functionScope) : this.scope;\n  };\n\n  return CatchClause;\n}(Node); // TODO this code is pretty wild, tidy it up\n\n\nvar ClassBody = /*@__PURE__*/function (Node) {\n  function ClassBody() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ClassBody.__proto__ = Node;\n  ClassBody.prototype = Object.create(Node && Node.prototype);\n  ClassBody.prototype.constructor = ClassBody;\n\n  ClassBody.prototype.transpile = function transpile(code, transforms, inFunctionExpression, superName) {\n    var this$1 = this;\n\n    if (transforms.classes) {\n      var name = this.parent.name;\n      var indentStr = code.getIndentString();\n      var i0 = this.getIndentation() + (inFunctionExpression ? indentStr : '');\n      var i1 = i0 + indentStr;\n      var constructorIndex = findIndex(this.body, function (node) {\n        return node.kind === 'constructor';\n      });\n      var constructor = this.body[constructorIndex];\n      var introBlock = '';\n      var outroBlock = '';\n\n      if (this.body.length) {\n        code.remove(this.start, this.body[0].start);\n        code.remove(this.body[this.body.length - 1].end, this.end);\n      } else {\n        code.remove(this.start, this.end);\n      }\n\n      if (constructor) {\n        constructor.value.body.isConstructorBody = true;\n        var previousMethod = this.body[constructorIndex - 1];\n        var nextMethod = this.body[constructorIndex + 1]; // ensure constructor is first\n\n        if (constructorIndex > 0) {\n          code.remove(previousMethod.end, constructor.start);\n          code.move(constructor.start, nextMethod ? nextMethod.start : this.end - 1, this.body[0].start);\n        }\n\n        if (!inFunctionExpression) {\n          code.appendLeft(constructor.end, ';');\n        }\n      }\n\n      var namedFunctions = this.program.options.namedFunctionExpressions !== false;\n      var namedConstructor = namedFunctions || this.parent.superClass || this.parent.type !== 'ClassDeclaration';\n\n      if (this.parent.superClass) {\n        var inheritanceBlock = \"if ( \" + superName + \" ) \" + name + \".__proto__ = \" + superName + \";\\n\" + i0 + name + \".prototype = Object.create( \" + superName + \" && \" + superName + \".prototype );\\n\" + i0 + name + \".prototype.constructor = \" + name + \";\";\n\n        if (constructor) {\n          introBlock += \"\\n\\n\" + i0 + inheritanceBlock;\n        } else {\n          var fn = \"function \" + name + \" () {\" + (superName ? \"\\n\" + i1 + superName + \".apply(this, arguments);\\n\" + i0 + \"}\" : \"}\") + (inFunctionExpression ? '' : ';') + (this.body.length ? \"\\n\\n\" + i0 : '');\n          inheritanceBlock = fn + inheritanceBlock;\n          introBlock += inheritanceBlock + \"\\n\\n\" + i0;\n        }\n      } else if (!constructor) {\n        var fn$1 = 'function ' + (namedConstructor ? name + ' ' : '') + '() {}';\n\n        if (this.parent.type === 'ClassDeclaration') {\n          fn$1 += ';';\n        }\n\n        if (this.body.length) {\n          fn$1 += \"\\n\\n\" + i0;\n        }\n\n        introBlock += fn$1;\n      }\n\n      var scope = this.findScope(false);\n      var prototypeGettersAndSetters = [];\n      var staticGettersAndSetters = [];\n      var prototypeAccessors;\n      var staticAccessors;\n      this.body.forEach(function (method, i) {\n        if ((method.kind === 'get' || method.kind === 'set') && transforms.getterSetter) {\n          CompileError.missingTransform(\"getters and setters\", \"getterSetter\", method);\n        }\n\n        if (method.kind === 'constructor') {\n          var constructorName = namedConstructor ? ' ' + name : '';\n          code.overwrite(method.key.start, method.key.end, \"function\" + constructorName);\n          return;\n        }\n\n        if (method.static) {\n          var len = code.original[method.start + 6] == ' ' ? 7 : 6;\n          code.remove(method.start, method.start + len);\n        }\n\n        var isAccessor = method.kind !== 'method';\n        var lhs;\n        var methodName = method.key.name;\n\n        if (reserved[methodName] || method.value.body.scope.references[methodName]) {\n          methodName = scope.createIdentifier(methodName);\n        } // when method name is a string or a number let's pretend it's a computed method\n\n\n        var fake_computed = false;\n\n        if (!method.computed && method.key.type === 'Literal') {\n          fake_computed = true;\n          method.computed = true;\n        }\n\n        if (isAccessor) {\n          if (method.computed) {\n            throw new Error('Computed accessor properties are not currently supported');\n          }\n\n          code.remove(method.start, method.key.start);\n\n          if (method.static) {\n            if (!~staticGettersAndSetters.indexOf(method.key.name)) {\n              staticGettersAndSetters.push(method.key.name);\n            }\n\n            if (!staticAccessors) {\n              staticAccessors = scope.createIdentifier('staticAccessors');\n            }\n\n            lhs = \"\" + staticAccessors;\n          } else {\n            if (!~prototypeGettersAndSetters.indexOf(method.key.name)) {\n              prototypeGettersAndSetters.push(method.key.name);\n            }\n\n            if (!prototypeAccessors) {\n              prototypeAccessors = scope.createIdentifier('prototypeAccessors');\n            }\n\n            lhs = \"\" + prototypeAccessors;\n          }\n        } else {\n          lhs = method.static ? \"\" + name : name + \".prototype\";\n        }\n\n        if (!method.computed) {\n          lhs += '.';\n        }\n\n        var insertNewlines = constructorIndex > 0 && i === constructorIndex + 1 || i === 0 && constructorIndex === this$1.body.length - 1;\n\n        if (insertNewlines) {\n          lhs = \"\\n\\n\" + i0 + lhs;\n        }\n\n        var c = method.key.end;\n\n        if (method.computed) {\n          if (fake_computed) {\n            code.prependRight(method.key.start, '[');\n            code.appendLeft(method.key.end, ']');\n          } else {\n            while (code.original[c] !== ']') {\n              c += 1;\n            }\n\n            c += 1;\n          }\n        }\n\n        var funcName = method.computed || isAccessor || !namedFunctions ? '' : methodName + \" \";\n        var rhs = (isAccessor ? \".\" + method.kind : '') + \" = \" + (method.value.async ? 'async ' : '') + \"function\" + (method.value.generator ? '* ' : ' ') + funcName;\n        code.remove(c, method.value.start);\n        code.prependRight(method.value.start, rhs);\n        code.appendLeft(method.end, ';');\n\n        if (method.value.generator) {\n          code.remove(method.start, method.key.start);\n        }\n\n        var start = method.key.start;\n\n        if (method.computed && !fake_computed) {\n          while (code.original[start] != '[') {\n            --start;\n          }\n        }\n\n        if (method.start < start) {\n          code.overwrite(method.start, start, lhs);\n        } else {\n          code.prependRight(method.start, lhs);\n        }\n      });\n\n      if (prototypeGettersAndSetters.length || staticGettersAndSetters.length) {\n        var intro = [];\n        var outro = [];\n\n        if (prototypeGettersAndSetters.length) {\n          intro.push(\"var \" + prototypeAccessors + \" = { \" + prototypeGettersAndSetters.map(function (name) {\n            return name + \": { configurable: true }\";\n          }).join(',') + \" };\");\n          outro.push(\"Object.defineProperties( \" + name + \".prototype, \" + prototypeAccessors + \" );\");\n        }\n\n        if (staticGettersAndSetters.length) {\n          intro.push(\"var \" + staticAccessors + \" = { \" + staticGettersAndSetters.map(function (name) {\n            return name + \": { configurable: true }\";\n          }).join(',') + \" };\");\n          outro.push(\"Object.defineProperties( \" + name + \", \" + staticAccessors + \" );\");\n        }\n\n        if (constructor) {\n          introBlock += \"\\n\\n\" + i0;\n        }\n\n        introBlock += intro.join(\"\\n\" + i0);\n\n        if (!constructor) {\n          introBlock += \"\\n\\n\" + i0;\n        }\n\n        outroBlock += \"\\n\\n\" + i0 + outro.join(\"\\n\" + i0);\n      }\n\n      if (constructor) {\n        code.appendLeft(constructor.end, introBlock);\n      } else {\n        code.prependRight(this.start, introBlock);\n      }\n\n      code.appendLeft(this.end, outroBlock);\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return ClassBody;\n}(Node); // TODO this function is slightly flawed – it works on the original string,\n// not its current edited state.\n// That's not a problem for the way that it's currently used, but it could\n// be in future...\n\n\nfunction deindent(node, code) {\n  var start = node.start;\n  var end = node.end;\n  var indentStr = code.getIndentString();\n  var indentStrLen = indentStr.length;\n  var indentStart = start - indentStrLen;\n\n  if (!node.program.indentExclusions[indentStart] && code.original.slice(indentStart, start) === indentStr) {\n    code.remove(indentStart, start);\n  }\n\n  var pattern = new RegExp(indentStr + '\\\\S', 'g');\n  var slice = code.original.slice(start, end);\n  var match;\n\n  while (match = pattern.exec(slice)) {\n    var removeStart = start + match.index;\n\n    if (!node.program.indentExclusions[removeStart]) {\n      code.remove(removeStart, removeStart + indentStrLen);\n    }\n  }\n}\n\nvar ClassDeclaration = /*@__PURE__*/function (Node) {\n  function ClassDeclaration() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ClassDeclaration.__proto__ = Node;\n  ClassDeclaration.prototype = Object.create(Node && Node.prototype);\n  ClassDeclaration.prototype.constructor = ClassDeclaration;\n\n  ClassDeclaration.prototype.initialise = function initialise(transforms) {\n    if (this.id) {\n      this.name = this.id.name;\n      this.findScope(true).addDeclaration(this.id, 'class');\n    } else {\n      this.name = this.findScope(true).createIdentifier(\"defaultExport\");\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  ClassDeclaration.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.classes) {\n      if (!this.superClass) {\n        deindent(this.body, code);\n      }\n\n      var superName = this.superClass && (this.superClass.name || 'superclass');\n      var i0 = this.getIndentation();\n      var i1 = i0 + code.getIndentString(); // if this is an export default statement, we have to move the export to\n      // after the declaration, because `export default var Foo = ...` is illegal\n\n      var isExportDefaultDeclaration = this.parent.type === 'ExportDefaultDeclaration';\n\n      if (isExportDefaultDeclaration) {\n        code.remove(this.parent.start, this.start);\n      }\n\n      var c = this.start;\n\n      if (this.id) {\n        code.overwrite(c, this.id.start, 'var ');\n        c = this.id.end;\n      } else {\n        code.prependLeft(c, \"var \" + this.name);\n      }\n\n      if (this.superClass) {\n        if (this.superClass.end === this.body.start) {\n          code.remove(c, this.superClass.start);\n          code.appendLeft(c, \" = /*@__PURE__*/(function (\" + superName + \") {\\n\" + i1);\n        } else {\n          code.overwrite(c, this.superClass.start, ' = ');\n          code.overwrite(this.superClass.end, this.body.start, \"/*@__PURE__*/(function (\" + superName + \") {\\n\" + i1);\n        }\n      } else {\n        if (c === this.body.start) {\n          code.appendLeft(c, ' = ');\n        } else {\n          code.overwrite(c, this.body.start, ' = ');\n        }\n      }\n\n      this.body.transpile(code, transforms, !!this.superClass, superName);\n      var syntheticDefaultExport = isExportDefaultDeclaration ? \"\\n\\n\" + i0 + \"export default \" + this.name + \";\" : '';\n\n      if (this.superClass) {\n        code.appendLeft(this.end, \"\\n\\n\" + i1 + \"return \" + this.name + \";\\n\" + i0 + \"}(\");\n        code.move(this.superClass.start, this.superClass.end, this.end);\n        code.prependRight(this.end, \"));\" + syntheticDefaultExport);\n      } else if (syntheticDefaultExport) {\n        code.prependRight(this.end, syntheticDefaultExport);\n      }\n    } else {\n      this.body.transpile(code, transforms, false, null);\n    }\n  };\n\n  return ClassDeclaration;\n}(Node);\n\nvar ClassExpression = /*@__PURE__*/function (Node) {\n  function ClassExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ClassExpression.__proto__ = Node;\n  ClassExpression.prototype = Object.create(Node && Node.prototype);\n  ClassExpression.prototype.constructor = ClassExpression;\n\n  ClassExpression.prototype.initialise = function initialise(transforms) {\n    this.name = (this.id ? this.id.name : this.parent.type === 'VariableDeclarator' ? this.parent.id.name : this.parent.type !== 'AssignmentExpression' ? null : this.parent.left.type === 'Identifier' ? this.parent.left.name : this.parent.left.type === 'MemberExpression' ? this.parent.left.property.name : null) || this.findScope(true).createIdentifier('anonymous');\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  ClassExpression.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.classes) {\n      var superName = this.superClass && (this.superClass.name || 'superclass');\n\n      if (superName === this.name) {\n        superName = this.findScope(true).createIdentifier(this.name);\n      }\n\n      var i0 = this.getIndentation();\n      var i1 = i0 + code.getIndentString();\n\n      if (this.superClass) {\n        code.remove(this.start, this.superClass.start);\n        code.remove(this.superClass.end, this.body.start);\n        code.appendRight(this.start, \"/*@__PURE__*/(function (\" + superName + \") {\\n\" + i1);\n      } else {\n        code.overwrite(this.start, this.body.start, \"/*@__PURE__*/(function () {\\n\" + i1);\n      }\n\n      this.body.transpile(code, transforms, true, superName);\n      var superClass = '';\n\n      if (this.superClass) {\n        superClass = code.slice(this.superClass.start, this.superClass.end);\n        code.remove(this.superClass.start, this.superClass.end);\n      }\n\n      code.appendLeft(this.end, \"\\n\\n\" + i1 + \"return \" + this.name + \";\\n\" + i0 + \"}(\" + superClass + \"))\");\n    } else {\n      this.body.transpile(code, transforms, false);\n    }\n  };\n\n  return ClassExpression;\n}(Node);\n\nvar ContinueStatement = /*@__PURE__*/function (Node) {\n  function ContinueStatement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ContinueStatement.__proto__ = Node;\n  ContinueStatement.prototype = Object.create(Node && Node.prototype);\n  ContinueStatement.prototype.constructor = ContinueStatement;\n\n  ContinueStatement.prototype.transpile = function transpile(code) {\n    var loop = this.findNearest(loopStatement);\n\n    if (loop.shouldRewriteAsFunction) {\n      if (this.label) {\n        throw new CompileError('Labels are not currently supported in a loop with locally-scoped variables', this);\n      }\n\n      code.overwrite(this.start, this.start + 8, 'return');\n    }\n  };\n\n  return ContinueStatement;\n}(Node);\n\nvar ExportDefaultDeclaration = /*@__PURE__*/function (Node) {\n  function ExportDefaultDeclaration() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ExportDefaultDeclaration.__proto__ = Node;\n  ExportDefaultDeclaration.prototype = Object.create(Node && Node.prototype);\n  ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration;\n\n  ExportDefaultDeclaration.prototype.initialise = function initialise(transforms) {\n    if (transforms.moduleExport) {\n      CompileError.missingTransform(\"export\", \"moduleExport\", this);\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return ExportDefaultDeclaration;\n}(Node);\n\nvar ExportNamedDeclaration = /*@__PURE__*/function (Node) {\n  function ExportNamedDeclaration() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ExportNamedDeclaration.__proto__ = Node;\n  ExportNamedDeclaration.prototype = Object.create(Node && Node.prototype);\n  ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration;\n\n  ExportNamedDeclaration.prototype.initialise = function initialise(transforms) {\n    if (transforms.moduleExport) {\n      CompileError.missingTransform(\"export\", \"moduleExport\", this);\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return ExportNamedDeclaration;\n}(Node);\n\nvar LoopStatement = /*@__PURE__*/function (Node) {\n  function LoopStatement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) LoopStatement.__proto__ = Node;\n  LoopStatement.prototype = Object.create(Node && Node.prototype);\n  LoopStatement.prototype.constructor = LoopStatement;\n\n  LoopStatement.prototype.findScope = function findScope(functionScope) {\n    return functionScope || !this.createdScope ? this.parent.findScope(functionScope) : this.body.scope;\n  };\n\n  LoopStatement.prototype.initialise = function initialise(transforms) {\n    this.body.createScope();\n    this.createdScope = true; // this is populated as and when reassignments occur\n\n    this.reassigned = Object.create(null);\n    this.aliases = Object.create(null);\n    this.thisRefs = [];\n    Node.prototype.initialise.call(this, transforms);\n\n    if (this.scope) {\n      this.scope.consolidate();\n    }\n\n    var declarations = Object.assign({}, this.body.scope.declarations);\n\n    if (this.scope) {\n      Object.assign(declarations, this.scope.declarations);\n    }\n\n    if (transforms.letConst) {\n      // see if any block-scoped declarations are referenced\n      // inside function expressions\n      var names = Object.keys(declarations);\n      var i = names.length;\n\n      while (i--) {\n        var name = names[i];\n        var declaration = declarations[name];\n        var j = declaration.instances.length;\n\n        while (j--) {\n          var instance = declaration.instances[j];\n          var nearestFunctionExpression = instance.findNearest(/Function/);\n\n          if (nearestFunctionExpression && nearestFunctionExpression.depth > this.depth) {\n            this.shouldRewriteAsFunction = true;\n\n            for (var i$1 = 0, list = this.thisRefs; i$1 < list.length; i$1 += 1) {\n              var node = list[i$1];\n              node.alias = node.alias || node.findLexicalBoundary().getThisAlias();\n            }\n\n            break;\n          }\n        }\n\n        if (this.shouldRewriteAsFunction) {\n          break;\n        }\n      }\n    }\n  };\n\n  LoopStatement.prototype.transpile = function transpile(code, transforms) {\n    var needsBlock = this.type != 'ForOfStatement' && (this.body.type !== 'BlockStatement' || this.body.type === 'BlockStatement' && this.body.synthetic);\n\n    if (this.shouldRewriteAsFunction) {\n      var i0 = this.getIndentation();\n      var i1 = i0 + code.getIndentString();\n      var argString = this.args ? \" \" + this.args.join(', ') + \" \" : '';\n      var paramString = this.params ? \" \" + this.params.join(', ') + \" \" : '';\n      var functionScope = this.findScope(true);\n      var loop = functionScope.createIdentifier('loop');\n      var before = \"var \" + loop + \" = function (\" + paramString + \") \" + (this.body.synthetic ? \"{\\n\" + i0 + code.getIndentString() : '');\n      var after = (this.body.synthetic ? \"\\n\" + i0 + \"}\" : '') + \";\\n\\n\" + i0;\n      code.prependRight(this.body.start, before);\n      code.appendLeft(this.body.end, after);\n      code.move(this.start, this.body.start, this.body.end);\n\n      if (this.canBreak || this.canReturn) {\n        var returned = functionScope.createIdentifier('returned');\n        var insert = \"{\\n\" + i1 + \"var \" + returned + \" = \" + loop + \"(\" + argString + \");\\n\";\n\n        if (this.canBreak) {\n          insert += \"\\n\" + i1 + \"if ( \" + returned + \" === 'break' ) break;\";\n        }\n\n        if (this.canReturn) {\n          insert += \"\\n\" + i1 + \"if ( \" + returned + \" ) return \" + returned + \".v;\";\n        }\n\n        insert += \"\\n\" + i0 + \"}\";\n        code.prependRight(this.body.end, insert);\n      } else {\n        var callExpression = loop + \"(\" + argString + \");\";\n\n        if (this.type === 'DoWhileStatement') {\n          code.overwrite(this.start, this.body.start, \"do {\\n\" + i1 + callExpression + \"\\n\" + i0 + \"}\");\n        } else {\n          code.prependRight(this.body.end, callExpression);\n        }\n      }\n    } else if (needsBlock) {\n      code.appendLeft(this.body.start, '{ ');\n      code.prependRight(this.body.end, ' }');\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return LoopStatement;\n}(Node);\n\nvar ForStatement = /*@__PURE__*/function (LoopStatement) {\n  function ForStatement() {\n    LoopStatement.apply(this, arguments);\n  }\n\n  if (LoopStatement) ForStatement.__proto__ = LoopStatement;\n  ForStatement.prototype = Object.create(LoopStatement && LoopStatement.prototype);\n  ForStatement.prototype.constructor = ForStatement;\n\n  ForStatement.prototype.initialise = function initialise(transforms) {\n    var this$1 = this;\n    this.createdDeclarations = [];\n    this.scope = new Scope({\n      block: true,\n      parent: this.parent.findScope(false),\n      declare: function declare(id) {\n        return this$1.createdDeclarations.push(id);\n      }\n    });\n    LoopStatement.prototype.initialise.call(this, transforms);\n  };\n\n  ForStatement.prototype.findScope = function findScope(functionScope) {\n    return functionScope ? this.parent.findScope(functionScope) : this.scope;\n  };\n\n  ForStatement.prototype.transpile = function transpile(code, transforms) {\n    var this$1 = this;\n    var i1 = this.getIndentation() + code.getIndentString();\n\n    if (this.shouldRewriteAsFunction) {\n      // which variables are declared in the init statement?\n      var names = this.init && this.init.type === 'VariableDeclaration' ? this.init.declarations.map(function (declarator) {\n        return extractNames(declarator.id);\n      }) : [];\n      var aliases = this.aliases;\n      this.args = names.map(function (name) {\n        return name in this$1.aliases ? this$1.aliases[name].outer : name;\n      });\n      this.params = names.map(function (name) {\n        return name in this$1.aliases ? this$1.aliases[name].inner : name;\n      });\n      var updates = Object.keys(this.reassigned).map(function (name) {\n        return aliases[name].outer + \" = \" + aliases[name].inner + \";\";\n      });\n\n      if (updates.length) {\n        if (this.body.synthetic) {\n          code.appendLeft(this.body.body[0].end, \"; \" + updates.join(\" \"));\n        } else {\n          var lastStatement = this.body.body[this.body.body.length - 1];\n          code.appendLeft(lastStatement.end, \"\\n\\n\" + i1 + updates.join(\"\\n\" + i1));\n        }\n      }\n    }\n\n    LoopStatement.prototype.transpile.call(this, code, transforms);\n  };\n\n  return ForStatement;\n}(LoopStatement);\n\nvar ForInStatement = /*@__PURE__*/function (LoopStatement) {\n  function ForInStatement() {\n    LoopStatement.apply(this, arguments);\n  }\n\n  if (LoopStatement) ForInStatement.__proto__ = LoopStatement;\n  ForInStatement.prototype = Object.create(LoopStatement && LoopStatement.prototype);\n  ForInStatement.prototype.constructor = ForInStatement;\n\n  ForInStatement.prototype.initialise = function initialise(transforms) {\n    var this$1 = this;\n    this.createdDeclarations = [];\n    this.scope = new Scope({\n      block: true,\n      parent: this.parent.findScope(false),\n      declare: function declare(id) {\n        return this$1.createdDeclarations.push(id);\n      }\n    });\n    LoopStatement.prototype.initialise.call(this, transforms);\n  };\n\n  ForInStatement.prototype.findScope = function findScope(functionScope) {\n    return functionScope ? this.parent.findScope(functionScope) : this.scope;\n  };\n\n  ForInStatement.prototype.transpile = function transpile(code, transforms) {\n    var this$1 = this;\n    var hasDeclaration = this.left.type === 'VariableDeclaration';\n\n    if (this.shouldRewriteAsFunction) {\n      // which variables are declared in the init statement?\n      var names = hasDeclaration ? this.left.declarations.map(function (declarator) {\n        return extractNames(declarator.id);\n      }) : [];\n      this.args = names.map(function (name) {\n        return name in this$1.aliases ? this$1.aliases[name].outer : name;\n      });\n      this.params = names.map(function (name) {\n        return name in this$1.aliases ? this$1.aliases[name].inner : name;\n      });\n    }\n\n    LoopStatement.prototype.transpile.call(this, code, transforms);\n    var maybePattern = hasDeclaration ? this.left.declarations[0].id : this.left;\n\n    if (maybePattern.type !== 'Identifier' && maybePattern.type !== 'MemberExpression') {\n      this.destructurePattern(code, maybePattern, hasDeclaration);\n    }\n  };\n\n  ForInStatement.prototype.destructurePattern = function destructurePattern(code, pattern, isDeclaration) {\n    var scope = this.findScope(true);\n    var i0 = this.getIndentation();\n    var i1 = i0 + code.getIndentString();\n    var ref = scope.createIdentifier('ref');\n    var bodyStart = this.body.body.length ? this.body.body[0].start : this.body.start + 1;\n    code.move(pattern.start, pattern.end, bodyStart);\n    code.prependRight(pattern.end, isDeclaration ? ref : \"var \" + ref);\n    var statementGenerators = [];\n    destructure(code, function (id) {\n      return scope.createIdentifier(id);\n    }, function (ref) {\n      var name = ref.name;\n      return scope.resolveName(name);\n    }, pattern, ref, false, statementGenerators);\n    var suffix = \";\\n\" + i1;\n    statementGenerators.forEach(function (fn, i) {\n      if (i === statementGenerators.length - 1) {\n        suffix = \";\\n\\n\" + i1;\n      }\n\n      fn(bodyStart, '', suffix);\n    });\n  };\n\n  return ForInStatement;\n}(LoopStatement);\n\nvar ForOfStatement = /*@__PURE__*/function (LoopStatement) {\n  function ForOfStatement() {\n    LoopStatement.apply(this, arguments);\n  }\n\n  if (LoopStatement) ForOfStatement.__proto__ = LoopStatement;\n  ForOfStatement.prototype = Object.create(LoopStatement && LoopStatement.prototype);\n  ForOfStatement.prototype.constructor = ForOfStatement;\n\n  ForOfStatement.prototype.initialise = function initialise(transforms) {\n    var this$1 = this;\n\n    if (transforms.forOf && !transforms.dangerousForOf) {\n      CompileError.missingTransform(\"for-of statements\", \"forOf\", this, \"dangerousForOf\");\n    }\n\n    if (this.await && transforms.asyncAwait) {\n      CompileError.missingTransform(\"for-await-of statements\", \"asyncAwait\", this);\n    }\n\n    this.createdDeclarations = [];\n    this.scope = new Scope({\n      block: true,\n      parent: this.parent.findScope(false),\n      declare: function declare(id) {\n        return this$1.createdDeclarations.push(id);\n      }\n    });\n    LoopStatement.prototype.initialise.call(this, transforms);\n  };\n\n  ForOfStatement.prototype.findScope = function findScope(functionScope) {\n    return functionScope ? this.parent.findScope(functionScope) : this.scope;\n  };\n\n  ForOfStatement.prototype.transpile = function transpile(code, transforms) {\n    LoopStatement.prototype.transpile.call(this, code, transforms);\n\n    if (!transforms.dangerousForOf) {\n      return;\n    } // edge case (#80)\n\n\n    if (!this.body.body[0]) {\n      if (this.left.type === 'VariableDeclaration' && this.left.kind === 'var') {\n        code.remove(this.start, this.left.start);\n        code.appendLeft(this.left.end, ';');\n        code.remove(this.left.end, this.end);\n      } else {\n        code.remove(this.start, this.end);\n      }\n\n      return;\n    }\n\n    var scope = this.findScope(true);\n    var i0 = this.getIndentation();\n    var i1 = i0 + code.getIndentString();\n    var key = scope.createIdentifier('i');\n    var list = scope.createIdentifier('list');\n\n    if (this.body.synthetic) {\n      code.prependRight(this.left.start, \"{\\n\" + i1);\n      code.appendLeft(this.body.body[0].end, \"\\n\" + i0 + \"}\");\n    }\n\n    var bodyStart = this.body.body[0].start;\n    code.remove(this.left.end, this.right.start);\n    code.move(this.left.start, this.left.end, bodyStart);\n    code.prependRight(this.right.start, \"var \" + key + \" = 0, \" + list + \" = \");\n    code.appendLeft(this.right.end, \"; \" + key + \" < \" + list + \".length; \" + key + \" += 1\");\n    var isDeclaration = this.left.type === 'VariableDeclaration';\n    var maybeDestructuring = isDeclaration ? this.left.declarations[0].id : this.left;\n\n    if (maybeDestructuring.type !== 'Identifier') {\n      var statementGenerators = [];\n      var ref = scope.createIdentifier('ref');\n      destructure(code, function (id) {\n        return scope.createIdentifier(id);\n      }, function (ref) {\n        var name = ref.name;\n        return scope.resolveName(name);\n      }, maybeDestructuring, ref, !isDeclaration, statementGenerators);\n      var suffix = \";\\n\" + i1;\n      statementGenerators.forEach(function (fn, i) {\n        if (i === statementGenerators.length - 1) {\n          suffix = \";\\n\\n\" + i1;\n        }\n\n        fn(bodyStart, '', suffix);\n      });\n\n      if (isDeclaration) {\n        code.appendLeft(this.left.start + this.left.kind.length + 1, ref);\n        code.appendLeft(this.left.end, \" = \" + list + \"[\" + key + \"];\\n\" + i1);\n      } else {\n        code.appendLeft(this.left.end, \"var \" + ref + \" = \" + list + \"[\" + key + \"];\\n\" + i1);\n      }\n    } else {\n      code.appendLeft(this.left.end, \" = \" + list + \"[\" + key + \"];\\n\\n\" + i1);\n    }\n  };\n\n  return ForOfStatement;\n}(LoopStatement);\n\nvar FunctionDeclaration = /*@__PURE__*/function (Node) {\n  function FunctionDeclaration() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) FunctionDeclaration.__proto__ = Node;\n  FunctionDeclaration.prototype = Object.create(Node && Node.prototype);\n  FunctionDeclaration.prototype.constructor = FunctionDeclaration;\n\n  FunctionDeclaration.prototype.initialise = function initialise(transforms) {\n    if (this.generator && transforms.generator) {\n      CompileError.missingTransform(\"generators\", \"generator\", this);\n    }\n\n    if (this.async && transforms.asyncAwait) {\n      CompileError.missingTransform(\"async functions\", \"asyncAwait\", this);\n    }\n\n    this.body.createScope();\n\n    if (this.id) {\n      this.findScope(true).addDeclaration(this.id, 'function');\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  FunctionDeclaration.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (transforms.trailingFunctionCommas && this.params.length) {\n      removeTrailingComma(code, this.params[this.params.length - 1].end);\n    }\n  };\n\n  return FunctionDeclaration;\n}(Node);\n\nvar FunctionExpression = /*@__PURE__*/function (Node) {\n  function FunctionExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) FunctionExpression.__proto__ = Node;\n  FunctionExpression.prototype = Object.create(Node && Node.prototype);\n  FunctionExpression.prototype.constructor = FunctionExpression;\n\n  FunctionExpression.prototype.initialise = function initialise(transforms) {\n    if (this.generator && transforms.generator) {\n      CompileError.missingTransform(\"generators\", \"generator\", this);\n    }\n\n    if (this.async && transforms.asyncAwait) {\n      CompileError.missingTransform(\"async functions\", \"asyncAwait\", this);\n    }\n\n    this.body.createScope();\n\n    if (this.id) {\n      // function expression IDs belong to the child scope...\n      this.body.scope.addDeclaration(this.id, 'function');\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n    var parent = this.parent;\n    var methodName;\n\n    if (transforms.conciseMethodProperty && parent.type === 'Property' && parent.kind === 'init' && parent.method && parent.key.type === 'Identifier') {\n      // object literal concise method\n      methodName = parent.key.name;\n    } else if (transforms.classes && parent.type === 'MethodDefinition' && parent.kind === 'method' && parent.key.type === 'Identifier') {\n      // method definition in a class\n      methodName = parent.key.name;\n    } else if (this.id && this.id.type === 'Identifier') {\n      // naked function expression\n      methodName = this.id.alias || this.id.name;\n    }\n\n    if (methodName) {\n      for (var i$1 = 0, list$1 = this.params; i$1 < list$1.length; i$1 += 1) {\n        var param = list$1[i$1];\n\n        if (param.type === 'Identifier' && methodName === param.name) {\n          // workaround for Safari 9/WebKit bug:\n          // https://gitlab.com/Rich-Harris/buble/issues/154\n          // change parameter name when same as method name\n          var scope = this.body.scope;\n          var declaration = scope.declarations[methodName];\n          var alias = scope.createIdentifier(methodName);\n          param.alias = alias;\n\n          for (var i = 0, list = declaration.instances; i < list.length; i += 1) {\n            var identifier = list[i];\n            identifier.alias = alias;\n          }\n\n          break;\n        }\n      }\n    }\n  };\n\n  FunctionExpression.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (transforms.trailingFunctionCommas && this.params.length) {\n      removeTrailingComma(code, this.params[this.params.length - 1].end);\n    }\n  };\n\n  return FunctionExpression;\n}(Node);\n\nfunction isReference(node, parent) {\n  if (node.type === 'MemberExpression') {\n    return !node.computed && isReference(node.object, node);\n  }\n\n  if (node.type === 'Identifier') {\n    // the only time we could have an identifier node without a parent is\n    // if it's the entire body of a function without a block statement –\n    // i.e. an arrow function expression like `a => a`\n    if (!parent) {\n      return true;\n    }\n\n    if (/(Function|Class)Expression/.test(parent.type)) {\n      return false;\n    }\n\n    if (parent.type === 'VariableDeclarator') {\n      return node === parent.init;\n    } // TODO is this right?\n\n\n    if (parent.type === 'MemberExpression' || parent.type === 'MethodDefinition') {\n      return parent.computed || node === parent.object;\n    }\n\n    if (parent.type === 'ArrayPattern') {\n      return false;\n    } // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`\n\n\n    if (parent.type === 'Property') {\n      if (parent.parent.type === 'ObjectPattern') {\n        return false;\n      }\n\n      return parent.computed || node === parent.value;\n    } // disregard the `bar` in `class Foo { bar () {...} }`\n\n\n    if (parent.type === 'MethodDefinition') {\n      return false;\n    } // disregard the `bar` in `export { foo as bar }`\n\n\n    if (parent.type === 'ExportSpecifier' && node !== parent.local) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\nvar Identifier = /*@__PURE__*/function (Node) {\n  function Identifier() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) Identifier.__proto__ = Node;\n  Identifier.prototype = Object.create(Node && Node.prototype);\n  Identifier.prototype.constructor = Identifier;\n\n  Identifier.prototype.findScope = function findScope(functionScope) {\n    if (this.parent.params && ~this.parent.params.indexOf(this)) {\n      return this.parent.body.scope;\n    }\n\n    if (this.parent.type === 'FunctionExpression' && this === this.parent.id) {\n      return this.parent.body.scope;\n    }\n\n    return this.parent.findScope(functionScope);\n  };\n\n  Identifier.prototype.initialise = function initialise(transforms) {\n    if (this.isLabel()) {\n      return;\n    }\n\n    if (isReference(this, this.parent)) {\n      if (transforms.arrow && this.name === 'arguments' && !this.findScope(false).contains(this.name)) {\n        var lexicalBoundary = this.findLexicalBoundary();\n        var arrowFunction = this.findNearest('ArrowFunctionExpression');\n        var loop = this.findNearest(loopStatement);\n\n        if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {\n          this.alias = lexicalBoundary.getArgumentsAlias();\n        }\n\n        if (loop && loop.body.contains(this) && loop.depth > lexicalBoundary.depth) {\n          this.alias = lexicalBoundary.getArgumentsAlias();\n        }\n      }\n\n      this.findScope(false).addReference(this);\n    }\n  };\n\n  Identifier.prototype.isLabel = function isLabel() {\n    switch (this.parent.type) {\n      case 'BreakStatement':\n        return true;\n\n      case 'ContinueStatement':\n        return true;\n\n      case 'LabeledStatement':\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  Identifier.prototype.transpile = function transpile(code) {\n    if (this.alias) {\n      code.overwrite(this.start, this.end, this.alias, {\n        storeName: true,\n        contentOnly: true\n      });\n    }\n  };\n\n  return Identifier;\n}(Node);\n\nvar IfStatement = /*@__PURE__*/function (Node) {\n  function IfStatement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) IfStatement.__proto__ = Node;\n  IfStatement.prototype = Object.create(Node && Node.prototype);\n  IfStatement.prototype.constructor = IfStatement;\n\n  IfStatement.prototype.initialise = function initialise(transforms) {\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  IfStatement.prototype.transpile = function transpile(code, transforms) {\n    if (this.consequent.type !== 'BlockStatement' || this.consequent.type === 'BlockStatement' && this.consequent.synthetic) {\n      code.appendLeft(this.consequent.start, '{ ');\n      code.prependRight(this.consequent.end, ' }');\n    }\n\n    if (this.alternate && this.alternate.type !== 'IfStatement' && (this.alternate.type !== 'BlockStatement' || this.alternate.type === 'BlockStatement' && this.alternate.synthetic)) {\n      code.appendLeft(this.alternate.start, '{ ');\n      code.prependRight(this.alternate.end, ' }');\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return IfStatement;\n}(Node);\n\nvar Import = /*@__PURE__*/function (Node) {\n  function Import() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) Import.__proto__ = Node;\n  Import.prototype = Object.create(Node && Node.prototype);\n  Import.prototype.constructor = Import;\n\n  Import.prototype.initialise = function initialise(transforms) {\n    if (transforms.moduleImport) {\n      CompileError.missingTransform(\"dynamic import expressions\", \"moduleImport\", this);\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return Import;\n}(Node);\n\nvar ImportDeclaration = /*@__PURE__*/function (Node) {\n  function ImportDeclaration() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ImportDeclaration.__proto__ = Node;\n  ImportDeclaration.prototype = Object.create(Node && Node.prototype);\n  ImportDeclaration.prototype.constructor = ImportDeclaration;\n\n  ImportDeclaration.prototype.initialise = function initialise(transforms) {\n    if (transforms.moduleImport) {\n      CompileError.missingTransform(\"import\", \"moduleImport\", this);\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return ImportDeclaration;\n}(Node);\n\nvar ImportDefaultSpecifier = /*@__PURE__*/function (Node) {\n  function ImportDefaultSpecifier() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ImportDefaultSpecifier.__proto__ = Node;\n  ImportDefaultSpecifier.prototype = Object.create(Node && Node.prototype);\n  ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier;\n\n  ImportDefaultSpecifier.prototype.initialise = function initialise(transforms) {\n    this.findScope(true).addDeclaration(this.local, 'import');\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return ImportDefaultSpecifier;\n}(Node);\n\nvar ImportSpecifier = /*@__PURE__*/function (Node) {\n  function ImportSpecifier() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ImportSpecifier.__proto__ = Node;\n  ImportSpecifier.prototype = Object.create(Node && Node.prototype);\n  ImportSpecifier.prototype.constructor = ImportSpecifier;\n\n  ImportSpecifier.prototype.initialise = function initialise(transforms) {\n    this.findScope(true).addDeclaration(this.local, 'import');\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  return ImportSpecifier;\n}(Node);\n\nvar hasDashes = function hasDashes(val) {\n  return /-/.test(val);\n};\n\nvar formatKey = function formatKey(key) {\n  return hasDashes(key) ? \"'\" + key + \"'\" : key;\n};\n\nvar formatVal = function formatVal(val) {\n  return val ? '' : 'true';\n};\n\nvar JSXAttribute = /*@__PURE__*/function (Node) {\n  function JSXAttribute() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXAttribute.__proto__ = Node;\n  JSXAttribute.prototype = Object.create(Node && Node.prototype);\n  JSXAttribute.prototype.constructor = JSXAttribute;\n\n  JSXAttribute.prototype.transpile = function transpile(code, transforms) {\n    var ref = this.name;\n    var start = ref.start;\n    var name = ref.name; // Overwrite equals sign if value is present.\n\n    var end = this.value ? this.value.start : this.name.end;\n    code.overwrite(start, end, formatKey(name) + \": \" + formatVal(this.value));\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return JSXAttribute;\n}(Node);\n\nfunction containsNewLine(node) {\n  return node.type === 'JSXText' && !/\\S/.test(node.value) && /\\n/.test(node.value);\n}\n\nvar JSXClosingElement = /*@__PURE__*/function (Node) {\n  function JSXClosingElement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXClosingElement.__proto__ = Node;\n  JSXClosingElement.prototype = Object.create(Node && Node.prototype);\n  JSXClosingElement.prototype.constructor = JSXClosingElement;\n\n  JSXClosingElement.prototype.transpile = function transpile(code) {\n    var spaceBeforeParen = true;\n    var lastChild = this.parent.children[this.parent.children.length - 1]; // omit space before closing paren if\n    //   a) this is on a separate line, or\n    //   b) there are no children but there are attributes\n\n    if (lastChild && containsNewLine(lastChild) || this.parent.openingElement.attributes.length) {\n      spaceBeforeParen = false;\n    }\n\n    code.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');\n  };\n\n  return JSXClosingElement;\n}(Node);\n\nfunction containsNewLine$1(node) {\n  return node.type === 'JSXText' && !/\\S/.test(node.value) && /\\n/.test(node.value);\n}\n\nvar JSXClosingFragment = /*@__PURE__*/function (Node) {\n  function JSXClosingFragment() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXClosingFragment.__proto__ = Node;\n  JSXClosingFragment.prototype = Object.create(Node && Node.prototype);\n  JSXClosingFragment.prototype.constructor = JSXClosingFragment;\n\n  JSXClosingFragment.prototype.transpile = function transpile(code) {\n    var spaceBeforeParen = true;\n    var lastChild = this.parent.children[this.parent.children.length - 1]; // omit space before closing paren if this is on a separate line\n\n    if (lastChild && containsNewLine$1(lastChild)) {\n      spaceBeforeParen = false;\n    }\n\n    code.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');\n  };\n\n  return JSXClosingFragment;\n}(Node);\n\nfunction normalise(str, removeTrailingWhitespace) {\n  if (removeTrailingWhitespace && /\\n/.test(str)) {\n    str = str.replace(/[ \\f\\n\\r\\t\\v]+$/, '');\n  }\n\n  str = str.replace(/^\\n\\r?[ \\f\\n\\r\\t\\v]+/, '') // remove leading newline + space\n  .replace(/[ \\f\\n\\r\\t\\v]*\\n\\r?[ \\f\\n\\r\\t\\v]*/gm, ' '); // replace newlines with spaces\n  // TODO prefer single quotes?\n\n  return JSON.stringify(str);\n}\n\nvar JSXElement = /*@__PURE__*/function (Node) {\n  function JSXElement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXElement.__proto__ = Node;\n  JSXElement.prototype = Object.create(Node && Node.prototype);\n  JSXElement.prototype.constructor = JSXElement;\n\n  JSXElement.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n    var children = this.children.filter(function (child) {\n      if (child.type !== 'JSXText') {\n        return true;\n      } // remove whitespace-only literals, unless on a single line\n\n\n      return /[^ \\f\\n\\r\\t\\v]/.test(child.raw) || !/\\n/.test(child.raw);\n    });\n\n    if (children.length) {\n      var c = (this.openingElement || this.openingFragment).end;\n      var i;\n\n      for (i = 0; i < children.length; i += 1) {\n        var child = children[i];\n        if (child.type === 'JSXExpressionContainer' && child.expression.type === 'JSXEmptyExpression') ;else {\n          var tail = code.original[c] === '\\n' && child.type !== 'JSXText' ? '' : ' ';\n          code.appendLeft(c, \",\" + tail);\n        }\n\n        if (child.type === 'JSXText') {\n          var str = normalise(child.value, i === children.length - 1);\n          code.overwrite(child.start, child.end, str);\n        }\n\n        c = child.end;\n      }\n    }\n  };\n\n  return JSXElement;\n}(Node);\n\nvar JSXExpressionContainer = /*@__PURE__*/function (Node) {\n  function JSXExpressionContainer() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXExpressionContainer.__proto__ = Node;\n  JSXExpressionContainer.prototype = Object.create(Node && Node.prototype);\n  JSXExpressionContainer.prototype.constructor = JSXExpressionContainer;\n\n  JSXExpressionContainer.prototype.transpile = function transpile(code, transforms) {\n    code.remove(this.start, this.expression.start);\n    code.remove(this.expression.end, this.end);\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return JSXExpressionContainer;\n}(Node);\n\nvar JSXFragment = /*@__PURE__*/function (JSXElement) {\n  function JSXFragment() {\n    JSXElement.apply(this, arguments);\n  }\n\n  if (JSXElement) JSXFragment.__proto__ = JSXElement;\n  JSXFragment.prototype = Object.create(JSXElement && JSXElement.prototype);\n  JSXFragment.prototype.constructor = JSXFragment;\n  return JSXFragment;\n}(JSXElement);\n\nvar JSXOpeningElement = /*@__PURE__*/function (Node) {\n  function JSXOpeningElement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXOpeningElement.__proto__ = Node;\n  JSXOpeningElement.prototype = Object.create(Node && Node.prototype);\n  JSXOpeningElement.prototype.constructor = JSXOpeningElement;\n\n  JSXOpeningElement.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n    code.overwrite(this.start, this.name.start, this.program.jsx + \"( \");\n    var html = this.name.type === 'JSXIdentifier' && this.name.name[0] === this.name.name[0].toLowerCase();\n\n    if (html) {\n      code.prependRight(this.name.start, \"'\");\n    }\n\n    var len = this.attributes.length;\n    var c = this.name.end;\n\n    if (len) {\n      var i;\n      var hasSpread = false;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.attributes[i].type === 'JSXSpreadAttribute') {\n          hasSpread = true;\n          break;\n        }\n      }\n\n      c = this.attributes[0].end;\n\n      for (i = 0; i < len; i += 1) {\n        var attr = this.attributes[i];\n\n        if (i > 0) {\n          if (attr.start === c) {\n            code.prependRight(c, ', ');\n          } else {\n            code.overwrite(c, attr.start, ', ');\n          }\n        }\n\n        if (hasSpread && attr.type !== 'JSXSpreadAttribute') {\n          var lastAttr = this.attributes[i - 1];\n          var nextAttr = this.attributes[i + 1];\n\n          if (!lastAttr || lastAttr.type === 'JSXSpreadAttribute') {\n            code.prependRight(attr.start, '{ ');\n          }\n\n          if (!nextAttr || nextAttr.type === 'JSXSpreadAttribute') {\n            code.appendLeft(attr.end, ' }');\n          }\n        }\n\n        c = attr.end;\n      }\n\n      var after;\n      var before;\n\n      if (hasSpread) {\n        if (len === 1) {\n          before = html ? \"',\" : ',';\n        } else {\n          if (!this.program.options.objectAssign) {\n            throw new CompileError(\"Mixed JSX attributes ending in spread requires specified objectAssign option with 'Object.assign' or polyfill helper.\", this);\n          }\n\n          before = html ? \"', \" + this.program.options.objectAssign + \"({},\" : \", \" + this.program.options.objectAssign + \"({},\";\n          after = ')';\n        }\n      } else {\n        before = html ? \"', {\" : ', {';\n        after = ' }';\n      }\n\n      code.prependRight(this.name.end, before);\n\n      if (after) {\n        code.appendLeft(this.attributes[len - 1].end, after);\n      }\n    } else {\n      code.appendLeft(this.name.end, html ? \"', null\" : \", null\");\n      c = this.name.end;\n    }\n\n    if (this.selfClosing) {\n      code.overwrite(c, this.end, this.attributes.length ? \")\" : \" )\");\n    } else {\n      code.remove(c, this.end);\n    }\n  };\n\n  return JSXOpeningElement;\n}(Node);\n\nvar JSXOpeningFragment = /*@__PURE__*/function (Node) {\n  function JSXOpeningFragment() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXOpeningFragment.__proto__ = Node;\n  JSXOpeningFragment.prototype = Object.create(Node && Node.prototype);\n  JSXOpeningFragment.prototype.constructor = JSXOpeningFragment;\n\n  JSXOpeningFragment.prototype.transpile = function transpile(code) {\n    code.overwrite(this.start, this.end, this.program.jsx + \"( \" + this.program.jsxFragment + \", null\");\n  };\n\n  return JSXOpeningFragment;\n}(Node);\n\nvar JSXSpreadAttribute = /*@__PURE__*/function (Node) {\n  function JSXSpreadAttribute() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) JSXSpreadAttribute.__proto__ = Node;\n  JSXSpreadAttribute.prototype = Object.create(Node && Node.prototype);\n  JSXSpreadAttribute.prototype.constructor = JSXSpreadAttribute;\n\n  JSXSpreadAttribute.prototype.transpile = function transpile(code, transforms) {\n    code.remove(this.start, this.argument.start);\n    code.remove(this.argument.end, this.end);\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return JSXSpreadAttribute;\n}(Node);\n\nvar nonAsciiLsOrPs = /[\\u2028-\\u2029]/g;\n\nvar Literal = /*@__PURE__*/function (Node) {\n  function Literal() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) Literal.__proto__ = Node;\n  Literal.prototype = Object.create(Node && Node.prototype);\n  Literal.prototype.constructor = Literal;\n\n  Literal.prototype.initialise = function initialise() {\n    if (typeof this.value === 'string') {\n      this.program.indentExclusionElements.push(this);\n    }\n  };\n\n  Literal.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.numericLiteral) {\n      if (this.raw.match(/^0[bo]/i)) {\n        code.overwrite(this.start, this.end, String(this.value), {\n          storeName: true,\n          contentOnly: true\n        });\n      }\n    }\n\n    if (this.regex) {\n      var ref = this.regex;\n      var pattern = ref.pattern;\n      var flags = ref.flags;\n\n      if (transforms.stickyRegExp && /y/.test(flags)) {\n        CompileError.missingTransform('the regular expression sticky flag', 'stickyRegExp', this);\n      }\n\n      if (transforms.unicodeRegExp && /u/.test(flags)) {\n        code.overwrite(this.start, this.end, \"/\" + rewritePattern(pattern, flags) + \"/\" + flags.replace('u', ''), {\n          contentOnly: true\n        });\n      }\n    } else if (typeof this.value === \"string\" && this.value.match(nonAsciiLsOrPs)) {\n      code.overwrite(this.start, this.end, this.raw.replace(nonAsciiLsOrPs, function (m) {\n        return m == \"\\u2028\" ? \"\\\\u2028\" : \"\\\\u2029\";\n      }), {\n        contentOnly: true\n      });\n    }\n  };\n\n  return Literal;\n}(Node);\n\nvar MemberExpression = /*@__PURE__*/function (Node) {\n  function MemberExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) MemberExpression.__proto__ = Node;\n  MemberExpression.prototype = Object.create(Node && Node.prototype);\n  MemberExpression.prototype.constructor = MemberExpression;\n\n  MemberExpression.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.reservedProperties && reserved[this.property.name]) {\n      code.overwrite(this.object.end, this.property.start, \"['\");\n      code.appendLeft(this.property.end, \"']\");\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return MemberExpression;\n}(Node);\n\nvar NewExpression = /*@__PURE__*/function (Node) {\n  function NewExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) NewExpression.__proto__ = Node;\n  NewExpression.prototype = Object.create(Node && Node.prototype);\n  NewExpression.prototype.constructor = NewExpression;\n\n  NewExpression.prototype.initialise = function initialise(transforms) {\n    if (transforms.spreadRest && this.arguments.length) {\n      var lexicalBoundary = this.findLexicalBoundary();\n      var i = this.arguments.length;\n\n      while (i--) {\n        var arg = this.arguments[i];\n\n        if (arg.type === 'SpreadElement' && isArguments(arg.argument)) {\n          this.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();\n          break;\n        }\n      }\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  NewExpression.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (transforms.spreadRest && this.arguments.length) {\n      inlineSpreads(code, this, this.arguments); // this.arguments.length may have changed, must retest.\n    }\n\n    if (transforms.spreadRest && this.arguments.length) {\n      var firstArgument = this.arguments[0];\n      var isNew = true;\n      var hasSpreadElements = spread(code, this.arguments, firstArgument.start, this.argumentsArrayAlias, isNew);\n\n      if (hasSpreadElements) {\n        code.prependRight(this.start + 'new'.length, ' (Function.prototype.bind.apply(');\n        code.overwrite(this.callee.end, firstArgument.start, ', [ null ].concat( ');\n        code.appendLeft(this.end, ' ))');\n      }\n    }\n\n    if (this.arguments.length) {\n      removeTrailingComma(code, this.arguments[this.arguments.length - 1].end);\n    }\n  };\n\n  return NewExpression;\n}(Node);\n\nvar ObjectExpression = /*@__PURE__*/function (Node) {\n  function ObjectExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ObjectExpression.__proto__ = Node;\n  ObjectExpression.prototype = Object.create(Node && Node.prototype);\n  ObjectExpression.prototype.constructor = ObjectExpression;\n\n  ObjectExpression.prototype.transpile = function transpile(code, transforms) {\n    var ref;\n    Node.prototype.transpile.call(this, code, transforms);\n    var firstPropertyStart = this.start + 1;\n    var spreadPropertyCount = 0;\n    var computedPropertyCount = 0;\n    var firstSpreadProperty = null;\n    var firstComputedProperty = null;\n\n    for (var i = 0; i < this.properties.length; ++i) {\n      var prop = this.properties[i];\n\n      if (prop.type === 'SpreadElement') {\n        // First see if we can inline the spread, to save needing objectAssign.\n        var argument = prop.argument;\n\n        if (argument.type === 'ObjectExpression' || argument.type === 'Literal' && typeof argument.value !== 'string') {\n          if (argument.type === 'ObjectExpression' && argument.properties.length > 0) {\n            // Strip the `...{` and the `}` with a possible trailing comma before it,\n            // leaving just the possible trailing comma after it.\n            code.remove(prop.start, argument.properties[0].start);\n            code.remove(argument.properties[argument.properties.length - 1].end, prop.end);\n            (ref = this.properties).splice.apply(ref, [i, 1].concat(argument.properties));\n            i--;\n          } else {\n            // An empty object, boolean, null, undefined, number or regexp (but NOT\n            // string) will spread to nothing, so just remove the element altogether,\n            // including a possible trailing comma.\n            code.remove(prop.start, i === this.properties.length - 1 ? prop.end : this.properties[i + 1].start);\n            this.properties.splice(i, 1);\n            i--;\n          }\n        } else {\n          spreadPropertyCount += 1;\n\n          if (firstSpreadProperty === null) {\n            firstSpreadProperty = i;\n          }\n        }\n      } else if (prop.computed && transforms.computedProperty) {\n        computedPropertyCount += 1;\n\n        if (firstComputedProperty === null) {\n          firstComputedProperty = i;\n        }\n      }\n    }\n\n    if (spreadPropertyCount && !transforms.objectRestSpread && !(computedPropertyCount && transforms.computedProperty)) {\n      spreadPropertyCount = 0;\n      firstSpreadProperty = null;\n    } else if (spreadPropertyCount) {\n      if (!this.program.options.objectAssign) {\n        throw new CompileError(\"Object spread operator requires specified objectAssign option with 'Object.assign' or polyfill helper.\", this);\n      }\n\n      var i$1 = this.properties.length;\n\n      while (i$1--) {\n        var prop$1 = this.properties[i$1]; // enclose run of non-spread properties in curlies\n\n        if (prop$1.type === 'Property' && !computedPropertyCount) {\n          var lastProp = this.properties[i$1 - 1];\n          var nextProp = this.properties[i$1 + 1];\n\n          if (!lastProp || lastProp.type !== 'Property') {\n            code.prependRight(prop$1.start, '{');\n          }\n\n          if (!nextProp || nextProp.type !== 'Property') {\n            code.appendLeft(prop$1.end, '}');\n          }\n        } // Remove ellipsis on spread property\n\n\n        if (prop$1.type === 'SpreadElement') {\n          code.remove(prop$1.start, prop$1.argument.start);\n          code.remove(prop$1.argument.end, prop$1.end);\n        }\n      } // wrap the whole thing in Object.assign\n\n\n      firstPropertyStart = this.properties[0].start;\n\n      if (!computedPropertyCount) {\n        code.overwrite(this.start, firstPropertyStart, this.program.options.objectAssign + \"({}, \");\n        code.overwrite(this.properties[this.properties.length - 1].end, this.end, ')');\n      } else if (this.properties[0].type === 'SpreadElement') {\n        code.overwrite(this.start, firstPropertyStart, this.program.options.objectAssign + \"({}, \");\n        code.remove(this.end - 1, this.end);\n        code.appendRight(this.end, ')');\n      } else {\n        code.prependLeft(this.start, this.program.options.objectAssign + \"(\");\n        code.appendRight(this.end, ')');\n      }\n    }\n\n    if (computedPropertyCount && transforms.computedProperty) {\n      var i0 = this.getIndentation();\n      var isSimpleAssignment;\n      var name;\n\n      if (this.parent.type === 'VariableDeclarator' && this.parent.parent.declarations.length === 1 && this.parent.id.type === 'Identifier') {\n        isSimpleAssignment = true;\n        name = this.parent.id.alias || this.parent.id.name; // TODO is this right?\n      } else if (this.parent.type === 'AssignmentExpression' && this.parent.parent.type === 'ExpressionStatement' && this.parent.left.type === 'Identifier') {\n        isSimpleAssignment = true;\n        name = this.parent.left.alias || this.parent.left.name; // TODO is this right?\n      } else if (this.parent.type === 'AssignmentPattern' && this.parent.left.type === 'Identifier') {\n        isSimpleAssignment = true;\n        name = this.parent.left.alias || this.parent.left.name; // TODO is this right?\n      }\n\n      if (spreadPropertyCount) {\n        isSimpleAssignment = false;\n      } // handle block scoping\n\n\n      name = this.findScope(false).resolveName(name);\n      var start = firstPropertyStart;\n      var end = this.end;\n      if (isSimpleAssignment) ;else {\n        if (firstSpreadProperty === null || firstComputedProperty < firstSpreadProperty) {\n          name = this.findScope(true).createDeclaration('obj');\n          code.prependRight(this.start, \"( \" + name + \" = \");\n        } else {\n          name = null;\n        } // We don't actually need this variable\n\n      }\n      var len = this.properties.length;\n      var lastComputedProp;\n      var sawNonComputedProperty = false;\n      var isFirst = true;\n\n      for (var i$2 = 0; i$2 < len; i$2 += 1) {\n        var prop$2 = this.properties[i$2];\n        var moveStart = i$2 > 0 ? this.properties[i$2 - 1].end : start;\n\n        if (prop$2.type === 'Property' && (prop$2.computed || lastComputedProp && !spreadPropertyCount)) {\n          if (i$2 === 0) {\n            moveStart = this.start + 1;\n          } // Trim leading whitespace\n\n\n          lastComputedProp = prop$2;\n\n          if (!name) {\n            name = this.findScope(true).createDeclaration('obj');\n            var propId = name + (prop$2.computed ? '' : '.');\n            code.appendRight(prop$2.start, \"( \" + name + \" = {}, \" + propId);\n          } else {\n            var propId$1 = (isSimpleAssignment ? \";\\n\" + i0 + name : \", \" + name) + (prop$2.key.type === 'Literal' || prop$2.computed ? '' : '.');\n\n            if (moveStart < prop$2.start) {\n              code.overwrite(moveStart, prop$2.start, propId$1);\n            } else {\n              code.prependRight(prop$2.start, propId$1);\n            }\n          }\n\n          var c = prop$2.key.end;\n\n          if (prop$2.computed) {\n            while (code.original[c] !== ']') {\n              c += 1;\n            }\n\n            c += 1;\n          }\n\n          if (prop$2.key.type === 'Literal' && !prop$2.computed) {\n            code.overwrite(prop$2.start, prop$2.value.start, '[' + code.slice(prop$2.start, prop$2.key.end) + '] = ');\n          } else if (prop$2.shorthand || prop$2.method && !prop$2.computed && transforms.conciseMethodProperty) {\n            // Replace : with = if Property::transpile inserted the :\n            code.overwrite(prop$2.key.start, prop$2.key.end, code.slice(prop$2.key.start, prop$2.key.end).replace(/:/, ' ='));\n          } else {\n            if (prop$2.value.start > c) {\n              code.remove(c, prop$2.value.start);\n            }\n\n            code.prependLeft(c, ' = ');\n          } // This duplicates behavior from Property::transpile which is disabled\n          // for computed properties or if conciseMethodProperty is false\n\n\n          if (prop$2.method && (prop$2.computed || !transforms.conciseMethodProperty)) {\n            if (prop$2.value.generator) {\n              code.remove(prop$2.start, prop$2.key.start);\n            }\n\n            code.prependRight(prop$2.value.start, \"function\" + (prop$2.value.generator ? '*' : '') + \" \");\n          }\n        } else if (prop$2.type === 'SpreadElement') {\n          if (name && i$2 > 0) {\n            if (!lastComputedProp) {\n              lastComputedProp = this.properties[i$2 - 1];\n            }\n\n            code.appendLeft(lastComputedProp.end, \", \" + name + \" )\");\n            lastComputedProp = null;\n            name = null;\n          }\n        } else {\n          if (!isFirst && spreadPropertyCount) {\n            // We are in an Object.assign context, so we need to wrap regular properties\n            code.prependRight(prop$2.start, '{');\n            code.appendLeft(prop$2.end, '}');\n          }\n\n          sawNonComputedProperty = true;\n        }\n\n        if (isFirst && (prop$2.type === 'SpreadElement' || prop$2.computed)) {\n          var beginEnd = sawNonComputedProperty ? this.properties[this.properties.length - 1].end : this.end - 1; // Trim trailing comma because it can easily become a leading comma which is illegal\n\n          if (code.original[beginEnd] == ',') {\n            ++beginEnd;\n          }\n\n          var closing = code.slice(beginEnd, end);\n          code.prependLeft(moveStart, closing);\n          code.remove(beginEnd, end);\n          isFirst = false;\n        } // Clean up some extranous whitespace\n\n\n        var c$1 = prop$2.end;\n\n        if (i$2 < len - 1 && !sawNonComputedProperty) {\n          while (code.original[c$1] !== ',') {\n            c$1 += 1;\n          }\n        } else if (i$2 == len - 1) {\n          c$1 = this.end;\n        }\n\n        if (prop$2.end != c$1) {\n          code.overwrite(prop$2.end, c$1, '', {\n            contentOnly: true\n          });\n        }\n      }\n\n      if (!isSimpleAssignment && name) {\n        code.appendLeft(lastComputedProp.end, \", \" + name + \" )\");\n      }\n    }\n  };\n\n  return ObjectExpression;\n}(Node);\n\nvar Property = /*@__PURE__*/function (Node) {\n  function Property() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) Property.__proto__ = Node;\n  Property.prototype = Object.create(Node && Node.prototype);\n  Property.prototype.constructor = Property;\n\n  Property.prototype.initialise = function initialise(transforms) {\n    if ((this.kind === 'get' || this.kind === 'set') && transforms.getterSetter) {\n      CompileError.missingTransform(\"getters and setters\", \"getterSetter\", this);\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  Property.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (transforms.conciseMethodProperty && !this.computed && this.parent.type !== 'ObjectPattern') {\n      if (this.shorthand) {\n        code.prependRight(this.start, this.key.name + \": \");\n      } else if (this.method) {\n        var name = '';\n\n        if (this.program.options.namedFunctionExpressions !== false) {\n          if (this.key.type === 'Literal' && typeof this.key.value === 'number') {\n            name = '';\n          } else if (this.key.type === 'Identifier') {\n            if (reserved[this.key.name] || !/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) || this.value.body.scope.references[this.key.name]) {\n              name = this.findScope(true).createIdentifier(this.key.name);\n            } else {\n              name = this.key.name;\n            }\n          } else {\n            name = this.findScope(true).createIdentifier(this.key.value);\n          }\n\n          name = ' ' + name;\n        }\n\n        if (this.start < this.key.start) {\n          code.remove(this.start, this.key.start);\n        }\n\n        code.appendLeft(this.key.end, \": \" + (this.value.async ? 'async ' : '') + \"function\" + (this.value.generator ? '*' : '') + name);\n      }\n    }\n\n    if (transforms.reservedProperties && reserved[this.key.name]) {\n      code.prependRight(this.key.start, \"'\");\n      code.appendLeft(this.key.end, \"'\");\n    }\n  };\n\n  return Property;\n}(Node);\n\nvar ReturnStatement = /*@__PURE__*/function (Node) {\n  function ReturnStatement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ReturnStatement.__proto__ = Node;\n  ReturnStatement.prototype = Object.create(Node && Node.prototype);\n  ReturnStatement.prototype.constructor = ReturnStatement;\n\n  ReturnStatement.prototype.initialise = function initialise(transforms) {\n    this.loop = this.findNearest(loopStatement);\n    this.nearestFunction = this.findNearest(/Function/);\n\n    if (this.loop && (!this.nearestFunction || this.loop.depth > this.nearestFunction.depth)) {\n      this.loop.canReturn = true;\n      this.shouldWrap = true;\n    }\n\n    if (this.argument) {\n      this.argument.initialise(transforms);\n    }\n  };\n\n  ReturnStatement.prototype.transpile = function transpile(code, transforms) {\n    var shouldWrap = this.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction;\n\n    if (this.argument) {\n      if (shouldWrap) {\n        code.prependRight(this.argument.start, \"{ v: \");\n      }\n\n      this.argument.transpile(code, transforms);\n\n      if (shouldWrap) {\n        code.appendLeft(this.argument.end, \" }\");\n      }\n    } else if (shouldWrap) {\n      code.appendLeft(this.start + 6, ' {}');\n    }\n  };\n\n  return ReturnStatement;\n}(Node);\n\nvar Super = /*@__PURE__*/function (Node) {\n  function Super() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) Super.__proto__ = Node;\n  Super.prototype = Object.create(Node && Node.prototype);\n  Super.prototype.constructor = Super;\n\n  Super.prototype.initialise = function initialise(transforms) {\n    if (transforms.classes) {\n      this.method = this.findNearest('MethodDefinition');\n\n      if (!this.method) {\n        throw new CompileError('use of super outside class method', this);\n      }\n\n      var parentClass = this.findNearest('ClassBody').parent;\n      this.superClassName = parentClass.superClass && (parentClass.superClass.name || 'superclass');\n\n      if (!this.superClassName) {\n        throw new CompileError('super used in base class', this);\n      }\n\n      this.isCalled = this.parent.type === 'CallExpression' && this === this.parent.callee;\n\n      if (this.method.kind !== 'constructor' && this.isCalled) {\n        throw new CompileError('super() not allowed outside class constructor', this);\n      }\n\n      this.isMember = this.parent.type === 'MemberExpression';\n\n      if (!this.isCalled && !this.isMember) {\n        throw new CompileError('Unexpected use of `super` (expected `super(...)` or `super.*`)', this);\n      }\n    }\n\n    if (transforms.arrow) {\n      var lexicalBoundary = this.findLexicalBoundary();\n      var arrowFunction = this.findNearest('ArrowFunctionExpression');\n      var loop = this.findNearest(loopStatement);\n\n      if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {\n        this.thisAlias = lexicalBoundary.getThisAlias();\n      }\n\n      if (loop && loop.body.contains(this) && loop.depth > lexicalBoundary.depth) {\n        this.thisAlias = lexicalBoundary.getThisAlias();\n      }\n    }\n  };\n\n  Super.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.classes) {\n      var expression = this.isCalled || this.method.static ? this.superClassName : this.superClassName + \".prototype\";\n      code.overwrite(this.start, this.end, expression, {\n        storeName: true,\n        contentOnly: true\n      });\n      var callExpression = this.isCalled ? this.parent : this.parent.parent;\n\n      if (callExpression && callExpression.type === 'CallExpression') {\n        if (!this.noCall) {\n          // special case – `super( ...args )`\n          code.appendLeft(callExpression.callee.end, '.call');\n        }\n\n        var thisAlias = this.thisAlias || 'this';\n\n        if (callExpression.arguments.length) {\n          code.appendLeft(callExpression.arguments[0].start, thisAlias + \", \");\n        } else {\n          code.appendLeft(callExpression.end - 1, \"\" + thisAlias);\n        }\n      }\n    }\n  };\n\n  return Super;\n}(Node);\n\nvar TaggedTemplateExpression = /*@__PURE__*/function (Node) {\n  function TaggedTemplateExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) TaggedTemplateExpression.__proto__ = Node;\n  TaggedTemplateExpression.prototype = Object.create(Node && Node.prototype);\n  TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression;\n\n  TaggedTemplateExpression.prototype.initialise = function initialise(transforms) {\n    if (transforms.templateString && !transforms.dangerousTaggedTemplateString) {\n      CompileError.missingTransform(\"tagged template strings\", \"templateString\", this, \"dangerousTaggedTemplateString\");\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  TaggedTemplateExpression.prototype.transpile = function transpile(code, transforms) {\n    if (transforms.templateString && transforms.dangerousTaggedTemplateString) {\n      var ordered = this.quasi.expressions.concat(this.quasi.quasis).sort(function (a, b) {\n        return a.start - b.start;\n      });\n      var program = this.program;\n      var rootScope = program.body.scope; // insert strings at start\n\n      var templateStrings = this.quasi.quasis.map(function (quasi) {\n        return JSON.stringify(quasi.value.cooked);\n      }).join(', ');\n      var templateObject = this.program.templateLiteralQuasis[templateStrings];\n\n      if (!templateObject) {\n        templateObject = rootScope.createIdentifier('templateObject');\n        code.prependLeft(this.program.prependAt, \"var \" + templateObject + \" = Object.freeze([\" + templateStrings + \"]);\\n\");\n        this.program.templateLiteralQuasis[templateStrings] = templateObject;\n      }\n\n      code.overwrite(this.tag.end, ordered[0].start, \"(\" + templateObject);\n      var lastIndex = ordered[0].start;\n      ordered.forEach(function (node) {\n        if (node.type === 'TemplateElement') {\n          code.remove(lastIndex, node.end);\n        } else {\n          code.overwrite(lastIndex, node.start, ', ');\n        }\n\n        lastIndex = node.end;\n      });\n      code.overwrite(lastIndex, this.end, ')');\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return TaggedTemplateExpression;\n}(Node);\n\nvar TemplateElement = /*@__PURE__*/function (Node) {\n  function TemplateElement() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) TemplateElement.__proto__ = Node;\n  TemplateElement.prototype = Object.create(Node && Node.prototype);\n  TemplateElement.prototype.constructor = TemplateElement;\n\n  TemplateElement.prototype.initialise = function initialise() {\n    this.program.indentExclusionElements.push(this);\n  };\n\n  return TemplateElement;\n}(Node);\n\nvar TemplateLiteral = /*@__PURE__*/function (Node) {\n  function TemplateLiteral() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) TemplateLiteral.__proto__ = Node;\n  TemplateLiteral.prototype = Object.create(Node && Node.prototype);\n  TemplateLiteral.prototype.constructor = TemplateLiteral;\n\n  TemplateLiteral.prototype.transpile = function transpile(code, transforms) {\n    Node.prototype.transpile.call(this, code, transforms);\n\n    if (transforms.templateString && this.parent.type !== 'TaggedTemplateExpression') {\n      var ordered = this.expressions.concat(this.quasis).sort(function (a, b) {\n        return a.start - b.start || a.end - b.end;\n      }).filter(function (node, i) {\n        // include all expressions\n        if (node.type !== 'TemplateElement') {\n          return true;\n        } // include all non-empty strings\n\n\n        if (node.value.raw) {\n          return true;\n        } // exclude all empty strings not at the head\n\n\n        return !i;\n      }); // special case – we may be able to skip the first element,\n      // if it's the empty string, but only if the second and\n      // third elements aren't both expressions (since they maybe\n      // be numeric, and `1 + 2 + '3' === '33'`)\n\n      if (ordered.length >= 3) {\n        var first = ordered[0];\n        var third = ordered[2];\n\n        if (first.type === 'TemplateElement' && first.value.raw === '' && third.type === 'TemplateElement') {\n          ordered.shift();\n        }\n      }\n\n      var parenthesise = (this.quasis.length !== 1 || this.expressions.length !== 0) && this.parent.type !== 'TemplateLiteral' && this.parent.type !== 'AssignmentExpression' && this.parent.type !== 'AssignmentPattern' && this.parent.type !== 'VariableDeclarator' && (this.parent.type !== 'BinaryExpression' || this.parent.operator !== '+');\n\n      if (parenthesise) {\n        code.appendRight(this.start, '(');\n      }\n\n      var lastIndex = this.start;\n      ordered.forEach(function (node, i) {\n        var prefix = i === 0 ? parenthesise ? '(' : '' : ' + ';\n\n        if (node.type === 'TemplateElement') {\n          code.overwrite(lastIndex, node.end, prefix + JSON.stringify(node.value.cooked));\n        } else {\n          var parenthesise$1 = node.type !== 'Identifier'; // TODO other cases where it's safe\n\n          if (parenthesise$1) {\n            prefix += '(';\n          }\n\n          code.remove(lastIndex, node.start);\n\n          if (prefix) {\n            code.prependRight(node.start, prefix);\n          }\n\n          if (parenthesise$1) {\n            code.appendLeft(node.end, ')');\n          }\n        }\n\n        lastIndex = node.end;\n      });\n\n      if (parenthesise) {\n        code.appendLeft(lastIndex, ')');\n      }\n\n      code.overwrite(lastIndex, this.end, \"\", {\n        contentOnly: true\n      });\n    }\n  };\n\n  return TemplateLiteral;\n}(Node);\n\nvar ThisExpression = /*@__PURE__*/function (Node) {\n  function ThisExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) ThisExpression.__proto__ = Node;\n  ThisExpression.prototype = Object.create(Node && Node.prototype);\n  ThisExpression.prototype.constructor = ThisExpression;\n\n  ThisExpression.prototype.initialise = function initialise(transforms) {\n    var lexicalBoundary = this.findLexicalBoundary();\n\n    if (transforms.letConst) {\n      // save all loops up to the lexical boundary in case we need\n      // to alias them later for block-scoped declarations\n      var node = this.findNearest(loopStatement);\n\n      while (node && node.depth > lexicalBoundary.depth) {\n        node.thisRefs.push(this);\n        node = node.parent.findNearest(loopStatement);\n      }\n    }\n\n    if (transforms.arrow) {\n      var arrowFunction = this.findNearest('ArrowFunctionExpression');\n\n      if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {\n        this.alias = lexicalBoundary.getThisAlias();\n      }\n    }\n  };\n\n  ThisExpression.prototype.transpile = function transpile(code) {\n    if (this.alias) {\n      code.overwrite(this.start, this.end, this.alias, {\n        storeName: true,\n        contentOnly: true\n      });\n    }\n  };\n\n  return ThisExpression;\n}(Node);\n\nvar UpdateExpression = /*@__PURE__*/function (Node) {\n  function UpdateExpression() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) UpdateExpression.__proto__ = Node;\n  UpdateExpression.prototype = Object.create(Node && Node.prototype);\n  UpdateExpression.prototype.constructor = UpdateExpression;\n\n  UpdateExpression.prototype.initialise = function initialise(transforms) {\n    if (this.argument.type === 'Identifier') {\n      var declaration = this.findScope(false).findDeclaration(this.argument.name); // special case – https://gitlab.com/Rich-Harris/buble/issues/150\n\n      var statement = declaration && declaration.node.ancestor(3);\n\n      if (statement && statement.type === 'ForStatement' && statement.body.contains(this)) {\n        statement.reassigned[this.argument.name] = true;\n      }\n    }\n\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  UpdateExpression.prototype.transpile = function transpile(code, transforms) {\n    if (this.argument.type === 'Identifier') {\n      // Do this check after everything has been initialized to find\n      // shadowing declarations after this expression\n      checkConst(this.argument, this.findScope(false));\n    }\n\n    Node.prototype.transpile.call(this, code, transforms);\n  };\n\n  return UpdateExpression;\n}(Node);\n\nvar VariableDeclaration = /*@__PURE__*/function (Node) {\n  function VariableDeclaration() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) VariableDeclaration.__proto__ = Node;\n  VariableDeclaration.prototype = Object.create(Node && Node.prototype);\n  VariableDeclaration.prototype.constructor = VariableDeclaration;\n\n  VariableDeclaration.prototype.initialise = function initialise(transforms) {\n    this.scope = this.findScope(this.kind === 'var');\n    this.declarations.forEach(function (declarator) {\n      return declarator.initialise(transforms);\n    });\n  };\n\n  VariableDeclaration.prototype.transpile = function transpile(code, transforms) {\n    var this$1 = this;\n    var i0 = this.getIndentation();\n    var kind = this.kind;\n\n    if (transforms.letConst && kind !== 'var') {\n      kind = 'var';\n      code.overwrite(this.start, this.start + this.kind.length, kind, {\n        contentOnly: true,\n        storeName: true\n      });\n    }\n\n    if (transforms.destructuring && this.parent.type !== 'ForOfStatement' && this.parent.type !== 'ForInStatement') {\n      var c = this.start;\n      var lastDeclaratorIsPattern;\n      this.declarations.forEach(function (declarator, i) {\n        declarator.transpile(code, transforms);\n\n        if (declarator.id.type === 'Identifier') {\n          if (i > 0 && this$1.declarations[i - 1].id.type !== 'Identifier') {\n            code.overwrite(c, declarator.id.start, \"var \");\n          }\n        } else {\n          var inline = loopStatement.test(this$1.parent.type);\n\n          if (i === 0) {\n            code.remove(c, declarator.id.start);\n          } else {\n            code.overwrite(c, declarator.id.start, \";\\n\" + i0);\n          }\n\n          var simple = declarator.init.type === 'Identifier' && !declarator.init.rewritten;\n          var name = simple ? declarator.init.alias || declarator.init.name : declarator.findScope(true).createIdentifier('ref');\n          c = declarator.start;\n          var statementGenerators = [];\n\n          if (simple) {\n            code.remove(declarator.id.end, declarator.end);\n          } else {\n            statementGenerators.push(function (start, prefix, suffix) {\n              code.prependRight(declarator.id.end, \"var \" + name);\n              code.appendLeft(declarator.init.end, \"\" + suffix);\n              code.move(declarator.id.end, declarator.end, start);\n            });\n          }\n\n          var scope = declarator.findScope(false);\n          destructure(code, function (id) {\n            return scope.createIdentifier(id);\n          }, function (ref) {\n            var name = ref.name;\n            return scope.resolveName(name);\n          }, declarator.id, name, inline, statementGenerators);\n          var prefix = inline ? 'var ' : '';\n          var suffix = inline ? \", \" : \";\\n\" + i0;\n          statementGenerators.forEach(function (fn, j) {\n            if (i === this$1.declarations.length - 1 && j === statementGenerators.length - 1) {\n              suffix = inline ? '' : ';';\n            }\n\n            fn(declarator.start, j === 0 ? prefix : '', suffix);\n          });\n        }\n\n        c = declarator.end;\n        lastDeclaratorIsPattern = declarator.id.type !== 'Identifier';\n      });\n\n      if (lastDeclaratorIsPattern && this.end > c) {\n        code.overwrite(c, this.end, '', {\n          contentOnly: true\n        });\n      }\n    } else {\n      this.declarations.forEach(function (declarator) {\n        declarator.transpile(code, transforms);\n      });\n    }\n  };\n\n  return VariableDeclaration;\n}(Node);\n\nvar VariableDeclarator = /*@__PURE__*/function (Node) {\n  function VariableDeclarator() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) VariableDeclarator.__proto__ = Node;\n  VariableDeclarator.prototype = Object.create(Node && Node.prototype);\n  VariableDeclarator.prototype.constructor = VariableDeclarator;\n\n  VariableDeclarator.prototype.initialise = function initialise(transforms) {\n    var kind = this.parent.kind;\n\n    if (kind === 'let' && this.parent.parent.type === 'ForStatement') {\n      kind = 'for.let'; // special case...\n    }\n\n    this.parent.scope.addDeclaration(this.id, kind);\n    Node.prototype.initialise.call(this, transforms);\n  };\n\n  VariableDeclarator.prototype.transpile = function transpile(code, transforms) {\n    if (!this.init && transforms.letConst && this.parent.kind !== 'var') {\n      var inLoop = this.findNearest(/Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/);\n\n      if (inLoop && !/Function/.test(inLoop.type) && !this.isLeftDeclaratorOfLoop()) {\n        code.appendLeft(this.id.end, ' = (void 0)');\n      }\n    }\n\n    if (this.id) {\n      this.id.transpile(code, transforms);\n    }\n\n    if (this.init) {\n      this.init.transpile(code, transforms);\n    }\n  };\n\n  VariableDeclarator.prototype.isLeftDeclaratorOfLoop = function isLeftDeclaratorOfLoop() {\n    return this.parent && this.parent.type === 'VariableDeclaration' && this.parent.parent && (this.parent.parent.type === 'ForInStatement' || this.parent.parent.type === 'ForOfStatement') && this.parent.parent.left && this.parent.parent.left.declarations[0] === this;\n  };\n\n  return VariableDeclarator;\n}(Node);\n\nvar types = {\n  ArrayExpression: ArrayExpression,\n  ArrowFunctionExpression: ArrowFunctionExpression,\n  AssignmentExpression: AssignmentExpression,\n  AwaitExpression: AwaitExpression,\n  BinaryExpression: BinaryExpression,\n  BreakStatement: BreakStatement,\n  CallExpression: CallExpression,\n  CatchClause: CatchClause,\n  ClassBody: ClassBody,\n  ClassDeclaration: ClassDeclaration,\n  ClassExpression: ClassExpression,\n  ContinueStatement: ContinueStatement,\n  DoWhileStatement: LoopStatement,\n  ExportNamedDeclaration: ExportNamedDeclaration,\n  ExportDefaultDeclaration: ExportDefaultDeclaration,\n  ForStatement: ForStatement,\n  ForInStatement: ForInStatement,\n  ForOfStatement: ForOfStatement,\n  FunctionDeclaration: FunctionDeclaration,\n  FunctionExpression: FunctionExpression,\n  Identifier: Identifier,\n  IfStatement: IfStatement,\n  Import: Import,\n  ImportDeclaration: ImportDeclaration,\n  ImportDefaultSpecifier: ImportDefaultSpecifier,\n  ImportSpecifier: ImportSpecifier,\n  JSXAttribute: JSXAttribute,\n  JSXClosingElement: JSXClosingElement,\n  JSXClosingFragment: JSXClosingFragment,\n  JSXElement: JSXElement,\n  JSXExpressionContainer: JSXExpressionContainer,\n  JSXFragment: JSXFragment,\n  JSXOpeningElement: JSXOpeningElement,\n  JSXOpeningFragment: JSXOpeningFragment,\n  JSXSpreadAttribute: JSXSpreadAttribute,\n  Literal: Literal,\n  MemberExpression: MemberExpression,\n  NewExpression: NewExpression,\n  ObjectExpression: ObjectExpression,\n  Property: Property,\n  ReturnStatement: ReturnStatement,\n  Super: Super,\n  TaggedTemplateExpression: TaggedTemplateExpression,\n  TemplateElement: TemplateElement,\n  TemplateLiteral: TemplateLiteral,\n  ThisExpression: ThisExpression,\n  UpdateExpression: UpdateExpression,\n  VariableDeclaration: VariableDeclaration,\n  VariableDeclarator: VariableDeclarator,\n  WhileStatement: LoopStatement\n};\nvar keys = {\n  Program: ['body'],\n  Literal: []\n};\nvar statementsWithBlocks = {\n  IfStatement: 'consequent',\n  ForStatement: 'body',\n  ForInStatement: 'body',\n  ForOfStatement: 'body',\n  WhileStatement: 'body',\n  DoWhileStatement: 'body',\n  ArrowFunctionExpression: 'body'\n};\n\nfunction wrap(raw, parent) {\n  if (!raw) {\n    return;\n  }\n\n  if ('length' in raw) {\n    var i = raw.length;\n\n    while (i--) {\n      wrap(raw[i], parent);\n    }\n\n    return;\n  } // with e.g. shorthand properties, key and value are\n  // the same node. We don't want to wrap an object twice\n\n\n  if (raw.__wrapped) {\n    return;\n  }\n\n  raw.__wrapped = true;\n\n  if (!keys[raw.type]) {\n    keys[raw.type] = Object.keys(raw).filter(function (key) {\n      return typeof raw[key] === 'object';\n    });\n  } // special case – body-less if/for/while statements. TODO others?\n\n\n  var bodyType = statementsWithBlocks[raw.type];\n\n  if (bodyType && raw[bodyType].type !== 'BlockStatement') {\n    var expression = raw[bodyType]; // create a synthetic block statement, otherwise all hell\n    // breaks loose when it comes to block scoping\n\n    raw[bodyType] = {\n      start: expression.start,\n      end: expression.end,\n      type: 'BlockStatement',\n      body: [expression],\n      synthetic: true\n    };\n  }\n\n  raw.parent = parent;\n  raw.program = parent.program || parent;\n  raw.depth = parent.depth + 1;\n  raw.keys = keys[raw.type];\n  raw.indentation = undefined;\n\n  for (var i$1 = 0, list = keys[raw.type]; i$1 < list.length; i$1 += 1) {\n    var key = list[i$1];\n    wrap(raw[key], raw);\n  }\n\n  raw.program.magicString.addSourcemapLocation(raw.start);\n  raw.program.magicString.addSourcemapLocation(raw.end);\n  var type = (raw.type === 'BlockStatement' ? BlockStatement : types[raw.type]) || Node;\n  raw.__proto__ = type.prototype;\n}\n\nfunction Program(source, ast, transforms, options) {\n  this.type = 'Root'; // options\n\n  this.jsx = options.jsx || 'React.createElement';\n  this.jsxFragment = options.jsxFragment || 'React.Fragment';\n  this.options = options;\n  this.source = source;\n  this.magicString = new MagicString(source);\n  this.ast = ast;\n  this.depth = 0;\n  wrap(this.body = ast, this);\n  this.body.__proto__ = BlockStatement.prototype;\n  this.templateLiteralQuasis = Object.create(null);\n\n  for (var i = 0; i < this.body.body.length; ++i) {\n    if (!this.body.body[i].directive) {\n      this.prependAt = this.body.body[i].start;\n      break;\n    }\n  }\n\n  this.objectWithoutPropertiesHelper = null;\n  this.indentExclusionElements = [];\n  this.body.initialise(transforms);\n  this.indentExclusions = Object.create(null);\n\n  for (var i$2 = 0, list = this.indentExclusionElements; i$2 < list.length; i$2 += 1) {\n    var node = list[i$2];\n\n    for (var i$1 = node.start; i$1 < node.end; i$1 += 1) {\n      this.indentExclusions[i$1] = true;\n    }\n  }\n\n  this.body.transpile(this.magicString, transforms);\n}\n\nProgram.prototype = {\n  export: function export$1(options) {\n    if (options === void 0) options = {};\n    return {\n      code: this.magicString.toString(),\n      map: this.magicString.generateMap({\n        file: options.file,\n        source: options.source,\n        includeContent: options.includeContent !== false\n      })\n    };\n  },\n  findNearest: function findNearest() {\n    return null;\n  },\n  findScope: function findScope() {\n    return null;\n  },\n  getObjectWithoutPropertiesHelper: function getObjectWithoutPropertiesHelper(code) {\n    if (!this.objectWithoutPropertiesHelper) {\n      this.objectWithoutPropertiesHelper = this.body.scope.createIdentifier('objectWithoutProperties');\n      code.prependLeft(this.prependAt, \"function \" + this.objectWithoutPropertiesHelper + \" (obj, exclude) { \" + \"var target = {}; for (var k in obj) \" + \"if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) \" + \"target[k] = obj[k]; return target; }\\n\");\n    }\n\n    return this.objectWithoutPropertiesHelper;\n  }\n};\nvar matrix = {\n  chrome: {\n    48: 610719,\n    49: 652287,\n    50: 783359,\n    51: 783359,\n    52: 1045503,\n    53: 1045503,\n    54: 1045503,\n    55: 3142655,\n    56: 3142655,\n    57: 3142655,\n    58: 4191231,\n    59: 4191231,\n    60: 8385535,\n    61: 8385535,\n    62: 8385535,\n    63: 8385535,\n    64: 8385535,\n    65: 8385535,\n    66: 8385535,\n    67: 8385535,\n    68: 8385535,\n    69: 8385535,\n    70: 8385535,\n    71: 8385535\n  },\n  firefox: {\n    43: 643515,\n    44: 643515,\n    45: 643519,\n    46: 774591,\n    47: 774655,\n    48: 774655,\n    49: 774655,\n    50: 774655,\n    51: 775167,\n    52: 4191231,\n    53: 4191231,\n    54: 4191231,\n    55: 8385535,\n    56: 8385535,\n    57: 8385535,\n    58: 8385535,\n    59: 8385535,\n    60: 8385535,\n    61: 8385535,\n    62: 8385535,\n    63: 8385535,\n    64: 8385535\n  },\n  safari: {\n    8: 524297,\n    9: 594141,\n    10: 1831935,\n    '10.1': 4191231,\n    11: 4191231,\n    '11.1': 8385535,\n    12: 8385535\n  },\n  ie: {\n    8: 0,\n    9: 524289,\n    10: 524289,\n    11: 524289 // no let/const in for loops\n\n  },\n  edge: {\n    12: 610459,\n    13: 774559,\n    14: 2085887,\n    15: 4183039,\n    16: 4183039,\n    17: 4183039,\n    18: 4183039,\n    19: 4183039\n  },\n  node: {\n    '0.10': 524289,\n    '0.12': 524417,\n    4: 594335,\n    5: 594335,\n    6: 783359,\n    8: 4191231,\n    '8.3': 8385535,\n    '8.7': 8385535,\n    '8.10': 8385535\n  }\n};\nvar features = ['getterSetter', 'arrow', 'classes', 'computedProperty', 'conciseMethodProperty', 'defaultParameter', 'destructuring', 'forOf', 'generator', 'letConst', 'moduleExport', 'moduleImport', 'numericLiteral', 'parameterDestructuring', 'spreadRest', 'stickyRegExp', 'templateString', 'unicodeRegExp', // ES2016\n'exponentiation', // additional transforms, not from\n// https://featuretests.io\n'reservedProperties', 'trailingFunctionCommas', 'asyncAwait', 'objectRestSpread'];\nvar version = \"0.20.0\";\nvar parser = Parser.extend(acornDynamicImport, acornJsx());\nvar dangerousTransforms = ['dangerousTaggedTemplateString', 'dangerousForOf'];\n\nfunction target(target) {\n  var targets = Object.keys(target);\n  var bitmask = targets.length ? 8388607 : 524289;\n  Object.keys(target).forEach(function (environment) {\n    var versions = matrix[environment];\n\n    if (!versions) {\n      throw new Error(\"Unknown environment '\" + environment + \"'. Please raise an issue at https://github.com/bublejs/buble/issues\");\n    }\n\n    var targetVersion = target[environment];\n\n    if (!(targetVersion in versions)) {\n      throw new Error(\"Support data exists for the following versions of \" + environment + \": \" + Object.keys(versions).join(', ') + \". Please raise an issue at https://github.com/bublejs/buble/issues\");\n    }\n\n    var support = versions[targetVersion];\n    bitmask &= support;\n  });\n  var transforms = Object.create(null);\n  features.forEach(function (name, i) {\n    transforms[name] = !(bitmask & 1 << i);\n  });\n  dangerousTransforms.forEach(function (name) {\n    transforms[name] = false;\n  });\n  return transforms;\n}\n\nfunction transform(source, options) {\n  if (options === void 0) options = {};\n  var ast;\n  var jsx = null;\n\n  try {\n    ast = parser.parse(source, {\n      ecmaVersion: 10,\n      preserveParens: true,\n      sourceType: 'module',\n      allowAwaitOutsideFunction: true,\n      allowReturnOutsideFunction: true,\n      allowHashBang: true,\n      onComment: function onComment(block, text) {\n        if (!jsx) {\n          var match = /@jsx\\s+([^\\s]+)/.exec(text);\n\n          if (match) {\n            jsx = match[1];\n          }\n        }\n      }\n    });\n    options.jsx = jsx || options.jsx;\n  } catch (err) {\n    err.snippet = getSnippet(source, err.loc);\n\n    err.toString = function () {\n      return err.name + \": \" + err.message + \"\\n\" + err.snippet;\n    };\n\n    throw err;\n  }\n\n  var transforms = target(options.target || {});\n  Object.keys(options.transforms || {}).forEach(function (name) {\n    if (name === 'modules') {\n      if (!('moduleImport' in options.transforms)) {\n        transforms.moduleImport = options.transforms.modules;\n      }\n\n      if (!('moduleExport' in options.transforms)) {\n        transforms.moduleExport = options.transforms.modules;\n      }\n\n      return;\n    }\n\n    if (!(name in transforms)) {\n      throw new Error(\"Unknown transform '\" + name + \"'\");\n    }\n\n    transforms[name] = options.transforms[name];\n  });\n\n  if (options.objectAssign === true) {\n    options.objectAssign = 'Object.assign';\n  }\n\n  return new Program(source, ast, transforms, options).export(options);\n}\n\nexport { version as VERSION, target, transform };","map":{"version":3,"sources":["../src/program/Node.js","../src/program/extractNames.js","../src/utils/reserved.js","../src/program/Scope.js","../src/utils/locate.js","../src/utils/getSnippet.js","../src/utils/CompileError.js","../src/utils/array.js","../src/utils/destructure.js","../src/program/BlockStatement.js","../src/utils/spread.js","../src/program/types/ArrayExpression.js","../src/utils/removeTrailingComma.js","../src/program/types/ArrowFunctionExpression.js","../src/utils/checkConst.js","../src/program/types/AssignmentExpression.js","../src/program/types/AwaitExpression.js","../src/program/types/BinaryExpression.js","../src/utils/patterns.js","../src/program/types/BreakStatement.js","../src/program/types/CallExpression.js","../src/program/types/CatchClause.js","../src/program/types/ClassBody.js","../src/utils/deindent.js","../src/program/types/ClassDeclaration.js","../src/program/types/ClassExpression.js","../src/program/types/ContinueStatement.js","../src/program/types/ExportDefaultDeclaration.js","../src/program/types/ExportNamedDeclaration.js","../src/program/types/shared/LoopStatement.js","../src/program/types/ForStatement.js","../src/program/types/ForInStatement.js","../src/program/types/ForOfStatement.js","../src/program/types/FunctionDeclaration.js","../src/program/types/FunctionExpression.js","../src/utils/isReference.js","../src/program/types/Identifier.js","../src/program/types/IfStatement.js","../src/program/types/Import.js","../src/program/types/ImportDeclaration.js","../src/program/types/ImportDefaultSpecifier.js","../src/program/types/ImportSpecifier.js","../src/program/types/JSXAttribute.js","../src/program/types/JSXClosingElement.js","../src/program/types/JSXClosingFragment.js","../src/program/types/JSXElement.js","../src/program/types/JSXExpressionContainer.js","../src/program/types/JSXFragment.js","../src/program/types/JSXOpeningElement.js","../src/program/types/JSXOpeningFragment.js","../src/program/types/JSXSpreadAttribute.js","../src/program/types/Literal.js","../src/program/types/MemberExpression.js","../src/program/types/NewExpression.js","../src/program/types/ObjectExpression.js","../src/program/types/Property.js","../src/program/types/ReturnStatement.js","../src/program/types/Super.js","../src/program/types/TaggedTemplateExpression.js","../src/program/types/TemplateElement.js","../src/program/types/TemplateLiteral.js","../src/program/types/ThisExpression.js","../src/program/types/UpdateExpression.js","../src/program/types/VariableDeclaration.js","../src/program/types/VariableDeclarator.js","../src/program/types/index.js","../src/program/keys.js","../src/program/wrap.js","../src/program/Program.js","../src/support.js","../src/index.js"],"names":["const","let","super","this","ref","start","alias","identifier","element","fn","containsNewLine","i","prop","propId","c","parenthesise","0b00010010101000110011111","0b00010011111001111111111","0b00010111111001111111111","0b00011111111001111111111","0b01011111111001111111111","0b01111111111001111111111","0b11111111111001111111111","0b00010011101000110111011","0b00010011101000110111111","0b00010111101000110111111","0b00010111101000111111111","0b00010111101001111111111","0b00010000000000000001001","0b00010010001000011011101","0b00110111111001111111111","0b00000000000000000000000","0b00010000000000000000001","0b00010010101000010011011","0b00010111101000110011111","0b00111111101001111111111","0b01111111101001111111111","0b00010000000000010000001","0b00010010001000110011111","0b11111111111111111111111"],"mappings":"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","sourcesContent":["// used for debugging, without the noise created by\n// circular references\nfunction toJSON(node) {\n\tconst obj = {};\n\n\tObject.keys(node).forEach(key => {\n\t\tif (\n\t\t\tkey === 'parent' ||\n\t\t\tkey === 'program' ||\n\t\t\tkey === 'keys' ||\n\t\t\tkey === '__wrapped'\n\t\t)\n\t\t\treturn;\n\n\t\tif (Array.isArray(node[key])) {\n\t\t\tobj[key] = node[key].map(toJSON);\n\t\t} else if (node[key] && node[key].toJSON) {\n\t\t\tobj[key] = node[key].toJSON();\n\t\t} else {\n\t\t\tobj[key] = node[key];\n\t\t}\n\t});\n\n\treturn obj;\n}\n\nexport default class Node {\n\tancestor(level) {\n\t\tlet node = this;\n\t\twhile (level--) {\n\t\t\tnode = node.parent;\n\t\t\tif (!node) return null;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tcontains(node) {\n\t\twhile (node) {\n\t\t\tif (node === this) return true;\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfindLexicalBoundary() {\n\t\treturn this.parent.findLexicalBoundary();\n\t}\n\n\tfindNearest(type) {\n\t\tif (typeof type === 'string') type = new RegExp(`^${type}$`);\n\t\tif (type.test(this.type)) return this;\n\t\treturn this.parent.findNearest(type);\n\t}\n\n\tunparenthesizedParent() {\n\t\tlet node = this.parent;\n\t\twhile (node && node.type === 'ParenthesizedExpression') {\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn node;\n\t}\n\n\tunparenthesize() {\n\t\tlet node = this;\n\t\twhile (node.type === 'ParenthesizedExpression') {\n\t\t\tnode = node.expression;\n\t\t}\n\t\treturn node;\n\t}\n\n\tfindScope(functionScope) {\n\t\treturn this.parent.findScope(functionScope);\n\t}\n\n\tgetIndentation() {\n\t\treturn this.parent.getIndentation();\n\t}\n\n\tinitialise(transforms) {\n\t\tfor (const key of this.keys) {\n\t\t\tconst value = this[key];\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach(node => node && node.initialise(transforms));\n\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\tvalue.initialise(transforms);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoJSON() {\n\t\treturn toJSON(this);\n\t}\n\n\ttoString() {\n\t\treturn this.program.magicString.original.slice(this.start, this.end);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tfor (const key of this.keys) {\n\t\t\tconst value = this[key];\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach(node => node && node.transpile(code, transforms));\n\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\tvalue.transpile(code, transforms);\n\t\t\t}\n\t\t}\n\t}\n}\n","export default function extractNames(node) {\n\tconst names = [];\n\textractors[node.type](names, node);\n\treturn names;\n}\n\nconst extractors = {\n\tIdentifier(names, node) {\n\t\tnames.push(node);\n\t},\n\n\tObjectPattern(names, node) {\n\t\tfor (const prop of node.properties) {\n\t\t\textractors[prop.type](names, prop);\n\t\t}\n\t},\n\n\tProperty(names, node) {\n\t\textractors[node.value.type](names, node.value);\n\t},\n\n\tArrayPattern(names, node) {\n\t\tfor (const element of node.elements) {\n\t\t\tif (element) extractors[element.type](names, element);\n\t\t}\n\t},\n\n\tRestElement(names, node) {\n\t\textractors[node.argument.type](names, node.argument);\n\t},\n\n\tAssignmentPattern(names, node) {\n\t\textractors[node.left.type](names, node.left);\n\t}\n};\n","const reserved = Object.create(null);\n'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'\n\t.split(' ')\n\t.forEach(word => (reserved[word] = true));\n\nexport default reserved;\n","import extractNames from './extractNames.js';\nimport reserved from '../utils/reserved.js';\n\nexport default function Scope(options) {\n\toptions = options || {};\n\n\tthis.parent = options.parent;\n\tthis.isBlockScope = !!options.block;\n\tthis.createDeclarationCallback = options.declare;\n\n\tlet scope = this;\n\twhile (scope.isBlockScope) scope = scope.parent;\n\tthis.functionScope = scope;\n\n\tthis.identifiers = [];\n\tthis.declarations = Object.create(null);\n\tthis.references = Object.create(null);\n\tthis.blockScopedDeclarations = this.isBlockScope ? null : Object.create(null);\n\tthis.aliases = Object.create(null);\n}\n\nScope.prototype = {\n\taddDeclaration(node, kind) {\n\t\tfor (const identifier of extractNames(node)) {\n\t\t\tconst name = identifier.name;\n\n\t\t\tconst declaration = { name, node: identifier, kind, instances: [] };\n\t\t\tthis.declarations[name] = declaration;\n\n\t\t\tif (this.isBlockScope) {\n\t\t\t\tif (!this.functionScope.blockScopedDeclarations[name])\n\t\t\t\t\tthis.functionScope.blockScopedDeclarations[name] = [];\n\t\t\t\tthis.functionScope.blockScopedDeclarations[name].push(declaration);\n\t\t\t}\n\t\t}\n\t},\n\n\taddReference(identifier) {\n\t\tif (this.consolidated) {\n\t\t\tthis.consolidateReference(identifier);\n\t\t} else {\n\t\t\tthis.identifiers.push(identifier);\n\t\t}\n\t},\n\n\tconsolidate() {\n\t\tfor (let i = 0; i < this.identifiers.length; i += 1) {\n\t\t\t// we might push to the array during consolidation, so don't cache length\n\t\t\tconst identifier = this.identifiers[i];\n\t\t\tthis.consolidateReference(identifier);\n\t\t}\n\n\t\tthis.consolidated = true; // TODO understand why this is necessary... seems bad\n\t},\n\n\tconsolidateReference(identifier) {\n\t\tconst declaration = this.declarations[identifier.name];\n\t\tif (declaration) {\n\t\t\tdeclaration.instances.push(identifier);\n\t\t} else {\n\t\t\tthis.references[identifier.name] = true;\n\t\t\tif (this.parent) this.parent.addReference(identifier);\n\t\t}\n\t},\n\n\tcontains(name) {\n\t\treturn (\n\t\t\tthis.declarations[name] ||\n\t\t\t(this.parent ? this.parent.contains(name) : false)\n\t\t);\n\t},\n\n\tcreateIdentifier(base) {\n\t\tif (typeof base === 'number') base = base.toString();\n\n\t\tbase = base\n\t\t\t.replace(/\\s/g, '')\n\t\t\t.replace(/\\[([^\\]]+)\\]/g, '_$1')\n\t\t\t.replace(/[^a-zA-Z0-9_$]/g, '_')\n\t\t\t.replace(/_{2,}/, '_');\n\n\t\tlet name = base;\n\t\tlet counter = 1;\n\n\t\twhile (\n\t\t\tthis.declarations[name] ||\n\t\t\tthis.references[name] ||\n\t\t\tthis.aliases[name] ||\n\t\t\tname in reserved\n\t\t) {\n\t\t\tname = `${base}$${counter++}`;\n\t\t}\n\n\t\tthis.aliases[name] = true;\n\t\treturn name;\n\t},\n\n\tcreateDeclaration(base) {\n\t\tconst id = this.createIdentifier(base);\n\t\tthis.createDeclarationCallback(id);\n\t\treturn id;\n\t},\n\n\tfindDeclaration(name) {\n\t\treturn (\n\t\t\tthis.declarations[name] ||\n\t\t\t(this.parent && this.parent.findDeclaration(name))\n\t\t);\n\t},\n\n\t// Sometimes, block scope declarations change name during transpilation\n\tresolveName(name) {\n\t\tconst declaration = this.findDeclaration(name);\n\t\treturn declaration ? declaration.name : name;\n\t}\n};\n","export default function locate(source, index) {\n\tconst lines = source.split('\\n');\n\tconst len = lines.length;\n\n\tlet lineStart = 0;\n\tlet i;\n\n\tfor (i = 0; i < len; i += 1) {\n\t\tconst line = lines[i];\n\t\tconst lineEnd = lineStart + line.length + 1; // +1 for newline\n\n\t\tif (lineEnd > index) {\n\t\t\treturn { line: i + 1, column: index - lineStart, char: i };\n\t\t}\n\n\t\tlineStart = lineEnd;\n\t}\n\n\tthrow new Error('Could not determine location of character');\n}\n","function pad(num, len) {\n\tconst result = String(num);\n\treturn result + repeat(' ', len - result.length);\n}\n\nfunction repeat(str, times) {\n\tlet result = '';\n\twhile (times--) result += str;\n\treturn result;\n}\n\nexport default function getSnippet(source, loc, length = 1) {\n\tconst first = Math.max(loc.line - 5, 0);\n\tconst last = loc.line;\n\n\tconst numDigits = String(last).length;\n\n\tconst lines = source.split('\\n').slice(first, last);\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst offset = lastLine.slice(0, loc.column).replace(/\\t/g, '  ').length;\n\n\tlet snippet = lines\n\t\t.map((line, i) => `${pad(i + first + 1, numDigits)} : ${line.replace(/\\t/g, '  ')}`)\n\t\t.join('\\n');\n\n\tsnippet += '\\n' + repeat(' ', numDigits + 3 + offset) + repeat('^', length);\n\n\treturn snippet;\n}\n","import locate from './locate.js';\nimport getSnippet from './getSnippet.js';\n\nexport default class CompileError extends Error {\n\tconstructor(message, node) {\n\t\tsuper(message);\n\n\t\tthis.name = 'CompileError';\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst source = node.program.magicString.original;\n\t\tconst loc = locate(source, node.start);\n\n\t\tthis.message = message + ` (${loc.line}:${loc.column})`;\n\n\t\tthis.stack = new Error().stack.replace(\n\t\t\tnew RegExp(`.+new ${this.name}.+\\\\n`, 'm'),\n\t\t\t''\n\t\t);\n\n\t\tthis.loc = loc;\n\t\tthis.snippet = getSnippet(source, loc, node.end - node.start);\n\t}\n\n\ttoString() {\n\t\treturn `${this.name}: ${this.message}\\n${this.snippet}`;\n\t}\n\n\tstatic missingTransform(feature, transformKey, node, dangerousKey = null) {\n\t\tconst maybeDangerous = dangerousKey ? `, or \\`transforms: { ${dangerousKey}: true }\\` if you know what you're doing` : '';\n\t\tthrow new CompileError(`Transforming ${feature} is not ${dangerousKey ? \"fully supported\" : \"implemented\"}. Use \\`transforms: { ${transformKey}: false }\\` to skip transformation and disable this error${maybeDangerous}.`, node);\n\t}\n}\n","export function findIndex(array, fn) {\n\tfor (let i = 0; i < array.length; i += 1) {\n\t\tif (fn(array[i], i)) return i;\n\t}\n\n\treturn -1;\n}\n\nexport function find(array, fn) {\n\treturn array[findIndex(array, fn)];\n}\n","import CompileError from '../utils/CompileError.js';\nimport { findIndex } from './array.js';\n\nconst handlers = {\n\tIdentifier: destructureIdentifier,\n\tAssignmentPattern: destructureAssignmentPattern,\n\tArrayPattern: destructureArrayPattern,\n\tObjectPattern: destructureObjectPattern\n};\n\nexport default function destructure(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tnode,\n\tref,\n\tinline,\n\tstatementGenerators\n) {\n\thandlers[node.type](code, createIdentifier, resolveName, node, ref, inline, statementGenerators);\n}\n\nfunction destructureIdentifier(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tnode,\n\tref,\n\tinline,\n\tstatementGenerators\n) {\n\tstatementGenerators.push((start, prefix, suffix) => {\n\t\tcode.overwrite(node.start, node.end, (inline ? prefix : `${prefix}var `) + resolveName(node) + ` = ${ref}${suffix}`);\n\t\tcode.move(node.start, node.end, start);\n\t});\n}\n\nfunction destructureMemberExpression(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tnode,\n\tref,\n\tinline,\n\tstatementGenerators\n) {\n\tstatementGenerators.push((start, prefix, suffix) => {\n\t\tcode.prependRight(node.start, inline ? prefix : `${prefix}var `);\n\t\tcode.appendLeft(node.end, ` = ${ref}${suffix}`);\n\t\tcode.move(node.start, node.end, start);\n\t});\n}\n\nfunction destructureAssignmentPattern(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tnode,\n\tref,\n\tinline,\n\tstatementGenerators\n) {\n\tconst isIdentifier = node.left.type === 'Identifier';\n\tconst name = isIdentifier ? node.left.name : ref;\n\n\tif (!inline) {\n\t\tstatementGenerators.push((start, prefix, suffix) => {\n\t\t\tcode.prependRight(\n\t\t\t\tnode.left.end,\n\t\t\t\t`${prefix}if ( ${name} === void 0 ) ${name}`\n\t\t\t);\n\t\t\tcode.move(node.left.end, node.right.end, start);\n\t\t\tcode.appendLeft(node.right.end, suffix);\n\t\t});\n\t}\n\n\tif (!isIdentifier) {\n\t\tdestructure(code, createIdentifier, resolveName, node.left, ref, inline, statementGenerators);\n\t}\n}\n\nfunction destructureArrayPattern(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tnode,\n\tref,\n\tinline,\n\tstatementGenerators\n) {\n\tlet c = node.start;\n\n\tnode.elements.forEach((element, i) => {\n\t\tif (!element) return;\n\n\t\tif (element.type === 'RestElement') {\n\t\t\thandleProperty(\n\t\t\t\tcode,\n\t\t\t\tcreateIdentifier,\n\t\t\t\tresolveName,\n\t\t\t\tc,\n\t\t\t\telement.argument,\n\t\t\t\t`${ref}.slice(${i})`,\n\t\t\t\tinline,\n\t\t\t\tstatementGenerators\n\t\t\t);\n\t\t} else {\n\t\t\thandleProperty(\n\t\t\t\tcode,\n\t\t\t\tcreateIdentifier,\n\t\t\t\tresolveName,\n\t\t\t\tc,\n\t\t\t\telement,\n\t\t\t\t`${ref}[${i}]`,\n\t\t\t\tinline,\n\t\t\t\tstatementGenerators\n\t\t\t);\n\t\t}\n\t\tc = element.end;\n\t});\n\n\tcode.remove(c, node.end);\n}\n\nfunction destructureObjectPattern(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tnode,\n\tref,\n\tinline,\n\tstatementGenerators\n) {\n\tlet c = node.start;\n\n\tconst nonRestKeys = [];\n\tnode.properties.forEach(prop => {\n\t\tlet value;\n\t\tlet content;\n\t\tif (prop.type === 'Property') {\n\t\t\tcontent = prop.value;\n\t\t\tif (!prop.computed && prop.key.type === 'Identifier') {\n\t\t\t\tvalue = `${ref}.${prop.key.name}`;\n\t\t\t\tnonRestKeys.push(`\"${prop.key.name}\"`);\n\t\t\t} else if (!prop.computed && prop.key.type === 'Literal') {\n\t\t\t\tvalue = `${ref}[${prop.key.raw}]`;\n\t\t\t\tnonRestKeys.push(JSON.stringify(String(prop.key.value)));\n\t\t\t} else {\n\t\t\t\tconst expr = code.slice(prop.key.start, prop.key.end);\n\t\t\t\tvalue = `${ref}[${expr}]`;\n\t\t\t\tnonRestKeys.push(`String(${expr})`);\n\t\t\t}\n\t\t} else if (prop.type === 'RestElement') {\n\t\t\tcontent = prop.argument;\n\t\t\tvalue = createIdentifier('rest');\n\t\t\tstatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\tconst helper = prop.program.getObjectWithoutPropertiesHelper(code);\n\t\t\t\tcode.overwrite(\n\t\t\t\t\tprop.start,\n\t\t\t\t\t(c = prop.argument.start),\n\t\t\t\t\t(inline ? prefix : `${prefix}var `) + `${value} = ${helper}( ${ref}, [${nonRestKeys.join(', ')}] )${suffix}`\n\t\t\t\t);\n\t\t\t\tcode.move(prop.start, c, start);\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new CompileError(\n\t\t\t\tthis,\n\t\t\t\t`Unexpected node of type ${prop.type} in object pattern`\n\t\t\t);\n\t\t}\n\t\thandleProperty(code, createIdentifier, resolveName, c, content, value, inline, statementGenerators);\n\t\tc = prop.end;\n\t});\n\n\tcode.remove(c, node.end);\n}\n\nfunction handleProperty(\n\tcode,\n\tcreateIdentifier,\n\tresolveName,\n\tc,\n\tnode,\n\tvalue,\n\tinline,\n\tstatementGenerators\n) {\n\tswitch (node.type) {\n\t\tcase 'Identifier': {\n\t\t\tcode.remove(c, node.start);\n\t\t\tdestructureIdentifier(\n\t\t\t\tcode,\n\t\t\t\tcreateIdentifier,\n\t\t\t\tresolveName,\n\t\t\t\tnode,\n\t\t\t\tvalue,\n\t\t\t\tinline,\n\t\t\t\tstatementGenerators\n\t\t\t);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'MemberExpression':\n\t\t\tcode.remove(c, node.start);\n\t\t\tdestructureMemberExpression(\n\t\t\t\tcode,\n\t\t\t\tcreateIdentifier,\n\t\t\t\tresolveName,\n\t\t\t\tnode,\n\t\t\t\tvalue,\n\t\t\t\ttrue,\n\t\t\t\tstatementGenerators\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase 'AssignmentPattern': {\n\t\t\tlet name;\n\n\t\t\tconst isIdentifier = node.left.type === 'Identifier';\n\n\t\t\tif (isIdentifier) {\n\t\t\t\tname = resolveName(node.left);\n\t\t\t} else {\n\t\t\t\tname = createIdentifier(value);\n\t\t\t}\n\n\t\t\tstatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\tif (inline) {\n\t\t\t\t\tcode.prependRight(\n\t\t\t\t\t\tnode.right.start,\n\t\t\t\t\t\t`${name} = ${value}, ${name} = ${name} === void 0 ? `\n\t\t\t\t\t);\n\t\t\t\t\tcode.appendLeft(node.right.end, ` : ${name}${suffix}`);\n\t\t\t\t} else {\n\t\t\t\t\tcode.prependRight(\n\t\t\t\t\t\tnode.right.start,\n\t\t\t\t\t\t`${prefix}var ${name} = ${value}; if ( ${name} === void 0 ) ${name} = `\n\t\t\t\t\t);\n\t\t\t\t\tcode.appendLeft(node.right.end, suffix);\n\t\t\t\t}\n\n\t\t\t\tcode.move(node.right.start, node.right.end, start);\n\t\t\t});\n\n\t\t\tif (isIdentifier) {\n\t\t\t\tcode.remove(c, node.right.start);\n\t\t\t} else {\n\t\t\t\tcode.remove(c, node.left.start);\n\t\t\t\tcode.remove(node.left.end, node.right.start);\n\t\t\t\thandleProperty(\n\t\t\t\t\tcode,\n\t\t\t\t\tcreateIdentifier,\n\t\t\t\t\tresolveName,\n\t\t\t\t\tc,\n\t\t\t\t\tnode.left,\n\t\t\t\t\tname,\n\t\t\t\t\tinline,\n\t\t\t\t\tstatementGenerators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'ObjectPattern': {\n\t\t\tcode.remove(c, (c = node.start));\n\n\t\t\tlet ref = value;\n\t\t\tif (node.properties.length > 1) {\n\t\t\t\tref = createIdentifier(value);\n\n\t\t\t\tstatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\t\t// this feels a tiny bit hacky, but we can't do a\n\t\t\t\t\t// straightforward appendLeft and keep correct order...\n\t\t\t\t\tcode.prependRight(node.start, (inline ? '' : `${prefix}var `) + `${ref} = `);\n\t\t\t\t\tcode.overwrite(node.start, (c = node.start + 1), value);\n\t\t\t\t\tcode.appendLeft(c, suffix);\n\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tnode.start,\n\t\t\t\t\t\t(c = node.start + 1),\n\t\t\t\t\t\t(inline ? '' : `${prefix}var `) + `${ref} = ${value}${suffix}`\n\t\t\t\t\t);\n\t\t\t\t\tcode.move(node.start, c, start);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tdestructureObjectPattern(\n\t\t\t\tcode,\n\t\t\t\tcreateIdentifier,\n\t\t\t\tresolveName,\n\t\t\t\tnode,\n\t\t\t\tref,\n\t\t\t\tinline,\n\t\t\t\tstatementGenerators\n\t\t\t);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'ArrayPattern': {\n\t\t\tcode.remove(c, (c = node.start));\n\n\t\t\tif (node.elements.filter(Boolean).length > 1) {\n\t\t\t\tconst ref = createIdentifier(value);\n\n\t\t\t\tstatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\t\tcode.prependRight(node.start, (inline ? '' : `${prefix}var `) + `${ref} = `);\n\t\t\t\t\tcode.overwrite(node.start, (c = node.start + 1), value, {\n\t\t\t\t\t\tcontentOnly: true\n\t\t\t\t\t});\n\t\t\t\t\tcode.appendLeft(c, suffix);\n\n\t\t\t\t\tcode.move(node.start, c, start);\n\t\t\t\t});\n\n\t\t\t\tnode.elements.forEach((element, i) => {\n\t\t\t\t\tif (!element) return;\n\n\t\t\t\t\tif (element.type === 'RestElement') {\n\t\t\t\t\t\thandleProperty(\n\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\tcreateIdentifier,\n\t\t\t\t\t\t\tresolveName,\n\t\t\t\t\t\t\tc,\n\t\t\t\t\t\t\telement.argument,\n\t\t\t\t\t\t\t`${ref}.slice(${i})`,\n\t\t\t\t\t\t\tinline,\n\t\t\t\t\t\t\tstatementGenerators\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleProperty(\n\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\tcreateIdentifier,\n\t\t\t\t\t\t\tresolveName,\n\t\t\t\t\t\t\tc,\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\t`${ref}[${i}]`,\n\t\t\t\t\t\t\tinline,\n\t\t\t\t\t\t\tstatementGenerators\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tc = element.end;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst index = findIndex(node.elements, Boolean);\n\t\t\t\tconst element = node.elements[index];\n\t\t\t\tif (element.type === 'RestElement') {\n\t\t\t\t\thandleProperty(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tcreateIdentifier,\n\t\t\t\t\t\tresolveName,\n\t\t\t\t\t\tc,\n\t\t\t\t\t\telement.argument,\n\t\t\t\t\t\t`${value}.slice(${index})`,\n\t\t\t\t\t\tinline,\n\t\t\t\t\t\tstatementGenerators\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\thandleProperty(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tcreateIdentifier,\n\t\t\t\t\t\tresolveName,\n\t\t\t\t\t\tc,\n\t\t\t\t\t\telement,\n\t\t\t\t\t\t`${value}[${index}]`,\n\t\t\t\t\t\tinline,\n\t\t\t\t\t\tstatementGenerators\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tc = element.end;\n\t\t\t}\n\n\t\t\tcode.remove(c, node.end);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault: {\n\t\t\tthrow new Error(`Unexpected node type in destructuring (${node.type})`);\n\t\t}\n\t}\n}\n","import Node from './Node.js';\nimport Scope from './Scope.js';\nimport destructure from '../utils/destructure.js';\n\nfunction isUseStrict(node) {\n\tif (!node) return false;\n\tif (node.type !== 'ExpressionStatement') return false;\n\tif (node.expression.type !== 'Literal') return false;\n\treturn node.expression.value === 'use strict';\n}\n\nexport default class BlockStatement extends Node {\n\tcreateScope() {\n\t\tthis.parentIsFunction = /Function/.test(this.parent.type);\n\t\tthis.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';\n\t\tthis.scope = new Scope({\n\t\t\tblock: !this.isFunctionBlock,\n\t\t\tparent: this.parent.findScope(false),\n\t\t\tdeclare: id => this.createdDeclarations.push(id)\n\t\t});\n\n\t\tif (this.parentIsFunction) {\n\t\t\tthis.parent.params.forEach(node => {\n\t\t\t\tthis.scope.addDeclaration(node, 'param');\n\t\t\t});\n\t\t}\n\t}\n\n\tinitialise(transforms) {\n\t\tthis.thisAlias = null;\n\t\tthis.argumentsAlias = null;\n\t\tthis.defaultParameters = [];\n\t\tthis.createdDeclarations = [];\n\n\t\t// normally the scope gets created here, during initialisation,\n\t\t// but in some cases (e.g. `for` statements), we need to create\n\t\t// the scope early, as it pertains to both the init block and\n\t\t// the body of the statement\n\t\tif (!this.scope) this.createScope();\n\n\t\tthis.body.forEach(node => node.initialise(transforms));\n\n\t\tthis.scope.consolidate();\n\t}\n\n\tfindLexicalBoundary() {\n\t\tif (this.type === 'Program') return this;\n\t\tif (/^Function/.test(this.parent.type)) return this;\n\n\t\treturn this.parent.findLexicalBoundary();\n\t}\n\n\tfindScope(functionScope) {\n\t\tif (functionScope && !this.isFunctionBlock)\n\t\t\treturn this.parent.findScope(functionScope);\n\t\treturn this.scope;\n\t}\n\n\tgetArgumentsAlias() {\n\t\tif (!this.argumentsAlias) {\n\t\t\tthis.argumentsAlias = this.scope.createIdentifier('arguments');\n\t\t}\n\n\t\treturn this.argumentsAlias;\n\t}\n\n\tgetArgumentsArrayAlias() {\n\t\tif (!this.argumentsArrayAlias) {\n\t\t\tthis.argumentsArrayAlias = this.scope.createIdentifier('argsArray');\n\t\t}\n\n\t\treturn this.argumentsArrayAlias;\n\t}\n\n\tgetThisAlias() {\n\t\tif (!this.thisAlias) {\n\t\t\tthis.thisAlias = this.scope.createIdentifier('this');\n\t\t}\n\n\t\treturn this.thisAlias;\n\t}\n\n\tgetIndentation() {\n\t\tif (this.indentation === undefined) {\n\t\t\tconst source = this.program.magicString.original;\n\n\t\t\tconst useOuter = this.synthetic || !this.body.length;\n\t\t\tlet c = useOuter ? this.start : this.body[0].start;\n\n\t\t\twhile (c && source[c] !== '\\n') c -= 1;\n\n\t\t\tthis.indentation = '';\n\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\twhile (true) {\n\t\t\t\tc += 1;\n\t\t\t\tconst char = source[c];\n\n\t\t\t\tif (char !== ' ' && char !== '\\t') break;\n\n\t\t\t\tthis.indentation += char;\n\t\t\t}\n\n\t\t\tconst indentString = this.program.magicString.getIndentString();\n\n\t\t\t// account for dedented class constructors\n\t\t\tlet parent = this.parent;\n\t\t\twhile (parent) {\n\t\t\t\tif (parent.kind === 'constructor' && !parent.parent.parent.superClass) {\n\t\t\t\t\tthis.indentation = this.indentation.replace(indentString, '');\n\t\t\t\t}\n\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\n\t\t\tif (useOuter) this.indentation += indentString;\n\t\t}\n\n\t\treturn this.indentation;\n\t}\n\n\ttranspile(code, transforms) {\n\t\tconst indentation = this.getIndentation();\n\n\t\tconst introStatementGenerators = [];\n\n\t\tif (this.argumentsAlias) {\n\t\t\tintroStatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\tconst assignment = `${prefix}var ${this.argumentsAlias} = arguments${\n\t\t\t\t\tsuffix\n\t\t\t\t}`;\n\t\t\t\tcode.appendLeft(start, assignment);\n\t\t\t});\n\t\t}\n\n\t\tif (this.thisAlias) {\n\t\t\tintroStatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\tconst assignment = `${prefix}var ${this.thisAlias} = this${suffix}`;\n\t\t\t\tcode.appendLeft(start, assignment);\n\t\t\t});\n\t\t}\n\n\t\tif (this.argumentsArrayAlias) {\n\t\t\tintroStatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\tconst i = this.scope.createIdentifier('i');\n\t\t\t\tconst assignment = `${prefix}var ${i} = arguments.length, ${\n\t\t\t\t\tthis.argumentsArrayAlias\n\t\t\t\t} = Array(${i});\\n${indentation}while ( ${i}-- ) ${\n\t\t\t\t\tthis.argumentsArrayAlias\n\t\t\t\t}[${i}] = arguments[${i}]${suffix}`;\n\t\t\t\tcode.appendLeft(start, assignment);\n\t\t\t});\n\t\t}\n\n\t\tif (/Function/.test(this.parent.type)) {\n\t\t\tthis.transpileParameters(\n\t\t\t\tthis.parent.params,\n\t\t\t\tcode,\n\t\t\t\ttransforms,\n\t\t\t\tindentation,\n\t\t\t\tintroStatementGenerators\n\t\t\t);\n\t\t} else if ('CatchClause' === this.parent.type) {\n\t\t\tthis.transpileParameters(\n\t\t\t\t[this.parent.param],\n\t\t\t\tcode,\n\t\t\t\ttransforms,\n\t\t\t\tindentation,\n\t\t\t\tintroStatementGenerators\n\t\t\t);\n\t\t}\n\n\t\tif (transforms.letConst && this.isFunctionBlock) {\n\t\t\tthis.transpileBlockScopedIdentifiers(code);\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\n\t\tif (this.createdDeclarations.length) {\n\t\t\tintroStatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\tconst assignment = `${prefix}var ${this.createdDeclarations.join(', ')}${suffix}`;\n\t\t\t\tcode.appendLeft(start, assignment);\n\t\t\t});\n\t\t}\n\n\t\tif (this.synthetic) {\n\t\t\tif (this.parent.type === 'ArrowFunctionExpression') {\n\t\t\t\tconst expr = this.body[0];\n\n\t\t\t\tif (introStatementGenerators.length) {\n\t\t\t\t\tcode\n\t\t\t\t\t\t.appendLeft(this.start, `{`)\n\t\t\t\t\t\t.prependRight(this.end, `${this.parent.getIndentation()}}`);\n\n\t\t\t\t\tcode.prependRight(expr.start, `\\n${indentation}return `);\n\t\t\t\t\tcode.appendLeft(expr.end, `;\\n`);\n\t\t\t\t} else if (transforms.arrow) {\n\t\t\t\t\tcode.prependRight(expr.start, `{ return `);\n\t\t\t\t\tcode.appendLeft(expr.end, `; }`);\n\t\t\t\t}\n\t\t\t} else if (introStatementGenerators.length) {\n\t\t\t\tcode.prependRight(this.start, `{`).appendLeft(this.end, `}`);\n\t\t\t}\n\t\t}\n\n\t\tlet start;\n\t\tif (isUseStrict(this.body[0])) {\n\t\t\tstart = this.body[0].end;\n\t\t} else if (this.synthetic || this.parent.type === 'Root') {\n\t\t\tstart = this.start;\n\t\t} else {\n\t\t\tstart = this.start + 1;\n\t\t}\n\n\t\tconst prefix = `\\n${indentation}`;\n\t\tlet suffix = ';';\n\t\tintroStatementGenerators.forEach((fn, i) => {\n\t\t\tif (i === introStatementGenerators.length - 1) suffix = `;\\n`;\n\t\t\tfn(start, prefix, suffix);\n\t\t});\n\t}\n\n\ttranspileParameters(params, code, transforms, indentation, introStatementGenerators) {\n\t\tparams.forEach(param => {\n\t\t\tif (\n\t\t\t\tparam.type === 'AssignmentPattern' &&\n\t\t\t\tparam.left.type === 'Identifier'\n\t\t\t) {\n\t\t\t\tif (transforms.defaultParameter) {\n\t\t\t\t\tintroStatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\t\t\tconst lhs = `${prefix}if ( ${param.left.name} === void 0 ) ${\n\t\t\t\t\t\t\tparam.left.name\n\t\t\t\t\t\t}`;\n\n\t\t\t\t\t\tcode\n\t\t\t\t\t\t\t.prependRight(param.left.end, lhs)\n\t\t\t\t\t\t\t.move(param.left.end, param.right.end, start)\n\t\t\t\t\t\t\t.appendLeft(param.right.end, suffix);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (param.type === 'RestElement') {\n\t\t\t\tif (transforms.spreadRest) {\n\t\t\t\t\tintroStatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\t\t\tconst penultimateParam = params[params.length - 2];\n\n\t\t\t\t\t\tif (penultimateParam) {\n\t\t\t\t\t\t\tcode.remove(\n\t\t\t\t\t\t\t\tpenultimateParam ? penultimateParam.end : param.start,\n\t\t\t\t\t\t\t\tparam.end\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet start = param.start,\n\t\t\t\t\t\t\t\tend = param.end; // TODO https://gitlab.com/Rich-Harris/buble/issues/8\n\n\t\t\t\t\t\t\twhile (/\\s/.test(code.original[start - 1])) start -= 1;\n\t\t\t\t\t\t\twhile (/\\s/.test(code.original[end])) end += 1;\n\n\t\t\t\t\t\t\tcode.remove(start, end);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst name = param.argument.name;\n\t\t\t\t\t\tconst len = this.scope.createIdentifier('len');\n\t\t\t\t\t\tconst count = params.length - 1;\n\n\t\t\t\t\t\tif (count) {\n\t\t\t\t\t\t\tcode.prependRight(\n\t\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t\t`${prefix}var ${name} = [], ${len} = arguments.length - ${\n\t\t\t\t\t\t\t\t\tcount\n\t\t\t\t\t\t\t\t};\\n${indentation}while ( ${len}-- > 0 ) ${name}[ ${\n\t\t\t\t\t\t\t\t\tlen\n\t\t\t\t\t\t\t\t} ] = arguments[ ${len} + ${count} ]${suffix}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode.prependRight(\n\t\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t\t`${prefix}var ${name} = [], ${len} = arguments.length;\\n${\n\t\t\t\t\t\t\t\t\tindentation\n\t\t\t\t\t\t\t\t}while ( ${len}-- ) ${name}[ ${len} ] = arguments[ ${len} ]${\n\t\t\t\t\t\t\t\t\tsuffix\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (param.type !== 'Identifier') {\n\t\t\t\tif (transforms.parameterDestructuring) {\n\t\t\t\t\tconst ref = this.scope.createIdentifier('ref');\n\t\t\t\t\tdestructure(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tid => this.scope.createIdentifier(id),\n\t\t\t\t\t\t({ name }) => this.scope.resolveName(name),\n\t\t\t\t\t\tparam,\n\t\t\t\t\t\tref,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tintroStatementGenerators\n\t\t\t\t\t);\n\t\t\t\t\tcode.prependRight(param.start, ref);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\ttranspileBlockScopedIdentifiers(code) {\n\t\tObject.keys(this.scope.blockScopedDeclarations).forEach(name => {\n\t\t\tconst declarations = this.scope.blockScopedDeclarations[name];\n\n\t\t\tfor (const declaration of declarations) {\n\t\t\t\tlet cont = false; // TODO implement proper continue...\n\n\t\t\t\tif (declaration.kind === 'for.let') {\n\t\t\t\t\t// special case\n\t\t\t\t\tconst forStatement = declaration.node.findNearest('ForStatement');\n\n\t\t\t\t\tif (forStatement.shouldRewriteAsFunction) {\n\t\t\t\t\t\tconst outerAlias = this.scope.createIdentifier(name);\n\t\t\t\t\t\tconst innerAlias = forStatement.reassigned[name]\n\t\t\t\t\t\t\t? this.scope.createIdentifier(name)\n\t\t\t\t\t\t\t: name;\n\n\t\t\t\t\t\tdeclaration.name = outerAlias;\n\t\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\t\tdeclaration.node.start,\n\t\t\t\t\t\t\tdeclaration.node.end,\n\t\t\t\t\t\t\touterAlias,\n\t\t\t\t\t\t\t{ storeName: true }\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tforStatement.aliases[name] = {\n\t\t\t\t\t\t\touter: outerAlias,\n\t\t\t\t\t\t\tinner: innerAlias\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (const identifier of declaration.instances) {\n\t\t\t\t\t\t\tconst alias = forStatement.body.contains(identifier)\n\t\t\t\t\t\t\t\t? innerAlias\n\t\t\t\t\t\t\t\t: outerAlias;\n\n\t\t\t\t\t\t\tif (name !== alias) {\n\t\t\t\t\t\t\t\tcode.overwrite(identifier.start, identifier.end, alias, {\n\t\t\t\t\t\t\t\t\tstoreName: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cont) {\n\t\t\t\t\tconst alias = this.scope.createIdentifier(name);\n\n\t\t\t\t\tif (name !== alias) {\n\t\t\t\t\t\tconst declarationParent = declaration.node.parent;\n\t\t\t\t\t\tdeclaration.name = alias;\n\t\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\t\tdeclaration.node.start,\n\t\t\t\t\t\t\tdeclaration.node.end,\n\t\t\t\t\t\t\talias,\n\t\t\t\t\t\t\t{ storeName: true }\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (declarationParent.type === 'Property' && declarationParent.shorthand) {\n\t\t\t\t\t\t\tdeclarationParent.shorthand = false;\n\t\t\t\t\t\t\tcode.prependLeft(declaration.node.start, `${name}: `);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const identifier of declaration.instances) {\n\t\t\t\t\t\t\tidentifier.rewritten = true;\n\t\t\t\t\t\t\tconst identifierParent = identifier.parent;\n\t\t\t\t\t\t\tcode.overwrite(identifier.start, identifier.end, alias, {\n\t\t\t\t\t\t\t\tstoreName: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (identifierParent.type === 'Property' && identifierParent.shorthand) {\n\t\t\t\t\t\t\t\tidentifierParent.shorthand = false;\n\t\t\t\t\t\t\t\tcode.prependLeft(identifier.start, `${name}: `);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n","import CompileError from './CompileError.js';\n\nexport function isArguments(node) {\n\treturn node.type === 'Identifier' && node.name === 'arguments';\n}\n\nexport function inlineSpreads(\n\tcode,\n\tnode,\n\telements\n) {\n\tlet i = elements.length;\n\n\twhile (i--) {\n\t\tconst element = elements[i];\n\t\tif (!element || element.type !== 'SpreadElement') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst argument = element.argument;\n\t\tif (argument.type !== 'ArrayExpression') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst subelements = argument.elements;\n\t\tif (subelements.some(subelement => subelement === null)) {\n\t\t\t// Not even going to try inlining spread arrays with holes.\n\t\t\t// It's a lot of work (got to be VERY careful in comma counting for\n\t\t\t// ArrayExpression, and turn blanks into undefined for\n\t\t\t// CallExpression and NewExpression), and probably literally no one\n\t\t\t// would ever benefit from it.\n\t\t\tcontinue;\n\t\t}\n\t\t// We can inline it: drop the `...[` and `]` and sort out any commas.\n\t\tconst isLast = i === elements.length - 1;\n\t\tif (subelements.length === 0) {\n\t\t\tcode.remove(\n\t\t\t\tisLast && i !== 0\n\t\t\t\t\t? elements[i - 1].end  // Take the previous comma too\n\t\t\t\t\t: element.start,\n\t\t\t\tisLast\n\t\t\t\t\t? node.end - 1  // Must remove trailing comma; element.end wouldn’t\n\t\t\t\t\t: elements[i + 1].start);\n\t\t} else {\n\t\t\t// Strip the `...[` and the `]` with a possible trailing comma before it,\n\t\t\t// leaving just the possible trailing comma after it.\n\t\t\tcode.remove(element.start, subelements[0].start);\n\t\t\tcode.remove(\n\t\t\t\t// Strip a possible trailing comma after the last element\n\t\t\t\tsubelements[subelements.length - 1].end,\n\t\t\t\t// And also a possible trailing comma after the spread\n\t\t\t\tisLast\n\t\t\t\t\t? node.end - 1\n\t\t\t\t\t: element.end\n\t\t\t);\n\t\t}\n\t\telements.splice(i, 1, ...subelements);\n\t\ti += subelements.length;\n\t}\n}\n\n// Returns false if it’s safe to simply append a method call to the node,\n// e.g. `a` → `a.concat()`.\n//\n// Returns true if it may not be and so parentheses should be employed,\n// e.g. `a ? b : c` → `a ? b : c.concat()` would be wrong.\n//\n// This test may be overcautious; if desired it can be refined over time.\nexport function needsParentheses(node) {\n\tswitch (node.type) {\n\t\t// Currently whitelisted are all relevant ES5 node types ('Literal' and\n\t\t// 'ObjectExpression' are skipped as irrelevant for array/call spread.)\n\t\tcase 'ArrayExpression':\n\t\tcase 'CallExpression':\n\t\tcase 'Identifier':\n\t\tcase 'ParenthesizedExpression':\n\t\tcase 'ThisExpression':\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n\nexport default function spread(\n\tcode,\n\telements,\n\tstart,\n\targumentsArrayAlias,\n\tisNew\n) {\n\tlet i = elements.length;\n\tlet firstSpreadIndex = -1;\n\n\twhile (i--) {\n\t\tconst element = elements[i];\n\t\tif (element && element.type === 'SpreadElement') {\n\t\t\tif (isArguments(element.argument)) {\n\t\t\t\tcode.overwrite(\n\t\t\t\t\telement.argument.start,\n\t\t\t\t\telement.argument.end,\n\t\t\t\t\targumentsArrayAlias\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfirstSpreadIndex = i;\n\t\t}\n\t}\n\n\tif (firstSpreadIndex === -1) return false; // false indicates no spread elements\n\n\tif (isNew) {\n\t\tfor (i = 0; i < elements.length; i += 1) {\n\t\t\tconst element = elements[i];\n\t\t\tif (element.type === 'SpreadElement') {\n\t\t\t\tcode.remove(element.start, element.argument.start);\n\t\t\t} else {\n\t\t\t\tcode.prependRight(element.start, '[');\n\t\t\t\tcode.prependRight(element.end, ']');\n\t\t\t}\n\t\t}\n\n\t\treturn true; // true indicates some spread elements\n\t}\n\n\tlet element = elements[firstSpreadIndex];\n\tconst previousElement = elements[firstSpreadIndex - 1];\n\n\tif (!previousElement) {\n\t\t// We may need to parenthesize it to handle ternaries like [...a ? b : c].\n\t\tlet addClosingParen;\n\t\tif (start !== element.start) {\n\t\t\tif ((addClosingParen = needsParentheses(element.argument))) {\n\t\t\t\tcode.overwrite(start, element.start, '( ');\n\t\t\t} else {\n\t\t\t\tcode.remove(start, element.start);\n\t\t\t}\n\t\t} else if (element.parent.type === 'CallExpression') {\n\t\t\t// CallExpression inserts `( ` itself, we add the ).\n\t\t\t// (Yeah, CallExpression did the needsParentheses call already,\n\t\t\t// but we don’t have its result handy, so do it again. It’s cheap.)\n\t\t\taddClosingParen = needsParentheses(element.argument);\n\t\t} else {\n\t\t\t// Should be unreachable, but doing this is more robust.\n\t\t\tthrow new CompileError(\n\t\t\t\t'Unsupported spread construct, please raise an issue at https://github.com/bublejs/buble/issues',\n\t\t\t\telement\n\t\t\t);\n\t\t}\n\t\tcode.overwrite(element.end, elements[1].start,\n\t\t\taddClosingParen ? ' ).concat( ' : '.concat( ');\n\t} else {\n\t\tcode.overwrite(previousElement.end, element.start, ' ].concat( ');\n\t}\n\n\tfor (i = firstSpreadIndex; i < elements.length; i += 1) {\n\t\telement = elements[i];\n\n\t\tif (element) {\n\t\t\tif (element.type === 'SpreadElement') {\n\t\t\t\tcode.remove(element.start, element.argument.start);\n\t\t\t} else {\n\t\t\t\tcode.appendLeft(element.start, '[');\n\t\t\t\tcode.appendLeft(element.end, ']');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true; // true indicates some spread elements\n}\n","import Node from '../Node.js';\nimport spread, { isArguments, inlineSpreads } from '../../utils/spread.js';\n\nexport default class ArrayExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.spreadRest && this.elements.length) {\n\t\t\tconst lexicalBoundary = this.findLexicalBoundary();\n\n\t\t\tlet i = this.elements.length;\n\t\t\twhile (i--) {\n\t\t\t\tconst element = this.elements[i];\n\t\t\t\tif (\n\t\t\t\t\telement &&\n\t\t\t\t\telement.type === 'SpreadElement' &&\n\t\t\t\t\tisArguments(element.argument)\n\t\t\t\t) {\n\t\t\t\t\tthis.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tif (transforms.spreadRest) {\n\t\t\tinlineSpreads(code, this, this.elements);\n\t\t\t// erase trailing comma after last array element if not an array hole\n\t\t\tif (this.elements.length) {\n\t\t\t\tconst lastElement = this.elements[this.elements.length - 1];\n\t\t\t\tif (\n\t\t\t\t\tlastElement &&\n\t\t\t\t\t/\\s*,/.test(code.original.slice(lastElement.end, this.end))\n\t\t\t\t) {\n\t\t\t\t\tcode.overwrite(lastElement.end, this.end - 1, ' ');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.elements.length === 1) {\n\t\t\t\tconst element = this.elements[0];\n\n\t\t\t\tif (element && element.type === 'SpreadElement') {\n\t\t\t\t\t// special case – [ ...arguments ]\n\t\t\t\t\tif (isArguments(element.argument)) {\n\t\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\t\tthis.start,\n\t\t\t\t\t\t\tthis.end,\n\t\t\t\t\t\t\t`[].concat( ${this.argumentsArrayAlias} )`\n\t\t\t\t\t\t); // TODO if this is the only use of argsArray, don't bother concating\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode.overwrite(this.start, element.argument.start, '[].concat( ');\n\t\t\t\t\t\tcode.overwrite(element.end, this.end, ' )');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst hasSpreadElements = spread(\n\t\t\t\t\tcode,\n\t\t\t\t\tthis.elements,\n\t\t\t\t\tthis.start,\n\t\t\t\t\tthis.argumentsArrayAlias\n\t\t\t\t);\n\n\t\t\t\tif (hasSpreadElements) {\n\t\t\t\t\tcode.overwrite(this.end - 1, this.end, ')');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","export default function removeTrailingComma(code, c) {\n\twhile (code.original[c] !== ')') {\n\t\tif (code.original[c] === ',') {\n\t\t\tcode.remove(c, c + 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (code.original[c] === '/') {\n\t\t\tif (code.original[c + 1] === '/') {\n\t\t\t\tc = code.original.indexOf('\\n', c);\n\t\t\t} else {\n\t\t\t\tc = code.original.indexOf('*/', c) + 1;\n\t\t\t}\n\t\t}\n\t\tc += 1;\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport removeTrailingComma from '../../utils/removeTrailingComma.js';\n\nexport default class ArrowFunctionExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (this.async && transforms.asyncAwait) {\n\t\t\tCompileError.missingTransform(\"async arrow functions\", \"asyncAwait\", this);\n\t\t}\n\t\tthis.body.createScope();\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tlet openParensPos = this.start;\n\t\tfor (let end = (this.body || this.params[0]).start - 1; code.original[openParensPos] !== '(' && openParensPos < end;) {\n\t\t\t++openParensPos;\n\t\t}\n\t\tif (code.original[openParensPos] !== '(') openParensPos = -1;\n\t\tconst naked = openParensPos === -1;\n\n\t\tif (transforms.arrow || this.needsArguments(transforms)) {\n\t\t\t// remove arrow\n\t\t\tlet charIndex = this.body.start;\n\t\t\twhile (code.original[charIndex] !== '=') {\n\t\t\t\tcharIndex -= 1;\n\t\t\t}\n\t\t\tcode.remove(charIndex, this.body.start);\n\n\t\t\tsuper.transpile(code, transforms);\n\n\t\t\t// wrap naked parameter\n\t\t\tif (naked) {\n\t\t\t\tcode.prependRight(this.params[0].start, '(');\n\t\t\t\tcode.appendLeft(this.params[0].end, ')');\n\t\t\t}\n\n\t\t\t// standalone expression statement\n\t\t\tconst standalone = this.parent && this.parent.type === 'ExpressionStatement';\n\t\t\tlet start, text = standalone ? '!' : '';\n\t\t\tif (this.async) text += 'async ';\n\t\t\ttext += 'function';\n\t\t\tif (!standalone) text += ' ';\n\t\t\tif (naked) {\n\t\t\t\tstart = this.params[0].start;\n\t\t\t} else {\n\t\t\t\tstart = openParensPos;\n\t\t\t}\n\t\t\t// add function\n\t\t\tif (start > this.start) {\n\t\t\t\tcode.overwrite(this.start, start, text);\n\t\t\t} else {\n\t\t\t\tcode.prependRight(this.start, text);\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.transpile(code, transforms);\n\t\t}\n\n\t\tif (transforms.trailingFunctionCommas && this.params.length && !naked) {\n\t\t\tremoveTrailingComma(code, this.params[this.params.length - 1].end);\n\t\t}\n\t}\n\n\t// Returns whether any transforms that will happen use `arguments`\n\tneedsArguments(transforms) {\n\t\treturn (\n\t\t\ttransforms.spreadRest &&\n\t\t\tthis.params.filter(param => param.type === 'RestElement').length > 0\n\t\t);\n\t}\n}\n","import CompileError from './CompileError.js';\n\nexport default function checkConst(identifier, scope) {\n\tconst declaration = scope.findDeclaration(identifier.name);\n\tif (declaration && declaration.kind === 'const') {\n\t\tthrow new CompileError(`${identifier.name} is read-only`, identifier);\n\t}\n}\n","import Node from '../Node.js';\nimport checkConst from '../../utils/checkConst.js';\nimport destructure from '../../utils/destructure.js';\n\nexport default class AssignmentExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (this.left.type === 'Identifier') {\n\t\t\tconst declaration = this.findScope(false).findDeclaration(this.left.name);\n\t\t\t// special case – https://gitlab.com/Rich-Harris/buble/issues/11\n\t\t\tconst statement = declaration && declaration.node.ancestor(3);\n\t\t\tif (\n\t\t\t\tstatement &&\n\t\t\t\tstatement.type === 'ForStatement' &&\n\t\t\t\tstatement.body.contains(this)\n\t\t\t) {\n\t\t\t\tstatement.reassigned[this.left.name] = true;\n\t\t\t}\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (this.left.type === 'Identifier') {\n\t\t\t// Do this check after everything has been initialized to find\n\t\t\t// shadowing declarations after this expression\n\t\t\tcheckConst(this.left, this.findScope(false));\n\t\t}\n\n\t\tif (this.operator === '**=' && transforms.exponentiation) {\n\t\t\tthis.transpileExponentiation(code, transforms);\n\t\t} else if (/Pattern/.test(this.left.type) && transforms.destructuring) {\n\t\t\tthis.transpileDestructuring(code);\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n\n\ttranspileDestructuring(code) {\n\t\tconst writeScope = this.findScope(true);\n\t\tconst lookupScope = this.findScope(false);\n\t\tconst assign = writeScope.createDeclaration('assign');\n\t\tcode.appendRight(this.left.end, `(${assign}`);\n\n\t\tcode.appendLeft(this.right.end, ', ');\n\t\tconst statementGenerators = [];\n\t\tdestructure(\n\t\t\tcode,\n\t\t\tid => writeScope.createDeclaration(id),\n\t\t\tnode => {\n\t\t\t\tconst name = lookupScope.resolveName(node.name);\n\t\t\t\tcheckConst(node, lookupScope);\n\t\t\t\treturn name;\n\t\t\t},\n\t\t\tthis.left,\n\t\t\tassign,\n\t\t\ttrue,\n\t\t\tstatementGenerators\n\t\t);\n\n\t\tlet suffix = ', ';\n\t\tstatementGenerators.forEach((fn, j) => {\n\t\t\tif (j === statementGenerators.length - 1) {\n\t\t\t\tsuffix = '';\n\t\t\t}\n\n\t\t\tfn(this.end, '', suffix);\n\t\t});\n\n\t\tif (this.unparenthesizedParent().type === 'ExpressionStatement') {\n\t\t\t// no rvalue needed for expression statement\n\t\t\tcode.prependRight(this.end, `)`);\n\t\t} else {\n\t\t\t// destructuring is part of an expression - need an rvalue\n\t\t\tcode.appendRight(this.end, `, ${assign})`);\n\t\t}\n\t}\n\n\ttranspileExponentiation(code) {\n\t\tconst scope = this.findScope(false);\n\n\t\t// first, the easy part – `**=` -> `=`\n\t\tlet charIndex = this.left.end;\n\t\twhile (code.original[charIndex] !== '*') charIndex += 1;\n\t\tcode.remove(charIndex, charIndex + 2);\n\n\t\t// how we do the next part depends on a number of factors – whether\n\t\t// this is a top-level statement, and whether we're updating a\n\t\t// simple or complex reference\n\t\tlet base;\n\n\t\tconst left = this.left.unparenthesize();\n\n\t\tif (left.type === 'Identifier') {\n\t\t\tbase = scope.resolveName(left.name);\n\t\t} else if (left.type === 'MemberExpression') {\n\t\t\tlet object;\n\t\t\tlet needsObjectVar = false;\n\t\t\tlet property;\n\t\t\tlet needsPropertyVar = false;\n\n\t\t\tconst statement = this.findNearest(/(?:Statement|Declaration)$/);\n\t\t\tconst i0 = statement.getIndentation();\n\n\t\t\tif (left.property.type === 'Identifier') {\n\t\t\t\tproperty = left.computed\n\t\t\t\t\t? scope.resolveName(left.property.name)\n\t\t\t\t\t: left.property.name;\n\t\t\t} else {\n\t\t\t\tproperty = scope.createDeclaration('property');\n\t\t\t\tneedsPropertyVar = true;\n\t\t\t}\n\n\t\t\tif (left.object.type === 'Identifier') {\n\t\t\t\tobject = scope.resolveName(left.object.name);\n\t\t\t} else {\n\t\t\t\tobject = scope.createDeclaration('object');\n\t\t\t\tneedsObjectVar = true;\n\t\t\t}\n\n\t\t\tif (left.start === statement.start) {\n\t\t\t\tif (needsObjectVar && needsPropertyVar) {\n\t\t\t\t\tcode.prependRight(statement.start, `${object} = `);\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tleft.object.end,\n\t\t\t\t\t\tleft.property.start,\n\t\t\t\t\t\t`;\\n${i0}${property} = `\n\t\t\t\t\t);\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tleft.property.end,\n\t\t\t\t\t\tleft.end,\n\t\t\t\t\t\t`;\\n${i0}${object}[${property}]`\n\t\t\t\t\t);\n\t\t\t\t} else if (needsObjectVar) {\n\t\t\t\t\tcode.prependRight(statement.start, `${object} = `);\n\t\t\t\t\tcode.appendLeft(left.object.end, `;\\n${i0}`);\n\t\t\t\t\tcode.appendLeft(left.object.end, object);\n\t\t\t\t} else if (needsPropertyVar) {\n\t\t\t\t\tcode.prependRight(left.property.start, `${property} = `);\n\t\t\t\t\tcode.appendLeft(left.property.end, `;\\n${i0}`);\n\t\t\t\t\tcode.move(left.property.start, left.property.end, this.start);\n\n\t\t\t\t\tcode.appendLeft(left.object.end, `[${property}]`);\n\t\t\t\t\tcode.remove(left.object.end, left.property.start);\n\t\t\t\t\tcode.remove(left.property.end, left.end);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (needsObjectVar && needsPropertyVar) {\n\t\t\t\t\tcode.prependRight(left.start, `( ${object} = `);\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tleft.object.end,\n\t\t\t\t\t\tleft.property.start,\n\t\t\t\t\t\t`, ${property} = `\n\t\t\t\t\t);\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tleft.property.end,\n\t\t\t\t\t\tleft.end,\n\t\t\t\t\t\t`, ${object}[${property}]`\n\t\t\t\t\t);\n\t\t\t\t} else if (needsObjectVar) {\n\t\t\t\t\tcode.prependRight(left.start, `( ${object} = `);\n\t\t\t\t\tcode.appendLeft(left.object.end, `, ${object}`);\n\t\t\t\t} else if (needsPropertyVar) {\n\t\t\t\t\tcode.prependRight(left.property.start, `( ${property} = `);\n\t\t\t\t\tcode.appendLeft(left.property.end, `, `);\n\t\t\t\t\tcode.move(left.property.start, left.property.end, left.start);\n\n\t\t\t\t\tcode.overwrite(left.object.end, left.property.start, `[${property}]`);\n\t\t\t\t\tcode.remove(left.property.end, left.end);\n\t\t\t\t}\n\n\t\t\t\tif (needsPropertyVar) {\n\t\t\t\t\tcode.appendLeft(this.end, ` )`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase =\n\t\t\t\tobject +\n\t\t\t\t(left.computed || needsPropertyVar ? `[${property}]` : `.${property}`);\n\t\t}\n\n\t\tcode.prependRight(this.right.start, `Math.pow( ${base}, `);\n\t\tcode.appendLeft(this.right.end, ` )`);\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class AwaitExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.asyncAwait) {\n\t\t\tCompileError.missingTransform(\"await\", \"asyncAwait\", this);\n\t\t}\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class BinaryExpression extends Node {\n\ttranspile(code, transforms) {\n\t\tif (this.operator === '**' && transforms.exponentiation) {\n\t\t\tcode.prependRight(this.start, `Math.pow( `);\n\t\t\tcode.overwrite(this.left.end, this.right.start, `, `);\n\t\t\tcode.appendLeft(this.end, ` )`);\n\t\t}\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","export const loopStatement = /(?:For(?:In|Of)?|While)Statement/;\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class BreakStatement extends Node {\n\tinitialise() {\n\t\tconst loop = this.findNearest(loopStatement);\n\t\tconst switchCase = this.findNearest('SwitchCase');\n\n\t\tif (loop && (!switchCase || loop.depth > switchCase.depth)) {\n\t\t\tloop.canBreak = true;\n\t\t\tthis.loop = loop;\n\t\t}\n\t}\n\n\ttranspile(code) {\n\t\tif (this.loop && this.loop.shouldRewriteAsFunction) {\n\t\t\tif (this.label)\n\t\t\t\tthrow new CompileError(\n\t\t\t\t\t'Labels are not currently supported in a loop with locally-scoped variables',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\tcode.overwrite(this.start, this.start + 5, `return 'break'`);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport spread, { isArguments, inlineSpreads, needsParentheses } from '../../utils/spread.js';\nimport removeTrailingComma from '../../utils/removeTrailingComma.js';\n\nexport default class CallExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.spreadRest && this.arguments.length > 1) {\n\t\t\tconst lexicalBoundary = this.findLexicalBoundary();\n\n\t\t\tlet i = this.arguments.length;\n\t\t\twhile (i--) {\n\t\t\t\tconst arg = this.arguments[i];\n\t\t\t\tif (arg.type === 'SpreadElement' && isArguments(arg.argument)) {\n\t\t\t\t\tthis.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (transforms.spreadRest && this.arguments.length) {\n\t\t\tinlineSpreads(code, this, this.arguments);\n\t\t\t// this.arguments.length may have changed, must retest.\n\t\t}\n\n\t\tif (transforms.spreadRest && this.arguments.length) {\n\t\t\tlet hasSpreadElements = false;\n\t\t\tlet context;\n\n\t\t\tconst firstArgument = this.arguments[0];\n\n\t\t\tif (this.arguments.length === 1) {\n\t\t\t\tif (firstArgument.type === 'SpreadElement') {\n\t\t\t\t\tcode.remove(firstArgument.start, firstArgument.argument.start);\n\t\t\t\t\thasSpreadElements = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thasSpreadElements = spread(\n\t\t\t\t\tcode,\n\t\t\t\t\tthis.arguments,\n\t\t\t\t\tfirstArgument.start,\n\t\t\t\t\tthis.argumentsArrayAlias\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (hasSpreadElements) {\n\t\t\t\t// we need to handle super() and super.method() differently\n\t\t\t\t// due to its instance\n\t\t\t\tlet _super = null;\n\t\t\t\tif (this.callee.type === 'Super') {\n\t\t\t\t\t_super = this.callee;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.callee.type === 'MemberExpression' &&\n\t\t\t\t\tthis.callee.object.type === 'Super'\n\t\t\t\t) {\n\t\t\t\t\t_super = this.callee.object;\n\t\t\t\t}\n\n\t\t\t\tif (!_super && this.callee.type === 'MemberExpression') {\n\t\t\t\t\tif (this.callee.object.type === 'Identifier') {\n\t\t\t\t\t\tcontext = this.callee.object.name;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext = this.findScope(true).createDeclaration('ref');\n\t\t\t\t\t\tconst callExpression = this.callee.object;\n\t\t\t\t\t\tcode.prependRight(callExpression.start, `(${context} = `);\n\t\t\t\t\t\tcode.appendLeft(callExpression.end, `)`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext = 'void 0';\n\t\t\t\t}\n\n\t\t\t\tcode.appendLeft(this.callee.end, '.apply');\n\n\t\t\t\tif (_super) {\n\t\t\t\t\t_super.noCall = true; // bit hacky...\n\n\t\t\t\t\tif (this.arguments.length > 1) {\n\t\t\t\t\t\tif (firstArgument.type === 'SpreadElement') {\n\t\t\t\t\t\t\tif (needsParentheses(firstArgument.argument)) {\n\t\t\t\t\t\t\t\tcode.prependRight(firstArgument.start, `( `);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode.prependRight(firstArgument.start, `[ `);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcode.appendLeft(\n\t\t\t\t\t\t\tthis.arguments[this.arguments.length - 1].end,\n\t\t\t\t\t\t\t' )'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (this.arguments.length === 1) {\n\t\t\t\t\tcode.prependRight(firstArgument.start, `${context}, `);\n\t\t\t\t} else {\n\t\t\t\t\tif (firstArgument.type === 'SpreadElement') {\n\t\t\t\t\t\tif (needsParentheses(firstArgument.argument)) {\n\t\t\t\t\t\t\tcode.appendLeft(firstArgument.start, `${context}, ( `);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode.appendLeft(firstArgument.start, `${context}, `);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode.appendLeft(firstArgument.start, `${context}, [ `);\n\t\t\t\t\t}\n\n\t\t\t\t\tcode.appendLeft(this.arguments[this.arguments.length - 1].end, ' )');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (transforms.trailingFunctionCommas && this.arguments.length) {\n\t\t\tremoveTrailingComma(code, this.arguments[this.arguments.length - 1].end);\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport Scope from '../Scope.js';\n\nexport default class CatchClause extends Node {\n\tinitialise(transforms) {\n\t\tthis.createdDeclarations = [];\n\t\tthis.scope = new Scope({\n\t\t\tblock: true,\n\t\t\tparent: this.parent.findScope(false),\n\t\t\tdeclare: id => this.createdDeclarations.push(id)\n\t\t});\n\n\t\tthis.scope.addDeclaration(this.param, 'catch');\n\n\t\tsuper.initialise(transforms);\n\t\tthis.scope.consolidate();\n\t}\n\n\tfindScope(functionScope) {\n\t\treturn functionScope\n\t\t\t? this.parent.findScope(functionScope)\n\t\t\t: this.scope;\n\t}\n}\n\n","import CompileError from '../../utils/CompileError.js';\nimport Node from '../Node.js';\nimport { findIndex } from '../../utils/array.js';\nimport reserved from '../../utils/reserved.js';\n\n// TODO this code is pretty wild, tidy it up\nexport default class ClassBody extends Node {\n\ttranspile(code, transforms, inFunctionExpression, superName) {\n\t\tif (transforms.classes) {\n\t\t\tconst name = this.parent.name;\n\n\t\t\tconst indentStr = code.getIndentString();\n\t\t\tconst i0 =\n\t\t\t\tthis.getIndentation() + (inFunctionExpression ? indentStr : '');\n\t\t\tconst i1 = i0 + indentStr;\n\n\t\t\tconst constructorIndex = findIndex(\n\t\t\t\tthis.body,\n\t\t\t\tnode => node.kind === 'constructor'\n\t\t\t);\n\t\t\tconst constructor = this.body[constructorIndex];\n\n\t\t\tlet introBlock = '';\n\t\t\tlet outroBlock = '';\n\n\t\t\tif (this.body.length) {\n\t\t\t\tcode.remove(this.start, this.body[0].start);\n\t\t\t\tcode.remove(this.body[this.body.length - 1].end, this.end);\n\t\t\t} else {\n\t\t\t\tcode.remove(this.start, this.end);\n\t\t\t}\n\n\t\t\tif (constructor) {\n\t\t\t\tconstructor.value.body.isConstructorBody = true;\n\n\t\t\t\tconst previousMethod = this.body[constructorIndex - 1];\n\t\t\t\tconst nextMethod = this.body[constructorIndex + 1];\n\n\t\t\t\t// ensure constructor is first\n\t\t\t\tif (constructorIndex > 0) {\n\t\t\t\t\tcode.remove(previousMethod.end, constructor.start);\n\t\t\t\t\tcode.move(\n\t\t\t\t\t\tconstructor.start,\n\t\t\t\t\t\tnextMethod ? nextMethod.start : this.end - 1,\n\t\t\t\t\t\tthis.body[0].start\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!inFunctionExpression) code.appendLeft(constructor.end, ';');\n\t\t\t}\n\n\t\t\tconst namedFunctions =\n\t\t\t\tthis.program.options.namedFunctionExpressions !== false;\n\t\t\tconst namedConstructor =\n\t\t\t\tnamedFunctions ||\n\t\t\t\tthis.parent.superClass ||\n\t\t\t\tthis.parent.type !== 'ClassDeclaration';\n\t\t\tif (this.parent.superClass) {\n\t\t\t\tlet inheritanceBlock = `if ( ${superName} ) ${name}.__proto__ = ${\n\t\t\t\t\tsuperName\n\t\t\t\t};\\n${i0}${name}.prototype = Object.create( ${superName} && ${\n\t\t\t\t\tsuperName\n\t\t\t\t}.prototype );\\n${i0}${name}.prototype.constructor = ${name};`;\n\n\t\t\t\tif (constructor) {\n\t\t\t\t\tintroBlock += `\\n\\n${i0}` + inheritanceBlock;\n\t\t\t\t} else {\n\t\t\t\t\tconst fn =\n\t\t\t\t\t\t`function ${name} () {` +\n\t\t\t\t\t\t(superName\n\t\t\t\t\t\t\t? `\\n${i1}${superName}.apply(this, arguments);\\n${i0}}`\n\t\t\t\t\t\t\t: `}`) +\n\t\t\t\t\t\t(inFunctionExpression ? '' : ';') +\n\t\t\t\t\t\t(this.body.length ? `\\n\\n${i0}` : '');\n\n\t\t\t\t\tinheritanceBlock = fn + inheritanceBlock;\n\t\t\t\t\tintroBlock += inheritanceBlock + `\\n\\n${i0}`;\n\t\t\t\t}\n\t\t\t} else if (!constructor) {\n\t\t\t\tlet fn = 'function ' + (namedConstructor ? name + ' ' : '') + '() {}';\n\t\t\t\tif (this.parent.type === 'ClassDeclaration') fn += ';';\n\t\t\t\tif (this.body.length) fn += `\\n\\n${i0}`;\n\n\t\t\t\tintroBlock += fn;\n\t\t\t}\n\n\t\t\tconst scope = this.findScope(false);\n\n\t\t\tconst prototypeGettersAndSetters = [];\n\t\t\tconst staticGettersAndSetters = [];\n\t\t\tlet prototypeAccessors;\n\t\t\tlet staticAccessors;\n\n\t\t\tthis.body.forEach((method, i) => {\n\t\t\t\tif ((method.kind === 'get' || method.kind === 'set') && transforms.getterSetter) {\n\t\t\t\t\tCompileError.missingTransform(\"getters and setters\", \"getterSetter\", method);\n\t\t\t\t}\n\n\t\t\t\tif (method.kind === 'constructor') {\n\t\t\t\t\tconst constructorName = namedConstructor ? ' ' + name : '';\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tmethod.key.start,\n\t\t\t\t\t\tmethod.key.end,\n\t\t\t\t\t\t`function${constructorName}`\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (method.static) {\n\t\t\t\t\tconst len = code.original[method.start + 6] == ' ' ? 7 : 6;\n\t\t\t\t\tcode.remove(method.start, method.start + len);\n\t\t\t\t}\n\n\t\t\t\tconst isAccessor = method.kind !== 'method';\n\t\t\t\tlet lhs;\n\n\t\t\t\tlet methodName = method.key.name;\n\t\t\t\tif (\n\t\t\t\t\treserved[methodName] ||\n\t\t\t\t\tmethod.value.body.scope.references[methodName]\n\t\t\t\t) {\n\t\t\t\t\tmethodName = scope.createIdentifier(methodName);\n\t\t\t\t}\n\n\t\t\t\t// when method name is a string or a number let's pretend it's a computed method\n\n\t\t\t\tlet fake_computed = false;\n\t\t\t\tif (!method.computed && method.key.type === 'Literal') {\n\t\t\t\t\tfake_computed = true;\n\t\t\t\t\tmethod.computed = true;\n\t\t\t\t}\n\n\t\t\t\tif (isAccessor) {\n\t\t\t\t\tif (method.computed) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Computed accessor properties are not currently supported'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tcode.remove(method.start, method.key.start);\n\n\t\t\t\t\tif (method.static) {\n\t\t\t\t\t\tif (!~staticGettersAndSetters.indexOf(method.key.name))\n\t\t\t\t\t\t\tstaticGettersAndSetters.push(method.key.name);\n\t\t\t\t\t\tif (!staticAccessors)\n\t\t\t\t\t\t\tstaticAccessors = scope.createIdentifier('staticAccessors');\n\n\t\t\t\t\t\tlhs = `${staticAccessors}`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!~prototypeGettersAndSetters.indexOf(method.key.name))\n\t\t\t\t\t\t\tprototypeGettersAndSetters.push(method.key.name);\n\t\t\t\t\t\tif (!prototypeAccessors)\n\t\t\t\t\t\t\tprototypeAccessors = scope.createIdentifier('prototypeAccessors');\n\n\t\t\t\t\t\tlhs = `${prototypeAccessors}`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlhs = method.static ? `${name}` : `${name}.prototype`;\n\t\t\t\t}\n\n\t\t\t\tif (!method.computed) lhs += '.';\n\n\t\t\t\tconst insertNewlines =\n\t\t\t\t\t(constructorIndex > 0 && i === constructorIndex + 1) ||\n\t\t\t\t\t(i === 0 && constructorIndex === this.body.length - 1);\n\n\t\t\t\tif (insertNewlines) lhs = `\\n\\n${i0}${lhs}`;\n\n\t\t\t\tlet c = method.key.end;\n\t\t\t\tif (method.computed) {\n\t\t\t\t\tif (fake_computed) {\n\t\t\t\t\t\tcode.prependRight(method.key.start, '[');\n\t\t\t\t\t\tcode.appendLeft(method.key.end, ']');\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (code.original[c] !== ']') c += 1;\n\t\t\t\t\t\tc += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst funcName =\n\t\t\t\t\tmethod.computed || isAccessor || !namedFunctions\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: `${methodName} `;\n\t\t\t\tconst rhs =\n\t\t\t\t\t(isAccessor ? `.${method.kind}` : '') +\n\t\t\t\t\t` = ${method.value.async ? 'async ' : ''}function` +\n\t\t\t\t\t(method.value.generator ? '* ' : ' ') +\n\t\t\t\t\tfuncName;\n\t\t\t\tcode.remove(c, method.value.start);\n\t\t\t\tcode.prependRight(method.value.start, rhs);\n\t\t\t\tcode.appendLeft(method.end, ';');\n\n\t\t\t\tif (method.value.generator) code.remove(method.start, method.key.start);\n\n\t\t\t\tlet start = method.key.start;\n\t\t\t\tif (method.computed && !fake_computed) {\n\t\t\t\t\twhile (code.original[start] != '[') {\n\t\t\t\t\t\t--start;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (method.start < start) {\n\t\t\t\t\tcode.overwrite(method.start, start, lhs);\n\t\t\t\t} else {\n\t\t\t\t\tcode.prependRight(method.start, lhs);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (prototypeGettersAndSetters.length || staticGettersAndSetters.length) {\n\t\t\t\tconst intro = [];\n\t\t\t\tconst outro = [];\n\n\t\t\t\tif (prototypeGettersAndSetters.length) {\n\t\t\t\t\tintro.push(\n\t\t\t\t\t\t`var ${prototypeAccessors} = { ${prototypeGettersAndSetters\n\t\t\t\t\t\t\t.map(name => `${name}: { configurable: true }`)\n\t\t\t\t\t\t\t.join(',')} };`\n\t\t\t\t\t);\n\t\t\t\t\toutro.push(\n\t\t\t\t\t\t`Object.defineProperties( ${name}.prototype, ${\n\t\t\t\t\t\t\tprototypeAccessors\n\t\t\t\t\t\t} );`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (staticGettersAndSetters.length) {\n\t\t\t\t\tintro.push(\n\t\t\t\t\t\t`var ${staticAccessors} = { ${staticGettersAndSetters\n\t\t\t\t\t\t\t.map(name => `${name}: { configurable: true }`)\n\t\t\t\t\t\t\t.join(',')} };`\n\t\t\t\t\t);\n\t\t\t\t\toutro.push(`Object.defineProperties( ${name}, ${staticAccessors} );`);\n\t\t\t\t}\n\n\t\t\t\tif (constructor) introBlock += `\\n\\n${i0}`;\n\t\t\t\tintroBlock += intro.join(`\\n${i0}`);\n\t\t\t\tif (!constructor) introBlock += `\\n\\n${i0}`;\n\n\t\t\t\toutroBlock += `\\n\\n${i0}` + outro.join(`\\n${i0}`);\n\t\t\t}\n\n\t\t\tif (constructor) {\n\t\t\t\tcode.appendLeft(constructor.end, introBlock);\n\t\t\t} else {\n\t\t\t\tcode.prependRight(this.start, introBlock);\n\t\t\t}\n\n\t\t\tcode.appendLeft(this.end, outroBlock);\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","// TODO this function is slightly flawed – it works on the original string,\n// not its current edited state.\n// That's not a problem for the way that it's currently used, but it could\n// be in future...\nexport default function deindent(node, code) {\n\tconst start = node.start;\n\tconst end = node.end;\n\n\tconst indentStr = code.getIndentString();\n\tconst indentStrLen = indentStr.length;\n\tconst indentStart = start - indentStrLen;\n\n\tif (\n\t\t!node.program.indentExclusions[indentStart] &&\n\t\tcode.original.slice(indentStart, start) === indentStr\n\t) {\n\t\tcode.remove(indentStart, start);\n\t}\n\n\tconst pattern = new RegExp(indentStr + '\\\\S', 'g');\n\tconst slice = code.original.slice(start, end);\n\tlet match;\n\n\twhile ((match = pattern.exec(slice))) {\n\t\tconst removeStart = start + match.index;\n\t\tif (!node.program.indentExclusions[removeStart]) {\n\t\t\tcode.remove(removeStart, removeStart + indentStrLen);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport deindent from '../../utils/deindent.js';\n\nexport default class ClassDeclaration extends Node {\n\tinitialise(transforms) {\n\t\tif (this.id) {\n\t\t\tthis.name = this.id.name;\n\t\t\tthis.findScope(true).addDeclaration(this.id, 'class');\n\t\t} else {\n\t\t\tthis.name = this.findScope(true).createIdentifier(\"defaultExport\");\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (transforms.classes) {\n\t\t\tif (!this.superClass) deindent(this.body, code);\n\n\t\t\tconst superName =\n\t\t\t\tthis.superClass && (this.superClass.name || 'superclass');\n\n\t\t\tconst i0 = this.getIndentation();\n\t\t\tconst i1 = i0 + code.getIndentString();\n\n\t\t\t// if this is an export default statement, we have to move the export to\n\t\t\t// after the declaration, because `export default var Foo = ...` is illegal\n\t\t\tconst isExportDefaultDeclaration = this.parent.type === 'ExportDefaultDeclaration';\n\n\t\t\tif (isExportDefaultDeclaration) {\n\t\t\t\tcode.remove(this.parent.start, this.start);\n\t\t\t}\n\n\t\t\tlet c = this.start;\n\t\t\tif (this.id) {\n\t\t\t\tcode.overwrite(c, this.id.start, 'var ');\n\t\t\t\tc = this.id.end;\n\t\t\t} else {\n\t\t\t\tcode.prependLeft(c, `var ${this.name}`);\n\t\t\t}\n\n\t\t\tif (this.superClass) {\n\t\t\t\tif (this.superClass.end === this.body.start) {\n\t\t\t\t\tcode.remove(c, this.superClass.start);\n\t\t\t\t\tcode.appendLeft(c, ` = /*@__PURE__*/(function (${superName}) {\\n${i1}`);\n\t\t\t\t} else {\n\t\t\t\t\tcode.overwrite(c, this.superClass.start, ' = ');\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tthis.superClass.end,\n\t\t\t\t\t\tthis.body.start,\n\t\t\t\t\t\t`/*@__PURE__*/(function (${superName}) {\\n${i1}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c === this.body.start) {\n\t\t\t\t\tcode.appendLeft(c, ' = ');\n\t\t\t\t} else {\n\t\t\t\t\tcode.overwrite(c, this.body.start, ' = ');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.body.transpile(code, transforms, !!this.superClass, superName);\n\n\t\t\tconst syntheticDefaultExport =\n\t\t\t\tisExportDefaultDeclaration\n\t\t\t\t\t? `\\n\\n${i0}export default ${this.name};`\n\t\t\t\t\t: '';\n\t\t\tif (this.superClass) {\n\t\t\t\tcode.appendLeft(this.end, `\\n\\n${i1}return ${this.name};\\n${i0}}(`);\n\t\t\t\tcode.move(this.superClass.start, this.superClass.end, this.end);\n\t\t\t\tcode.prependRight(this.end, `));${syntheticDefaultExport}`);\n\t\t\t} else if (syntheticDefaultExport) {\n\t\t\t\tcode.prependRight(this.end, syntheticDefaultExport);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.body.transpile(code, transforms, false, null);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class ClassExpression extends Node {\n\tinitialise(transforms) {\n\t\tthis.name = (this.id\n\t\t\t? this.id.name\n\t\t\t: this.parent.type === 'VariableDeclarator'\n\t\t\t\t? this.parent.id.name\n\t\t\t\t: this.parent.type !== 'AssignmentExpression'\n\t\t\t\t\t? null\n\t\t\t\t\t: this.parent.left.type === 'Identifier'\n\t\t\t\t\t\t? this.parent.left.name\n\t\t\t\t\t\t: this.parent.left.type === 'MemberExpression'\n\t\t\t\t\t\t\t? this.parent.left.property.name\n\t\t\t\t\t\t\t: null) || this.findScope(true).createIdentifier('anonymous');\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (transforms.classes) {\n\t\t\tlet superName = this.superClass && (this.superClass.name || 'superclass');\n\t\t\tif (superName === this.name) {\n\t\t\t\tsuperName = this.findScope(true).createIdentifier(this.name);\n\t\t\t}\n\n\t\t\tconst i0 = this.getIndentation();\n\t\t\tconst i1 = i0 + code.getIndentString();\n\n\t\t\tif (this.superClass) {\n\t\t\t\tcode.remove(this.start, this.superClass.start);\n\t\t\t\tcode.remove(this.superClass.end, this.body.start);\n\t\t\t\tcode.appendRight(this.start, `/*@__PURE__*/(function (${superName}) {\\n${i1}`);\n\t\t\t} else {\n\t\t\t\tcode.overwrite(this.start, this.body.start, `/*@__PURE__*/(function () {\\n${i1}`);\n\t\t\t}\n\n\t\t\tthis.body.transpile(code, transforms, true, superName);\n\n\t\t\tlet superClass = '';\n\t\t\tif (this.superClass) {\n\t\t\t\tsuperClass = code.slice(this.superClass.start, this.superClass.end);\n\t\t\t\tcode.remove(this.superClass.start, this.superClass.end);\n\t\t\t}\n\t\t\tcode.appendLeft(this.end, `\\n\\n${i1}return ${this.name};\\n${i0}}(${superClass}))`);\n\t\t} else {\n\t\t\tthis.body.transpile(code, transforms, false);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class ContinueStatement extends Node {\n\ttranspile(code) {\n\t\tconst loop = this.findNearest(loopStatement);\n\t\tif (loop.shouldRewriteAsFunction) {\n\t\t\tif (this.label)\n\t\t\t\tthrow new CompileError(\n\t\t\t\t\t'Labels are not currently supported in a loop with locally-scoped variables',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\tcode.overwrite(this.start, this.start + 8, 'return');\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class ExportDefaultDeclaration extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.moduleExport)\n\t\t\tCompileError.missingTransform(\"export\", \"moduleExport\", this);\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class ExportNamedDeclaration extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.moduleExport)\n\t\t\tCompileError.missingTransform(\"export\", \"moduleExport\", this);\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../../Node.js';\n\nexport default class LoopStatement extends Node {\n\tfindScope(functionScope) {\n\t\treturn functionScope || !this.createdScope\n\t\t\t? this.parent.findScope(functionScope)\n\t\t\t: this.body.scope;\n\t}\n\n\tinitialise(transforms) {\n\t\tthis.body.createScope();\n\t\tthis.createdScope = true;\n\n\t\t// this is populated as and when reassignments occur\n\t\tthis.reassigned = Object.create(null);\n\t\tthis.aliases = Object.create(null);\n\n\t\tthis.thisRefs = [];\n\n\t\tsuper.initialise(transforms);\n\t\tif (this.scope) {\n\t\t\tthis.scope.consolidate();\n\t\t}\n\n\t\tconst declarations = Object.assign({}, this.body.scope.declarations);\n\t\tif (this.scope) {\n\t\t\tObject.assign(declarations, this.scope.declarations);\n\t\t}\n\n\t\tif (transforms.letConst) {\n\t\t\t// see if any block-scoped declarations are referenced\n\t\t\t// inside function expressions\n\t\t\tconst names = Object.keys(declarations);\n\n\t\t\tlet i = names.length;\n\t\t\twhile (i--) {\n\t\t\t\tconst name = names[i];\n\t\t\t\tconst declaration = declarations[name];\n\n\t\t\t\tlet j = declaration.instances.length;\n\t\t\t\twhile (j--) {\n\t\t\t\t\tconst instance = declaration.instances[j];\n\t\t\t\t\tconst nearestFunctionExpression = instance.findNearest(/Function/);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tnearestFunctionExpression &&\n\t\t\t\t\t\tnearestFunctionExpression.depth > this.depth\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.shouldRewriteAsFunction = true;\n\t\t\t\t\t\tfor (const node of this.thisRefs) {\n\t\t\t\t\t\t\tnode.alias = node.alias || node.findLexicalBoundary().getThisAlias();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.shouldRewriteAsFunction) break;\n\t\t\t}\n\t\t}\n\t}\n\n\ttranspile(code, transforms) {\n\t\tconst needsBlock =\n\t\t\tthis.type != 'ForOfStatement' &&\n\t\t\t(this.body.type !== 'BlockStatement' ||\n\t\t\t\t(this.body.type === 'BlockStatement' && this.body.synthetic));\n\n\t\tif (this.shouldRewriteAsFunction) {\n\t\t\tconst i0 = this.getIndentation();\n\t\t\tconst i1 = i0 + code.getIndentString();\n\n\t\t\tconst argString = this.args ? ` ${this.args.join(', ')} ` : '';\n\t\t\tconst paramString = this.params ? ` ${this.params.join(', ')} ` : '';\n\n\t\t\tconst functionScope = this.findScope(true);\n\t\t\tconst loop = functionScope.createIdentifier('loop');\n\n\t\t\tconst before =\n\t\t\t\t`var ${loop} = function (${paramString}) ` +\n\t\t\t\t(this.body.synthetic ? `{\\n${i0}${code.getIndentString()}` : '');\n\t\t\tconst after = (this.body.synthetic ? `\\n${i0}}` : '') + `;\\n\\n${i0}`;\n\n\t\t\tcode.prependRight(this.body.start, before);\n\t\t\tcode.appendLeft(this.body.end, after);\n\t\t\tcode.move(this.start, this.body.start, this.body.end);\n\n\t\t\tif (this.canBreak || this.canReturn) {\n\t\t\t\tconst returned = functionScope.createIdentifier('returned');\n\n\t\t\t\tlet insert = `{\\n${i1}var ${returned} = ${loop}(${argString});\\n`;\n\t\t\t\tif (this.canBreak)\n\t\t\t\t\tinsert += `\\n${i1}if ( ${returned} === 'break' ) break;`;\n\t\t\t\tif (this.canReturn)\n\t\t\t\t\tinsert += `\\n${i1}if ( ${returned} ) return ${returned}.v;`;\n\t\t\t\tinsert += `\\n${i0}}`;\n\n\t\t\t\tcode.prependRight(this.body.end, insert);\n\t\t\t} else {\n\t\t\t\tconst callExpression = `${loop}(${argString});`;\n\n\t\t\t\tif (this.type === 'DoWhileStatement') {\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tthis.start,\n\t\t\t\t\t\tthis.body.start,\n\t\t\t\t\t\t`do {\\n${i1}${callExpression}\\n${i0}}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tcode.prependRight(this.body.end, callExpression);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (needsBlock) {\n\t\t\tcode.appendLeft(this.body.start, '{ ');\n\t\t\tcode.prependRight(this.body.end, ' }');\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import LoopStatement from './shared/LoopStatement.js';\nimport extractNames from '../extractNames.js';\nimport Scope from '../Scope.js';\n\nexport default class ForStatement extends LoopStatement {\n\tinitialise(transforms) {\n\t\tthis.createdDeclarations = [];\n\n\t\tthis.scope = new Scope({\n\t\t\tblock: true,\n\t\t\tparent: this.parent.findScope(false),\n\t\t\tdeclare: id => this.createdDeclarations.push(id)\n\t\t});\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\tfindScope(functionScope) {\n\t\treturn functionScope\n\t\t\t? this.parent.findScope(functionScope)\n\t\t\t: this.scope;\n\t}\n\n\ttranspile(code, transforms) {\n\t\tconst i1 = this.getIndentation() + code.getIndentString();\n\n\t\tif (this.shouldRewriteAsFunction) {\n\t\t\t// which variables are declared in the init statement?\n\t\t\tconst names = this.init && this.init.type === 'VariableDeclaration'\n\t\t\t\t? this.init.declarations.map(declarator => extractNames(declarator.id))\n\t\t\t\t: [];\n\n\t\t\tconst aliases = this.aliases;\n\n\t\t\tthis.args = names.map(\n\t\t\t\tname => (name in this.aliases ? this.aliases[name].outer : name)\n\t\t\t);\n\t\t\tthis.params = names.map(\n\t\t\t\tname => (name in this.aliases ? this.aliases[name].inner : name)\n\t\t\t);\n\n\t\t\tconst updates = Object.keys(this.reassigned).map(\n\t\t\t\tname => `${aliases[name].outer} = ${aliases[name].inner};`\n\t\t\t);\n\n\t\t\tif (updates.length) {\n\t\t\t\tif (this.body.synthetic) {\n\t\t\t\t\tcode.appendLeft(this.body.body[0].end, `; ${updates.join(` `)}`);\n\t\t\t\t} else {\n\t\t\t\t\tconst lastStatement = this.body.body[this.body.body.length - 1];\n\t\t\t\t\tcode.appendLeft(\n\t\t\t\t\t\tlastStatement.end,\n\t\t\t\t\t\t`\\n\\n${i1}${updates.join(`\\n${i1}`)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import LoopStatement from './shared/LoopStatement.js';\nimport destructure from '../../utils/destructure.js';\nimport extractNames from '../extractNames.js';\nimport Scope from '../Scope.js';\n\nexport default class ForInStatement extends LoopStatement {\n\tinitialise(transforms) {\n\t\tthis.createdDeclarations = [];\n\n\t\tthis.scope = new Scope({\n\t\t\tblock: true,\n\t\t\tparent: this.parent.findScope(false),\n\t\t\tdeclare: id => this.createdDeclarations.push(id)\n\t\t});\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\tfindScope(functionScope) {\n\t\treturn functionScope\n\t\t\t? this.parent.findScope(functionScope)\n\t\t\t: this.scope;\n\t}\n\n\ttranspile(code, transforms) {\n\t\tconst hasDeclaration = this.left.type === 'VariableDeclaration';\n\n\t\tif (this.shouldRewriteAsFunction) {\n\t\t\t// which variables are declared in the init statement?\n\t\t\tconst names = hasDeclaration\n\t\t\t\t? this.left.declarations.map(declarator => extractNames(declarator.id))\n\t\t\t\t: [];\n\n\t\t\tthis.args = names.map(\n\t\t\t\tname => (name in this.aliases ? this.aliases[name].outer : name)\n\t\t\t);\n\t\t\tthis.params = names.map(\n\t\t\t\tname => (name in this.aliases ? this.aliases[name].inner : name)\n\t\t\t);\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\n\t\tconst maybePattern = hasDeclaration ? this.left.declarations[0].id : this.left;\n\t\tif (maybePattern.type !== 'Identifier' && maybePattern.type !== 'MemberExpression') {\n\t\t\tthis.destructurePattern(code, maybePattern, hasDeclaration);\n\t\t}\n\t}\n\n\tdestructurePattern(code, pattern, isDeclaration) {\n\t\tconst scope = this.findScope(true);\n\t\tconst i0 = this.getIndentation();\n\t\tconst i1 = i0 + code.getIndentString();\n\n\t\tconst ref = scope.createIdentifier('ref');\n\n\t\tconst bodyStart = this.body.body.length ? this.body.body[0].start : this.body.start + 1;\n\n\t\tcode.move(pattern.start, pattern.end, bodyStart);\n\n\t\tcode.prependRight(pattern.end, isDeclaration ? ref : `var ${ref}`);\n\n\t\tconst statementGenerators = [];\n\t\tdestructure(\n\t\t\tcode,\n\t\t\tid => scope.createIdentifier(id),\n\t\t\t({ name }) => scope.resolveName(name),\n\t\t\tpattern,\n\t\t\tref,\n\t\t\tfalse,\n\t\t\tstatementGenerators\n\t\t);\n\n\t\tlet suffix = `;\\n${i1}`;\n\t\tstatementGenerators.forEach((fn, i) => {\n\t\t\tif (i === statementGenerators.length - 1) {\n\t\t\t\tsuffix = `;\\n\\n${i1}`;\n\t\t\t}\n\n\t\t\tfn(bodyStart, '', suffix);\n\t\t});\n\t}\n}\n","import LoopStatement from './shared/LoopStatement.js';\nimport CompileError from '../../utils/CompileError.js';\nimport destructure from '../../utils/destructure.js';\nimport Scope from '../Scope.js';\n\nexport default class ForOfStatement extends LoopStatement {\n\tinitialise(transforms) {\n\t\tif (transforms.forOf && !transforms.dangerousForOf)\n\t\t\tCompileError.missingTransform(\"for-of statements\", \"forOf\", this, \"dangerousForOf\");\n\t\tif (this.await && transforms.asyncAwait)\n\t\t\tCompileError.missingTransform(\"for-await-of statements\", \"asyncAwait\", this);\n\n\t\tthis.createdDeclarations = [];\n\n\t\tthis.scope = new Scope({\n\t\t\tblock: true,\n\t\t\tparent: this.parent.findScope(false),\n\t\t\tdeclare: id => this.createdDeclarations.push(id)\n\t\t});\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\tfindScope(functionScope) {\n\t\treturn functionScope\n\t\t\t? this.parent.findScope(functionScope)\n\t\t\t: this.scope;\n\t}\n\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\t\tif (!transforms.dangerousForOf) return;\n\n\t\t// edge case (#80)\n\t\tif (!this.body.body[0]) {\n\t\t\tif (\n\t\t\t\tthis.left.type === 'VariableDeclaration' &&\n\t\t\t\tthis.left.kind === 'var'\n\t\t\t) {\n\t\t\t\tcode.remove(this.start, this.left.start);\n\t\t\t\tcode.appendLeft(this.left.end, ';');\n\t\t\t\tcode.remove(this.left.end, this.end);\n\t\t\t} else {\n\t\t\t\tcode.remove(this.start, this.end);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst scope = this.findScope(true);\n\t\tconst i0 = this.getIndentation();\n\t\tconst i1 = i0 + code.getIndentString();\n\n\t\tconst key = scope.createIdentifier('i');\n\t\tconst list = scope.createIdentifier('list');\n\n\t\tif (this.body.synthetic) {\n\t\t\tcode.prependRight(this.left.start, `{\\n${i1}`);\n\t\t\tcode.appendLeft(this.body.body[0].end, `\\n${i0}}`);\n\t\t}\n\n\t\tconst bodyStart = this.body.body[0].start;\n\n\t\tcode.remove(this.left.end, this.right.start);\n\t\tcode.move(this.left.start, this.left.end, bodyStart);\n\n\t\tcode.prependRight(this.right.start, `var ${key} = 0, ${list} = `);\n\t\tcode.appendLeft(this.right.end, `; ${key} < ${list}.length; ${key} += 1`);\n\n\t\tconst isDeclaration = this.left.type === 'VariableDeclaration';\n\t\tconst maybeDestructuring = isDeclaration ? this.left.declarations[0].id : this.left;\n\t\tif (maybeDestructuring.type !== 'Identifier') {\n\t\t\tconst statementGenerators = [];\n\t\t\tconst ref = scope.createIdentifier('ref');\n\t\t\tdestructure(\n\t\t\t\tcode,\n\t\t\t\tid => scope.createIdentifier(id),\n\t\t\t\t({ name }) => scope.resolveName(name),\n\t\t\t\tmaybeDestructuring,\n\t\t\t\tref,\n\t\t\t\t!isDeclaration,\n\t\t\t\tstatementGenerators\n\t\t\t);\n\n\t\t\tlet suffix = `;\\n${i1}`;\n\t\t\tstatementGenerators.forEach((fn, i) => {\n\t\t\t\tif (i === statementGenerators.length - 1) {\n\t\t\t\t\tsuffix = `;\\n\\n${i1}`;\n\t\t\t\t}\n\n\t\t\t\tfn(bodyStart, '', suffix);\n\t\t\t});\n\n\t\t\tif (isDeclaration) {\n\t\t\t\tcode.appendLeft(this.left.start + this.left.kind.length + 1, ref);\n\t\t\t\tcode.appendLeft(this.left.end, ` = ${list}[${key}];\\n${i1}`);\n\t\t\t} else {\n\t\t\t\tcode.appendLeft(this.left.end, `var ${ref} = ${list}[${key}];\\n${i1}`);\n\t\t\t}\n\t\t} else {\n\t\t\tcode.appendLeft(this.left.end, ` = ${list}[${key}];\\n\\n${i1}`);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport removeTrailingComma from '../../utils/removeTrailingComma.js';\n\nexport default class FunctionDeclaration extends Node {\n\tinitialise(transforms) {\n\t\tif (this.generator && transforms.generator) {\n\t\t\tCompileError.missingTransform(\"generators\", \"generator\", this);\n\t\t}\n\t\tif (this.async && transforms.asyncAwait) {\n\t\t\tCompileError.missingTransform(\"async functions\", \"asyncAwait\", this);\n\t\t}\n\n\t\tthis.body.createScope();\n\n\t\tif (this.id) {\n\t\t\tthis.findScope(true).addDeclaration(this.id, 'function');\n\t\t}\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\t\tif (transforms.trailingFunctionCommas && this.params.length) {\n\t\t\tremoveTrailingComma(code, this.params[this.params.length - 1].end);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport removeTrailingComma from '../../utils/removeTrailingComma.js';\n\nexport default class FunctionExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (this.generator && transforms.generator) {\n\t\t\tCompileError.missingTransform(\"generators\", \"generator\", this);\n\t\t}\n\t\tif (this.async && transforms.asyncAwait) {\n\t\t\tCompileError.missingTransform(\"async functions\", \"asyncAwait\", this);\n\t\t}\n\n\t\tthis.body.createScope();\n\n\t\tif (this.id) {\n\t\t\t// function expression IDs belong to the child scope...\n\t\t\tthis.body.scope.addDeclaration(this.id, 'function');\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\n\t\tconst parent = this.parent;\n\t\tlet methodName;\n\n\t\tif (\n\t\t\ttransforms.conciseMethodProperty &&\n\t\t\tparent.type === 'Property' &&\n\t\t\tparent.kind === 'init' &&\n\t\t\tparent.method &&\n\t\t\tparent.key.type === 'Identifier'\n\t\t) {\n\t\t\t// object literal concise method\n\t\t\tmethodName = parent.key.name;\n\t\t} else if (\n\t\t\ttransforms.classes &&\n\t\t\tparent.type === 'MethodDefinition' &&\n\t\t\tparent.kind === 'method' &&\n\t\t\tparent.key.type === 'Identifier'\n\t\t) {\n\t\t\t// method definition in a class\n\t\t\tmethodName = parent.key.name;\n\t\t} else if (this.id && this.id.type === 'Identifier') {\n\t\t\t// naked function expression\n\t\t\tmethodName = this.id.alias || this.id.name;\n\t\t}\n\n\t\tif (methodName) {\n\t\t\tfor (const param of this.params) {\n\t\t\t\tif (param.type === 'Identifier' && methodName === param.name) {\n\t\t\t\t\t// workaround for Safari 9/WebKit bug:\n\t\t\t\t\t// https://gitlab.com/Rich-Harris/buble/issues/154\n\t\t\t\t\t// change parameter name when same as method name\n\n\t\t\t\t\tconst scope = this.body.scope;\n\t\t\t\t\tconst declaration = scope.declarations[methodName];\n\n\t\t\t\t\tconst alias = scope.createIdentifier(methodName);\n\t\t\t\t\tparam.alias = alias;\n\n\t\t\t\t\tfor (const identifier of declaration.instances) {\n\t\t\t\t\t\tidentifier.alias = alias;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\t\tif (transforms.trailingFunctionCommas && this.params.length) {\n\t\t\tremoveTrailingComma(code, this.params[this.params.length - 1].end);\n\t\t}\n\t}\n}\n","export default function isReference(node, parent) {\n\tif (node.type === 'MemberExpression') {\n\t\treturn !node.computed && isReference(node.object, node);\n\t}\n\n\tif (node.type === 'Identifier') {\n\t\t// the only time we could have an identifier node without a parent is\n\t\t// if it's the entire body of a function without a block statement –\n\t\t// i.e. an arrow function expression like `a => a`\n\t\tif (!parent) return true;\n\n\t\tif (/(Function|Class)Expression/.test(parent.type)) return false;\n\n\t\tif (parent.type === 'VariableDeclarator') return node === parent.init;\n\n\t\t// TODO is this right?\n\t\tif (\n\t\t\tparent.type === 'MemberExpression' ||\n\t\t\tparent.type === 'MethodDefinition'\n\t\t) {\n\t\t\treturn parent.computed || node === parent.object;\n\t\t}\n\n\t\tif (parent.type === 'ArrayPattern') return false;\n\n\t\t// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`\n\t\tif (parent.type === 'Property') {\n\t\t\tif (parent.parent.type === 'ObjectPattern') return false;\n\t\t\treturn parent.computed || node === parent.value;\n\t\t}\n\n\t\t// disregard the `bar` in `class Foo { bar () {...} }`\n\t\tif (parent.type === 'MethodDefinition') return false;\n\n\t\t// disregard the `bar` in `export { foo as bar }`\n\t\tif (parent.type === 'ExportSpecifier' && node !== parent.local)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n}\n","import Node from '../Node.js';\nimport isReference from '../../utils/isReference.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class Identifier extends Node {\n\tfindScope(functionScope) {\n\t\tif (this.parent.params && ~this.parent.params.indexOf(this)) {\n\t\t\treturn this.parent.body.scope;\n\t\t}\n\n\t\tif (this.parent.type === 'FunctionExpression' && this === this.parent.id) {\n\t\t\treturn this.parent.body.scope;\n\t\t}\n\n\t\treturn this.parent.findScope(functionScope);\n\t}\n\n\tinitialise(transforms) {\n\t\tif (this.isLabel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isReference(this, this.parent)) {\n\t\t\tif (\n\t\t\t\ttransforms.arrow &&\n\t\t\t\tthis.name === 'arguments' &&\n\t\t\t\t!this.findScope(false).contains(this.name)\n\t\t\t) {\n\t\t\t\tconst lexicalBoundary = this.findLexicalBoundary();\n\t\t\t\tconst arrowFunction = this.findNearest('ArrowFunctionExpression');\n\t\t\t\tconst loop = this.findNearest(loopStatement);\n\n\t\t\t\tif (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {\n\t\t\t\t\tthis.alias = lexicalBoundary.getArgumentsAlias();\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tloop &&\n\t\t\t\t\tloop.body.contains(this) &&\n\t\t\t\t\tloop.depth > lexicalBoundary.depth\n\t\t\t\t) {\n\t\t\t\t\tthis.alias = lexicalBoundary.getArgumentsAlias();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.findScope(false).addReference(this);\n\t\t}\n\t}\n\n\tisLabel() {\n\t\tswitch (this.parent.type) {\n\t\t\tcase 'BreakStatement': return true;\n\t\t\tcase 'ContinueStatement': return true;\n\t\t\tcase 'LabeledStatement': return true;\n\t\t\tdefault: return false;\n\t\t}\n\t}\n\n\ttranspile(code) {\n\t\tif (this.alias) {\n\t\t\tcode.overwrite(this.start, this.end, this.alias, {\n\t\t\t\tstoreName: true,\n\t\t\t\tcontentOnly: true\n\t\t\t});\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class IfStatement extends Node {\n\tinitialise(transforms) {\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (\n\t\t\tthis.consequent.type !== 'BlockStatement' ||\n\t\t\t(this.consequent.type === 'BlockStatement' && this.consequent.synthetic)\n\t\t) {\n\t\t\tcode.appendLeft(this.consequent.start, '{ ');\n\t\t\tcode.prependRight(this.consequent.end, ' }');\n\t\t}\n\n\t\tif (\n\t\t\tthis.alternate &&\n\t\t\tthis.alternate.type !== 'IfStatement' &&\n\t\t\t(this.alternate.type !== 'BlockStatement' ||\n\t\t\t\t(this.alternate.type === 'BlockStatement' && this.alternate.synthetic))\n\t\t) {\n\t\t\tcode.appendLeft(this.alternate.start, '{ ');\n\t\t\tcode.prependRight(this.alternate.end, ' }');\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class Import extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.moduleImport) {\n\t\t\tCompileError.missingTransform(\"dynamic import expressions\", \"moduleImport\", this);\n\t\t}\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class ImportDeclaration extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.moduleImport)\n\t\t\tCompileError.missingTransform(\"import\", \"moduleImport\", this);\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class ImportDefaultSpecifier extends Node {\n\tinitialise(transforms) {\n\t\tthis.findScope(true).addDeclaration(this.local, 'import');\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class ImportSpecifier extends Node {\n\tinitialise(transforms) {\n\t\tthis.findScope(true).addDeclaration(this.local, 'import');\n\t\tsuper.initialise(transforms);\n\t}\n}\n","import Node from '../Node.js';\n\nconst hasDashes = val => /-/.test(val);\n\nconst formatKey = key => (hasDashes(key) ? `'${key}'` : key);\n\nconst formatVal = val => (val ? '' : 'true');\n\nexport default class JSXAttribute extends Node {\n\ttranspile(code, transforms) {\n\t\tconst { start, name } = this.name;\n\n\t\t// Overwrite equals sign if value is present.\n\t\tconst end = this.value ? this.value.start : this.name.end;\n\n\t\tcode.overwrite(start, end, `${formatKey(name)}: ${formatVal(this.value)}`);\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\n\nfunction containsNewLine(node) {\n\treturn (\n\t\tnode.type === 'JSXText' && !/\\S/.test(node.value) && /\\n/.test(node.value)\n\t);\n}\n\nexport default class JSXClosingElement extends Node {\n\ttranspile(code) {\n\t\tlet spaceBeforeParen = true;\n\n\t\tconst lastChild = this.parent.children[this.parent.children.length - 1];\n\n\t\t// omit space before closing paren if\n\t\t//   a) this is on a separate line, or\n\t\t//   b) there are no children but there are attributes\n\t\tif (\n\t\t\t(lastChild && containsNewLine(lastChild)) ||\n\t\t\tthis.parent.openingElement.attributes.length\n\t\t) {\n\t\t\tspaceBeforeParen = false;\n\t\t}\n\n\t\tcode.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');\n\t}\n}\n","import Node from '../Node.js';\n\nfunction containsNewLine(node) {\n\treturn (\n\t\tnode.type === 'JSXText' && !/\\S/.test(node.value) && /\\n/.test(node.value)\n\t);\n}\n\nexport default class JSXClosingFragment extends Node {\n\ttranspile(code) {\n\t\tlet spaceBeforeParen = true;\n\n\t\tconst lastChild = this.parent.children[this.parent.children.length - 1];\n\n\t\t// omit space before closing paren if this is on a separate line\n\t\tif (lastChild && containsNewLine(lastChild)) {\n\t\t\tspaceBeforeParen = false;\n\t\t}\n\n\t\tcode.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');\n\t}\n}\n","import Node from '../Node.js';\n\nfunction normalise(str, removeTrailingWhitespace) {\n\n\tif (removeTrailingWhitespace && /\\n/.test(str)) {\n\t\tstr = str.replace(/[ \\f\\n\\r\\t\\v]+$/, '');\n\t}\n\n\tstr = str\n\t\t.replace(/^\\n\\r?[ \\f\\n\\r\\t\\v]+/, '') // remove leading newline + space\n\t\t.replace(/[ \\f\\n\\r\\t\\v]*\\n\\r?[ \\f\\n\\r\\t\\v]*/gm, ' '); // replace newlines with spaces\n\n\t// TODO prefer single quotes?\n\treturn JSON.stringify(str);\n}\n\nexport default class JSXElement extends Node {\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tconst children = this.children.filter(child => {\n\t\t\tif (child.type !== 'JSXText') return true;\n\n\t\t\t// remove whitespace-only literals, unless on a single line\n\t\t\treturn /[^ \\f\\n\\r\\t\\v]/.test(child.raw) || !/\\n/.test(child.raw);\n\t\t});\n\n\t\tif (children.length) {\n\t\t\tlet c = (this.openingElement || this.openingFragment).end;\n\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < children.length; i += 1) {\n\t\t\t\tconst child = children[i];\n\n\t\t\t\tif (\n\t\t\t\t\tchild.type === 'JSXExpressionContainer' &&\n\t\t\t\t\tchild.expression.type === 'JSXEmptyExpression'\n\t\t\t\t) {\n\t\t\t\t\t// empty block is a no op\n\t\t\t\t} else {\n\t\t\t\t\tconst tail =\n\t\t\t\t\t\tcode.original[c] === '\\n' && child.type !== 'JSXText' ? '' : ' ';\n\t\t\t\t\tcode.appendLeft(c, `,${tail}`);\n\t\t\t\t}\n\n\t\t\t\tif (child.type === 'JSXText') {\n\t\t\t\t\tconst str = normalise(child.value, i === children.length - 1);\n\t\t\t\t\tcode.overwrite(child.start, child.end, str);\n\t\t\t\t}\n\n\t\t\t\tc = child.end;\n\t\t\t}\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class JSXExpressionContainer extends Node {\n\ttranspile(code, transforms) {\n\t\tcode.remove(this.start, this.expression.start);\n\t\tcode.remove(this.expression.end, this.end);\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import JSXElement from './JSXElement.js';\n\nexport default class JSXFragment extends JSXElement {\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class JSXOpeningElement extends Node {\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tcode.overwrite(this.start, this.name.start, `${this.program.jsx}( `);\n\n\t\tconst html =\n\t\t\tthis.name.type === 'JSXIdentifier' &&\n\t\t\tthis.name.name[0] === this.name.name[0].toLowerCase();\n\t\tif (html) code.prependRight(this.name.start, `'`);\n\n\t\tconst len = this.attributes.length;\n\t\tlet c = this.name.end;\n\n\t\tif (len) {\n\t\t\tlet i;\n\n\t\t\tlet hasSpread = false;\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tif (this.attributes[i].type === 'JSXSpreadAttribute') {\n\t\t\t\t\thasSpread = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = this.attributes[0].end;\n\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tconst attr = this.attributes[i];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tif (attr.start === c) code.prependRight(c, ', ');\n\t\t\t\t\telse code.overwrite(c, attr.start, ', ');\n\t\t\t\t}\n\n\t\t\t\tif (hasSpread && attr.type !== 'JSXSpreadAttribute') {\n\t\t\t\t\tconst lastAttr = this.attributes[i - 1];\n\t\t\t\t\tconst nextAttr = this.attributes[i + 1];\n\n\t\t\t\t\tif (!lastAttr || lastAttr.type === 'JSXSpreadAttribute') {\n\t\t\t\t\t\tcode.prependRight(attr.start, '{ ');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextAttr || nextAttr.type === 'JSXSpreadAttribute') {\n\t\t\t\t\t\tcode.appendLeft(attr.end, ' }');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tc = attr.end;\n\t\t\t}\n\n\t\t\tlet after;\n\t\t\tlet before;\n\t\t\tif (hasSpread) {\n\t\t\t\tif (len === 1) {\n\t\t\t\t\tbefore = html ? `',` : ',';\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.program.options.objectAssign) {\n\t\t\t\t\t\tthrow new CompileError(\n\t\t\t\t\t\t\t\"Mixed JSX attributes ending in spread requires specified objectAssign option with 'Object.assign' or polyfill helper.\",\n\t\t\t\t\t\t\tthis\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbefore = html\n\t\t\t\t\t\t? `', ${this.program.options.objectAssign}({},`\n\t\t\t\t\t\t: `, ${this.program.options.objectAssign}({},`;\n\t\t\t\t\tafter = ')';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbefore = html ? `', {` : ', {';\n\t\t\t\tafter = ' }';\n\t\t\t}\n\n\t\t\tcode.prependRight(this.name.end, before);\n\n\t\t\tif (after) {\n\t\t\t\tcode.appendLeft(this.attributes[len - 1].end, after);\n\t\t\t}\n\t\t} else {\n\t\t\tcode.appendLeft(this.name.end, html ? `', null` : `, null`);\n\t\t\tc = this.name.end;\n\t\t}\n\n\t\tif (this.selfClosing) {\n\t\t\tcode.overwrite(c, this.end, this.attributes.length ? `)` : ` )`);\n\t\t} else {\n\t\t\tcode.remove(c, this.end);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class JSXOpeningFragment extends Node {\n\ttranspile(code) {\n\t\tcode.overwrite(this.start, this.end, `${this.program.jsx}( ${this.program.jsxFragment}, null`);\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class JSXSpreadAttribute extends Node {\n\ttranspile(code, transforms) {\n\t\tcode.remove(this.start, this.argument.start);\n\t\tcode.remove(this.argument.end, this.end);\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport rewritePattern from 'regexpu-core';\n\nconst nonAsciiLsOrPs = /[\\u2028-\\u2029]/g;\n\nexport default class Literal extends Node {\n\tinitialise() {\n\t\tif (typeof this.value === 'string') {\n\t\t\tthis.program.indentExclusionElements.push(this);\n\t\t}\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (transforms.numericLiteral) {\n\t\t\tif (this.raw.match(/^0[bo]/i)) {\n\t\t\t\tcode.overwrite(this.start, this.end, String(this.value), {\n\t\t\t\t\tstoreName: true,\n\t\t\t\t\tcontentOnly: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (this.regex) {\n\t\t\tconst { pattern, flags } = this.regex;\n\n\t\t\tif (transforms.stickyRegExp && /y/.test(flags))\n\t\t\t\tCompileError.missingTransform('the regular expression sticky flag', 'stickyRegExp', this);\n\t\t\tif (transforms.unicodeRegExp && /u/.test(flags)) {\n\t\t\t\tcode.overwrite(\n\t\t\t\t\tthis.start,\n\t\t\t\t\tthis.end,\n\t\t\t\t\t`/${rewritePattern(pattern, flags)}/${flags.replace('u', '')}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tcontentOnly: true\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (typeof this.value === \"string\" && this.value.match(nonAsciiLsOrPs)) {\n\t\t\tcode.overwrite(\n\t\t\t\tthis.start,\n\t\t\t\tthis.end,\n\t\t\t\tthis.raw.replace(nonAsciiLsOrPs, m => m == '\\u2028' ? '\\\\u2028' : '\\\\u2029'),\n\t\t\t\t{\n\t\t\t\t\tcontentOnly: true\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport reserved from '../../utils/reserved.js';\n\nexport default class MemberExpression extends Node {\n\ttranspile(code, transforms) {\n\t\tif (transforms.reservedProperties && reserved[this.property.name]) {\n\t\t\tcode.overwrite(this.object.end, this.property.start, `['`);\n\t\t\tcode.appendLeft(this.property.end, `']`);\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport spread, { isArguments, inlineSpreads } from '../../utils/spread.js';\nimport removeTrailingComma from '../../utils/removeTrailingComma.js';\n\nexport default class NewExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.spreadRest && this.arguments.length) {\n\t\t\tconst lexicalBoundary = this.findLexicalBoundary();\n\n\t\t\tlet i = this.arguments.length;\n\t\t\twhile (i--) {\n\t\t\t\tconst arg = this.arguments[i];\n\t\t\t\tif (arg.type === 'SpreadElement' && isArguments(arg.argument)) {\n\t\t\t\t\tthis.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tif (transforms.spreadRest && this.arguments.length) {\n\t\t\tinlineSpreads(code, this, this.arguments);\n\t\t\t// this.arguments.length may have changed, must retest.\n\t\t}\n\n\t\tif (transforms.spreadRest && this.arguments.length) {\n\t\t\tconst firstArgument = this.arguments[0];\n\t\t\tconst isNew = true;\n\t\t\tconst hasSpreadElements = spread(\n\t\t\t\tcode,\n\t\t\t\tthis.arguments,\n\t\t\t\tfirstArgument.start,\n\t\t\t\tthis.argumentsArrayAlias,\n\t\t\t\tisNew\n\t\t\t);\n\n\t\t\tif (hasSpreadElements) {\n\t\t\t\tcode.prependRight(\n\t\t\t\t\tthis.start + 'new'.length,\n\t\t\t\t\t' (Function.prototype.bind.apply('\n\t\t\t\t);\n\t\t\t\tcode.overwrite(\n\t\t\t\t\tthis.callee.end,\n\t\t\t\t\tfirstArgument.start,\n\t\t\t\t\t', [ null ].concat( '\n\t\t\t\t);\n\t\t\t\tcode.appendLeft(this.end, ' ))');\n\t\t\t}\n\t\t}\n\n\t\tif (this.arguments.length) {\n\t\t\tremoveTrailingComma(code, this.arguments[this.arguments.length - 1].end);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class ObjectExpression extends Node {\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tlet firstPropertyStart = this.start + 1;\n\t\tlet spreadPropertyCount = 0;\n\t\tlet computedPropertyCount = 0;\n\t\tlet firstSpreadProperty = null;\n\t\tlet firstComputedProperty = null;\n\n\t\tfor (let i = 0; i < this.properties.length; ++i) {\n\t\t\tconst prop = this.properties[i];\n\t\t\tif (prop.type === 'SpreadElement') {\n\t\t\t\t// First see if we can inline the spread, to save needing objectAssign.\n\t\t\t\tconst argument = prop.argument;\n\t\t\t\tif (\n\t\t\t\t\targument.type === 'ObjectExpression' || (\n\t\t\t\t\t\targument.type === 'Literal' &&\n\t\t\t\t\t\ttypeof argument.value !== 'string'\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tif (argument.type === 'ObjectExpression' && argument.properties.length > 0) {\n\t\t\t\t\t\t// Strip the `...{` and the `}` with a possible trailing comma before it,\n\t\t\t\t\t\t// leaving just the possible trailing comma after it.\n\t\t\t\t\t\tcode.remove(prop.start, argument.properties[0].start);\n\t\t\t\t\t\tcode.remove(argument.properties[argument.properties.length - 1].end, prop.end);\n\t\t\t\t\t\tthis.properties.splice(i, 1, ...argument.properties);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// An empty object, boolean, null, undefined, number or regexp (but NOT\n\t\t\t\t\t\t// string) will spread to nothing, so just remove the element altogether,\n\t\t\t\t\t\t// including a possible trailing comma.\n\t\t\t\t\t\tcode.remove(prop.start, i === this.properties.length - 1\n\t\t\t\t\t\t\t? prop.end\n\t\t\t\t\t\t\t: this.properties[i + 1].start);\n\t\t\t\t\t\tthis.properties.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tspreadPropertyCount += 1;\n\t\t\t\t\tif (firstSpreadProperty === null) firstSpreadProperty = i;\n\t\t\t\t}\n\t\t\t} else if (prop.computed && transforms.computedProperty) {\n\t\t\t\tcomputedPropertyCount += 1;\n\t\t\t\tif (firstComputedProperty === null) firstComputedProperty = i;\n\t\t\t}\n\t\t}\n\n\t\tif (spreadPropertyCount && !transforms.objectRestSpread && !(computedPropertyCount && transforms.computedProperty)) {\n\t\t\tspreadPropertyCount = 0;\n\t\t\tfirstSpreadProperty = null;\n\t\t} else if (spreadPropertyCount) {\n\t\t\tif (!this.program.options.objectAssign) {\n\t\t\t\tthrow new CompileError(\n\t\t\t\t\t\"Object spread operator requires specified objectAssign option with 'Object.assign' or polyfill helper.\",\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\t\t\tlet i = this.properties.length;\n\t\t\twhile (i--) {\n\t\t\t\tconst prop = this.properties[i];\n\n\t\t\t\t// enclose run of non-spread properties in curlies\n\t\t\t\tif (prop.type === 'Property' && !computedPropertyCount) {\n\t\t\t\t\tconst lastProp = this.properties[i - 1];\n\t\t\t\t\tconst nextProp = this.properties[i + 1];\n\n\t\t\t\t\tif (!lastProp || lastProp.type !== 'Property') {\n\t\t\t\t\t\tcode.prependRight(prop.start, '{');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextProp || nextProp.type !== 'Property') {\n\t\t\t\t\t\tcode.appendLeft(prop.end, '}');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove ellipsis on spread property\n\t\t\t\tif (prop.type === 'SpreadElement') {\n\t\t\t\t\tcode.remove(prop.start, prop.argument.start);\n\t\t\t\t\tcode.remove(prop.argument.end, prop.end);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// wrap the whole thing in Object.assign\n\t\t\tfirstPropertyStart = this.properties[0].start;\n\t\t\tif (!computedPropertyCount) {\n\t\t\t\tcode.overwrite(\n\t\t\t\t\tthis.start,\n\t\t\t\t\tfirstPropertyStart,\n\t\t\t\t\t`${this.program.options.objectAssign}({}, `\n\t\t\t\t);\n\t\t\t\tcode.overwrite(\n\t\t\t\t\tthis.properties[this.properties.length - 1].end,\n\t\t\t\t\tthis.end,\n\t\t\t\t\t')'\n\t\t\t\t);\n\t\t\t} else if (this.properties[0].type === 'SpreadElement') {\n\t\t\t\tcode.overwrite(\n\t\t\t\t\tthis.start,\n\t\t\t\t\tfirstPropertyStart,\n\t\t\t\t\t`${this.program.options.objectAssign}({}, `\n\t\t\t\t);\n\t\t\t\tcode.remove(this.end - 1, this.end);\n\t\t\t\tcode.appendRight(this.end, ')');\n\t\t\t} else {\n\t\t\t\tcode.prependLeft(this.start, `${this.program.options.objectAssign}(`);\n\t\t\t\tcode.appendRight(this.end, ')');\n\t\t\t}\n\t\t}\n\n\t\tif (computedPropertyCount && transforms.computedProperty) {\n\t\t\tconst i0 = this.getIndentation();\n\n\t\t\tlet isSimpleAssignment;\n\t\t\tlet name;\n\n\t\t\tif (\n\t\t\t\tthis.parent.type === 'VariableDeclarator' &&\n\t\t\t\tthis.parent.parent.declarations.length === 1 &&\n\t\t\t\tthis.parent.id.type === 'Identifier'\n\t\t\t) {\n\t\t\t\tisSimpleAssignment = true;\n\t\t\t\tname = this.parent.id.alias || this.parent.id.name; // TODO is this right?\n\t\t\t} else if (\n\t\t\t\tthis.parent.type === 'AssignmentExpression' &&\n\t\t\t\tthis.parent.parent.type === 'ExpressionStatement' &&\n\t\t\t\tthis.parent.left.type === 'Identifier'\n\t\t\t) {\n\t\t\t\tisSimpleAssignment = true;\n\t\t\t\tname = this.parent.left.alias || this.parent.left.name; // TODO is this right?\n\t\t\t} else if (\n\t\t\t\tthis.parent.type === 'AssignmentPattern' &&\n\t\t\t\tthis.parent.left.type === 'Identifier'\n\t\t\t) {\n\t\t\t\tisSimpleAssignment = true;\n\t\t\t\tname = this.parent.left.alias || this.parent.left.name; // TODO is this right?\n\t\t\t}\n\n\t\t\tif (spreadPropertyCount) isSimpleAssignment = false;\n\n\t\t\t// handle block scoping\n\t\t\tname = this.findScope(false).resolveName(name);\n\n\t\t\tconst start = firstPropertyStart;\n\t\t\tconst end = this.end;\n\n\t\t\tif (isSimpleAssignment) {\n\t\t\t\t// ???\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tfirstSpreadProperty === null ||\n\t\t\t\t\tfirstComputedProperty < firstSpreadProperty\n\t\t\t\t) {\n\t\t\t\t\tname = this.findScope(true).createDeclaration('obj');\n\n\t\t\t\t\tcode.prependRight(this.start, `( ${name} = `);\n\t\t\t\t} else name = null; // We don't actually need this variable\n\t\t\t}\n\n\t\t\tconst len = this.properties.length;\n\t\t\tlet lastComputedProp;\n\t\t\tlet sawNonComputedProperty = false;\n\t\t\tlet isFirst = true;\n\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tconst prop = this.properties[i];\n\t\t\t\tlet moveStart = i > 0 ? this.properties[i - 1].end : start;\n\n\t\t\t\tif (\n\t\t\t\t\tprop.type === 'Property' &&\n\t\t\t\t\t(prop.computed || (lastComputedProp && !spreadPropertyCount))\n\t\t\t\t) {\n\t\t\t\t\tif (i === 0) moveStart = this.start + 1; // Trim leading whitespace\n\t\t\t\t\tlastComputedProp = prop;\n\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\tname = this.findScope(true).createDeclaration('obj');\n\n\t\t\t\t\t\tconst propId = name + (prop.computed ? '' : '.');\n\t\t\t\t\t\tcode.appendRight(prop.start, `( ${name} = {}, ${propId}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst propId =\n\t\t\t\t\t\t\t(isSimpleAssignment ? `;\\n${i0}${name}` : `, ${name}`) +\n\t\t\t\t\t\t\t(prop.key.type === 'Literal' || prop.computed ? '' : '.');\n\n\t\t\t\t\t\tif (moveStart < prop.start) {\n\t\t\t\t\t\t\tcode.overwrite(moveStart, prop.start, propId);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode.prependRight(prop.start, propId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet c = prop.key.end;\n\t\t\t\t\tif (prop.computed) {\n\t\t\t\t\t\twhile (code.original[c] !== ']') c += 1;\n\t\t\t\t\t\tc += 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (prop.key.type === 'Literal' && !prop.computed) {\n\t\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\t\tprop.start,\n\t\t\t\t\t\t\tprop.value.start,\n\t\t\t\t\t\t\t'[' + code.slice(prop.start, prop.key.end) + '] = '\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (prop.shorthand || (prop.method && !prop.computed && transforms.conciseMethodProperty)) {\n\t\t\t\t\t\t// Replace : with = if Property::transpile inserted the :\n\t\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\t\tprop.key.start,\n\t\t\t\t\t\t\tprop.key.end,\n\t\t\t\t\t\t\tcode.slice(prop.key.start, prop.key.end).replace(/:/, ' =')\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (prop.value.start > c) code.remove(c, prop.value.start);\n\t\t\t\t\t\tcode.prependLeft(c, ' = ');\n\t\t\t\t\t}\n\n\t\t\t\t\t// This duplicates behavior from Property::transpile which is disabled\n\t\t\t\t\t// for computed properties or if conciseMethodProperty is false\n\t\t\t\t\tif (prop.method && (prop.computed || !transforms.conciseMethodProperty)) {\n\t\t\t\t\t\tif (prop.value.generator) code.remove(prop.start, prop.key.start);\n\t\t\t\t\t\tcode.prependRight(prop.value.start, `function${prop.value.generator ? '*' : ''} `);\n\t\t\t\t\t}\n\t\t\t\t} else if (prop.type === 'SpreadElement') {\n\t\t\t\t\tif (name && i > 0) {\n\t\t\t\t\t\tif (!lastComputedProp) {\n\t\t\t\t\t\t\tlastComputedProp = this.properties[i - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcode.appendLeft(lastComputedProp.end, `, ${name} )`);\n\n\t\t\t\t\t\tlastComputedProp = null;\n\t\t\t\t\t\tname = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!isFirst && spreadPropertyCount) {\n\t\t\t\t\t\t// We are in an Object.assign context, so we need to wrap regular properties\n\t\t\t\t\t\tcode.prependRight(prop.start, '{');\n\t\t\t\t\t\tcode.appendLeft(prop.end, '}');\n\t\t\t\t\t}\n\t\t\t\t\tsawNonComputedProperty = true;\n\t\t\t\t}\n\t\t\t\tif (isFirst && (prop.type === 'SpreadElement' || prop.computed)) {\n\t\t\t\t\tlet beginEnd = sawNonComputedProperty\n\t\t\t\t\t\t? this.properties[this.properties.length - 1].end\n\t\t\t\t\t\t: this.end - 1;\n\t\t\t\t\t// Trim trailing comma because it can easily become a leading comma which is illegal\n\t\t\t\t\tif (code.original[beginEnd] == ',') ++beginEnd;\n\t\t\t\t\tconst closing = code.slice(beginEnd, end);\n\t\t\t\t\tcode.prependLeft(moveStart, closing);\n\t\t\t\t\tcode.remove(beginEnd, end);\n\t\t\t\t\tisFirst = false;\n\t\t\t\t}\n\n\t\t\t\t// Clean up some extranous whitespace\n\t\t\t\tlet c = prop.end;\n\t\t\t\tif (i < len - 1 && !sawNonComputedProperty) {\n\t\t\t\t\twhile (code.original[c] !== ',') c += 1;\n\t\t\t\t} else if (i == len - 1) c = this.end;\n\t\t\t\tif (prop.end != c) code.overwrite(prop.end, c, '', {contentOnly: true});\n\t\t\t}\n\n\t\t\tif (!isSimpleAssignment && name) {\n\t\t\t\tcode.appendLeft(lastComputedProp.end, `, ${name} )`);\n\t\t\t}\n\t\t}\n\t}\n}\n","import CompileError from '../../utils/CompileError.js';\nimport Node from '../Node.js';\nimport reserved from '../../utils/reserved.js';\n\nexport default class Property extends Node {\n\tinitialise(transforms) {\n\t\tif ((this.kind === 'get' || this.kind === 'set') && transforms.getterSetter) {\n\t\t\tCompileError.missingTransform(\"getters and setters\", \"getterSetter\", this);\n\t\t}\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tif (\n\t\t\ttransforms.conciseMethodProperty &&\n\t\t\t!this.computed &&\n\t\t\tthis.parent.type !== 'ObjectPattern'\n\t\t) {\n\t\t\tif (this.shorthand) {\n\t\t\t\tcode.prependRight(this.start, `${this.key.name}: `);\n\t\t\t} else if (this.method) {\n\t\t\t\tlet name = '';\n\t\t\t\tif (this.program.options.namedFunctionExpressions !== false) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.key.type === 'Literal' &&\n\t\t\t\t\t\ttypeof this.key.value === 'number'\n\t\t\t\t\t) {\n\t\t\t\t\t\tname = '';\n\t\t\t\t\t} else if (this.key.type === 'Identifier') {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\treserved[this.key.name] ||\n\t\t\t\t\t\t\t!/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) ||\n\t\t\t\t\t\t\tthis.value.body.scope.references[this.key.name]\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tname = this.findScope(true).createIdentifier(this.key.name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tname = this.key.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = this.findScope(true).createIdentifier(this.key.value);\n\t\t\t\t\t}\n\t\t\t\t\tname = ' ' + name;\n\t\t\t\t}\n\n\t\t\t\tif (this.start < this.key.start) code.remove(this.start, this.key.start);\n\t\t\t\tcode.appendLeft(\n\t\t\t\t\tthis.key.end,\n\t\t\t\t\t`: ${this.value.async ? 'async ' : ''}function${this.value.generator ? '*' : ''}${name}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (transforms.reservedProperties && reserved[this.key.name]) {\n\t\t\tcode.prependRight(this.key.start, `'`);\n\t\t\tcode.appendLeft(this.key.end, `'`);\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class ReturnStatement extends Node {\n\tinitialise(transforms) {\n\t\tthis.loop = this.findNearest(loopStatement);\n\t\tthis.nearestFunction = this.findNearest(/Function/);\n\n\t\tif (\n\t\t\tthis.loop &&\n\t\t\t(!this.nearestFunction || this.loop.depth > this.nearestFunction.depth)\n\t\t) {\n\t\t\tthis.loop.canReturn = true;\n\t\t\tthis.shouldWrap = true;\n\t\t}\n\n\t\tif (this.argument) this.argument.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tconst shouldWrap =\n\t\t\tthis.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction;\n\n\t\tif (this.argument) {\n\t\t\tif (shouldWrap) code.prependRight(this.argument.start, `{ v: `);\n\t\t\tthis.argument.transpile(code, transforms);\n\t\t\tif (shouldWrap) code.appendLeft(this.argument.end, ` }`);\n\t\t} else if (shouldWrap) {\n\t\t\tcode.appendLeft(this.start + 6, ' {}');\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class Super extends Node {\n\tinitialise(transforms) {\n\t\tif (transforms.classes) {\n\t\t\tthis.method = this.findNearest('MethodDefinition');\n\t\t\tif (!this.method)\n\t\t\t\tthrow new CompileError('use of super outside class method', this);\n\n\t\t\tconst parentClass = this.findNearest('ClassBody').parent;\n\t\t\tthis.superClassName =\n\t\t\t\tparentClass.superClass && (parentClass.superClass.name || 'superclass');\n\n\t\t\tif (!this.superClassName)\n\t\t\t\tthrow new CompileError('super used in base class', this);\n\n\t\t\tthis.isCalled =\n\t\t\t\tthis.parent.type === 'CallExpression' && this === this.parent.callee;\n\n\t\t\tif (this.method.kind !== 'constructor' && this.isCalled) {\n\t\t\t\tthrow new CompileError(\n\t\t\t\t\t'super() not allowed outside class constructor',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.isMember = this.parent.type === 'MemberExpression';\n\n\t\t\tif (!this.isCalled && !this.isMember) {\n\t\t\t\tthrow new CompileError(\n\t\t\t\t\t'Unexpected use of `super` (expected `super(...)` or `super.*`)',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (transforms.arrow) {\n\t\t\tconst lexicalBoundary = this.findLexicalBoundary();\n\t\t\tconst arrowFunction = this.findNearest('ArrowFunctionExpression');\n\t\t\tconst loop = this.findNearest(loopStatement);\n\n\t\t\tif (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {\n\t\t\t\tthis.thisAlias = lexicalBoundary.getThisAlias();\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tloop &&\n\t\t\t\tloop.body.contains(this) &&\n\t\t\t\tloop.depth > lexicalBoundary.depth\n\t\t\t) {\n\t\t\t\tthis.thisAlias = lexicalBoundary.getThisAlias();\n\t\t\t}\n\t\t}\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (transforms.classes) {\n\t\t\tconst expression =\n\t\t\t\tthis.isCalled || this.method.static\n\t\t\t\t\t? this.superClassName\n\t\t\t\t\t: `${this.superClassName}.prototype`;\n\n\t\t\tcode.overwrite(this.start, this.end, expression, {\n\t\t\t\tstoreName: true,\n\t\t\t\tcontentOnly: true\n\t\t\t});\n\n\t\t\tconst callExpression = this.isCalled ? this.parent : this.parent.parent;\n\n\t\t\tif (callExpression && callExpression.type === 'CallExpression') {\n\t\t\t\tif (!this.noCall) {\n\t\t\t\t\t// special case – `super( ...args )`\n\t\t\t\t\tcode.appendLeft(callExpression.callee.end, '.call');\n\t\t\t\t}\n\n\t\t\t\tconst thisAlias = this.thisAlias || 'this';\n\n\t\t\t\tif (callExpression.arguments.length) {\n\t\t\t\t\tcode.appendLeft(callExpression.arguments[0].start, `${thisAlias}, `);\n\t\t\t\t} else {\n\t\t\t\t\tcode.appendLeft(callExpression.end - 1, `${thisAlias}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport CompileError from '../../utils/CompileError.js';\n\nexport default class TaggedTemplateExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (\n\t\t\ttransforms.templateString &&\n\t\t\t!transforms.dangerousTaggedTemplateString\n\t\t) {\n\t\t\tCompileError.missingTransform(\n\t\t\t\t\"tagged template strings\", \"templateString\", this, \"dangerousTaggedTemplateString\"\n\t\t\t);\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (transforms.templateString && transforms.dangerousTaggedTemplateString) {\n\t\t\tconst ordered = this.quasi.expressions\n\t\t\t\t.concat(this.quasi.quasis)\n\t\t\t\t.sort((a, b) => a.start - b.start);\n\n\t\t\tconst program = this.program;\n\t\t\tconst rootScope = program.body.scope;\n\n\t\t\t// insert strings at start\n\t\t\tconst templateStrings = this.quasi.quasis.map(quasi =>\n\t\t\t\tJSON.stringify(quasi.value.cooked)\n\t\t\t).join(', ');\n\n\t\t\tlet templateObject = this.program.templateLiteralQuasis[templateStrings];\n\t\t\tif (!templateObject) {\n\t\t\t\ttemplateObject = rootScope.createIdentifier('templateObject');\n\t\t\t\tcode.prependLeft(this.program.prependAt, `var ${templateObject} = Object.freeze([${templateStrings}]);\\n`);\n\n\t\t\t\tthis.program.templateLiteralQuasis[templateStrings] = templateObject;\n\t\t\t}\n\n\t\t\tcode.overwrite(\n\t\t\t\tthis.tag.end,\n\t\t\t\tordered[0].start,\n\t\t\t\t`(${templateObject}`\n\t\t\t);\n\n\t\t\tlet lastIndex = ordered[0].start;\n\t\t\tordered.forEach(node => {\n\t\t\t\tif (node.type === 'TemplateElement') {\n\t\t\t\t\tcode.remove(lastIndex, node.end);\n\t\t\t\t} else {\n\t\t\t\t\tcode.overwrite(lastIndex, node.start, ', ');\n\t\t\t\t}\n\n\t\t\t\tlastIndex = node.end;\n\t\t\t});\n\n\t\t\tcode.overwrite(lastIndex, this.end, ')');\n\t\t}\n\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class TemplateElement extends Node {\n\tinitialise() {\n\t\tthis.program.indentExclusionElements.push(this);\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class TemplateLiteral extends Node {\n\ttranspile(code, transforms) {\n\t\tsuper.transpile(code, transforms);\n\n\t\tif (\n\t\t\ttransforms.templateString &&\n\t\t\tthis.parent.type !== 'TaggedTemplateExpression'\n\t\t) {\n\t\t\tconst ordered = this.expressions\n\t\t\t\t.concat(this.quasis)\n\t\t\t\t.sort((a, b) => a.start - b.start || a.end - b.end)\n\t\t\t\t.filter((node, i) => {\n\t\t\t\t\t// include all expressions\n\t\t\t\t\tif (node.type !== 'TemplateElement') return true;\n\n\t\t\t\t\t// include all non-empty strings\n\t\t\t\t\tif (node.value.raw) return true;\n\n\t\t\t\t\t// exclude all empty strings not at the head\n\t\t\t\t\treturn !i;\n\t\t\t\t});\n\n\t\t\t// special case – we may be able to skip the first element,\n\t\t\t// if it's the empty string, but only if the second and\n\t\t\t// third elements aren't both expressions (since they maybe\n\t\t\t// be numeric, and `1 + 2 + '3' === '33'`)\n\t\t\tif (ordered.length >= 3) {\n\t\t\t\tconst [first, , third] = ordered;\n\t\t\t\tif (\n\t\t\t\t\tfirst.type === 'TemplateElement' &&\n\t\t\t\t\tfirst.value.raw === '' &&\n\t\t\t\t\tthird.type === 'TemplateElement'\n\t\t\t\t) {\n\t\t\t\t\tordered.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst parenthesise =\n\t\t\t\t(this.quasis.length !== 1 || this.expressions.length !== 0) &&\n\t\t\t\tthis.parent.type !== 'TemplateLiteral' &&\n\t\t\t\tthis.parent.type !== 'AssignmentExpression' &&\n\t\t\t\tthis.parent.type !== 'AssignmentPattern' &&\n\t\t\t\tthis.parent.type !== 'VariableDeclarator' &&\n\t\t\t\t(this.parent.type !== 'BinaryExpression' ||\n\t\t\t\t\tthis.parent.operator !== '+');\n\n\t\t\tif (parenthesise) code.appendRight(this.start, '(');\n\n\t\t\tlet lastIndex = this.start;\n\n\t\t\tordered.forEach((node, i) => {\n\t\t\t\tlet prefix = i === 0 ? (parenthesise ? '(' : '') : ' + ';\n\n\t\t\t\tif (node.type === 'TemplateElement') {\n\t\t\t\t\tcode.overwrite(\n\t\t\t\t\t\tlastIndex,\n\t\t\t\t\t\tnode.end,\n\t\t\t\t\t\tprefix + JSON.stringify(node.value.cooked)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst parenthesise = node.type !== 'Identifier'; // TODO other cases where it's safe\n\n\t\t\t\t\tif (parenthesise) prefix += '(';\n\n\t\t\t\t\tcode.remove(lastIndex, node.start);\n\n\t\t\t\t\tif (prefix) code.prependRight(node.start, prefix);\n\t\t\t\t\tif (parenthesise) code.appendLeft(node.end, ')');\n\t\t\t\t}\n\n\t\t\t\tlastIndex = node.end;\n\t\t\t});\n\n\t\t\tif (parenthesise) code.appendLeft(lastIndex, ')');\n\t\t\tcode.overwrite(lastIndex, this.end, \"\", { contentOnly: true });\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class ThisExpression extends Node {\n\tinitialise(transforms) {\n\t\tconst lexicalBoundary = this.findLexicalBoundary();\n\n\t\tif (transforms.letConst) {\n\t\t\t// save all loops up to the lexical boundary in case we need\n\t\t\t// to alias them later for block-scoped declarations\n\t\t\tlet node = this.findNearest(loopStatement);\n\t\t\twhile (node && node.depth > lexicalBoundary.depth) {\n\t\t\t\tnode.thisRefs.push(this);\n\t\t\t\tnode = node.parent.findNearest(loopStatement);\n\t\t\t}\n\t\t}\n\n\t\tif (transforms.arrow) {\n\t\t\tconst arrowFunction = this.findNearest('ArrowFunctionExpression');\n\n\t\t\tif (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {\n\t\t\t\tthis.alias = lexicalBoundary.getThisAlias();\n\t\t\t}\n\t\t}\n\t}\n\n\ttranspile(code) {\n\t\tif (this.alias) {\n\t\t\tcode.overwrite(this.start, this.end, this.alias, {\n\t\t\t\tstoreName: true,\n\t\t\t\tcontentOnly: true\n\t\t\t});\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\nimport checkConst from '../../utils/checkConst.js';\n\nexport default class UpdateExpression extends Node {\n\tinitialise(transforms) {\n\t\tif (this.argument.type === 'Identifier') {\n\t\t\tconst declaration = this.findScope(false).findDeclaration(\n\t\t\t\tthis.argument.name\n\t\t\t);\n\t\t\t// special case – https://gitlab.com/Rich-Harris/buble/issues/150\n\t\t\tconst statement = declaration && declaration.node.ancestor(3);\n\t\t\tif (\n\t\t\t\tstatement &&\n\t\t\t\tstatement.type === 'ForStatement' &&\n\t\t\t\tstatement.body.contains(this)\n\t\t\t) {\n\t\t\t\tstatement.reassigned[this.argument.name] = true;\n\t\t\t}\n\t\t}\n\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (this.argument.type === 'Identifier') {\n\t\t\t// Do this check after everything has been initialized to find\n\t\t\t// shadowing declarations after this expression\n\t\t\tcheckConst(this.argument, this.findScope(false));\n\t\t}\n\t\tsuper.transpile(code, transforms);\n\t}\n}\n","import Node from '../Node.js';\nimport destructure from '../../utils/destructure.js';\nimport { loopStatement } from '../../utils/patterns.js';\n\nexport default class VariableDeclaration extends Node {\n\tinitialise(transforms) {\n\t\tthis.scope = this.findScope(this.kind === 'var');\n\t\tthis.declarations.forEach(declarator => declarator.initialise(transforms));\n\t}\n\n\ttranspile(code, transforms) {\n\t\tconst i0 = this.getIndentation();\n\t\tlet kind = this.kind;\n\n\t\tif (transforms.letConst && kind !== 'var') {\n\t\t\tkind = 'var';\n\t\t\tcode.overwrite(this.start, this.start + this.kind.length, kind, {\n\t\t\t\tcontentOnly: true,\n\t\t\t\tstoreName: true\n\t\t\t});\n\t\t}\n\n\t\tif (transforms.destructuring && this.parent.type !== 'ForOfStatement' && this.parent.type !== 'ForInStatement') {\n\t\t\tlet c = this.start;\n\t\t\tlet lastDeclaratorIsPattern;\n\n\t\t\tthis.declarations.forEach((declarator, i) => {\n\t\t\t\tdeclarator.transpile(code, transforms);\n\n\t\t\t\tif (declarator.id.type === 'Identifier') {\n\t\t\t\t\tif (i > 0 && this.declarations[i - 1].id.type !== 'Identifier') {\n\t\t\t\t\t\tcode.overwrite(c, declarator.id.start, `var `);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst inline = loopStatement.test(this.parent.type);\n\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tcode.remove(c, declarator.id.start);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode.overwrite(c, declarator.id.start, `;\\n${i0}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst simple =\n\t\t\t\t\t\tdeclarator.init.type === 'Identifier' && !declarator.init.rewritten;\n\n\t\t\t\t\tconst name = simple\n\t\t\t\t\t\t? (declarator.init.alias || declarator.init.name)\n\t\t\t\t\t\t: declarator.findScope(true).createIdentifier('ref');\n\n\t\t\t\t\tc = declarator.start;\n\n\t\t\t\t\tconst statementGenerators = [];\n\n\t\t\t\t\tif (simple) {\n\t\t\t\t\t\tcode.remove(declarator.id.end, declarator.end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatementGenerators.push((start, prefix, suffix) => {\n\t\t\t\t\t\t\tcode.prependRight(declarator.id.end, `var ${name}`);\n\t\t\t\t\t\t\tcode.appendLeft(declarator.init.end, `${suffix}`);\n\t\t\t\t\t\t\tcode.move(declarator.id.end, declarator.end, start);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tconst scope = declarator.findScope(false);\n\t\t\t\t\tdestructure(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tid => scope.createIdentifier(id),\n\t\t\t\t\t\t({ name }) => scope.resolveName(name),\n\t\t\t\t\t\tdeclarator.id,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tinline,\n\t\t\t\t\t\tstatementGenerators\n\t\t\t\t\t);\n\n\t\t\t\t\tconst prefix = inline ? 'var ' : '';\n\t\t\t\t\tlet suffix = inline ? `, ` : `;\\n${i0}`;\n\t\t\t\t\tstatementGenerators.forEach((fn, j) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ti === this.declarations.length - 1 &&\n\t\t\t\t\t\t\tj === statementGenerators.length - 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsuffix = inline ? '' : ';';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfn(declarator.start, j === 0 ? prefix : '', suffix);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tc = declarator.end;\n\t\t\t\tlastDeclaratorIsPattern = declarator.id.type !== 'Identifier';\n\t\t\t});\n\n\t\t\tif (lastDeclaratorIsPattern && this.end > c) {\n\t\t\t\tcode.overwrite(c, this.end, '', { contentOnly: true });\n\t\t\t}\n\t\t} else {\n\t\t\tthis.declarations.forEach(declarator => {\n\t\t\t\tdeclarator.transpile(code, transforms);\n\t\t\t});\n\t\t}\n\t}\n}\n","import Node from '../Node.js';\n\nexport default class VariableDeclarator extends Node {\n\tinitialise(transforms) {\n\t\tlet kind = this.parent.kind;\n\t\tif (kind === 'let' && this.parent.parent.type === 'ForStatement') {\n\t\t\tkind = 'for.let'; // special case...\n\t\t}\n\n\t\tthis.parent.scope.addDeclaration(this.id, kind);\n\t\tsuper.initialise(transforms);\n\t}\n\n\ttranspile(code, transforms) {\n\t\tif (!this.init && transforms.letConst && this.parent.kind !== 'var') {\n\t\t\tconst inLoop = this.findNearest(\n\t\t\t\t/Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/\n\t\t\t);\n\t\t\tif (\n\t\t\t\tinLoop &&\n\t\t\t\t!/Function/.test(inLoop.type) &&\n\t\t\t\t!this.isLeftDeclaratorOfLoop()\n\t\t\t) {\n\t\t\t\tcode.appendLeft(this.id.end, ' = (void 0)');\n\t\t\t}\n\t\t}\n\n\t\tif (this.id) this.id.transpile(code, transforms);\n\t\tif (this.init) this.init.transpile(code, transforms);\n\t}\n\n\tisLeftDeclaratorOfLoop() {\n\t\treturn (\n\t\t\tthis.parent &&\n\t\t\tthis.parent.type === 'VariableDeclaration' &&\n\t\t\tthis.parent.parent &&\n\t\t\t(this.parent.parent.type === 'ForInStatement' ||\n\t\t\t\tthis.parent.parent.type === 'ForOfStatement') &&\n\t\t\tthis.parent.parent.left &&\n\t\t\tthis.parent.parent.left.declarations[0] === this\n\t\t);\n\t}\n}\n","import ArrayExpression from './ArrayExpression.js';\nimport ArrowFunctionExpression from './ArrowFunctionExpression.js';\nimport AssignmentExpression from './AssignmentExpression.js';\nimport AwaitExpression from './AwaitExpression.js';\nimport BinaryExpression from './BinaryExpression.js';\nimport BreakStatement from './BreakStatement.js';\nimport CallExpression from './CallExpression.js';\nimport CatchClause from './CatchClause.js';\nimport ClassBody from './ClassBody.js';\nimport ClassDeclaration from './ClassDeclaration.js';\nimport ClassExpression from './ClassExpression.js';\nimport ContinueStatement from './ContinueStatement.js';\nimport ExportDefaultDeclaration from './ExportDefaultDeclaration.js';\nimport ExportNamedDeclaration from './ExportNamedDeclaration.js';\nimport ForStatement from './ForStatement.js';\nimport ForInStatement from './ForInStatement.js';\nimport ForOfStatement from './ForOfStatement.js';\nimport FunctionDeclaration from './FunctionDeclaration.js';\nimport FunctionExpression from './FunctionExpression.js';\nimport Identifier from './Identifier.js';\nimport IfStatement from './IfStatement.js';\nimport Import from './Import.js';\nimport ImportDeclaration from './ImportDeclaration.js';\nimport ImportDefaultSpecifier from './ImportDefaultSpecifier.js';\nimport ImportSpecifier from './ImportSpecifier.js';\nimport JSXAttribute from './JSXAttribute.js';\nimport JSXClosingElement from './JSXClosingElement.js';\nimport JSXClosingFragment from './JSXClosingFragment.js';\nimport JSXElement from './JSXElement.js';\nimport JSXExpressionContainer from './JSXExpressionContainer.js';\nimport JSXFragment from './JSXFragment.js';\nimport JSXOpeningElement from './JSXOpeningElement.js';\nimport JSXOpeningFragment from './JSXOpeningFragment.js';\nimport JSXSpreadAttribute from './JSXSpreadAttribute.js';\nimport Literal from './Literal.js';\nimport LoopStatement from './shared/LoopStatement.js';\nimport MemberExpression from './MemberExpression.js';\nimport NewExpression from './NewExpression.js';\nimport ObjectExpression from './ObjectExpression.js';\nimport Property from './Property.js';\nimport ReturnStatement from './ReturnStatement.js';\nimport Super from './Super.js';\nimport TaggedTemplateExpression from './TaggedTemplateExpression.js';\nimport TemplateElement from './TemplateElement.js';\nimport TemplateLiteral from './TemplateLiteral.js';\nimport ThisExpression from './ThisExpression.js';\nimport UpdateExpression from './UpdateExpression.js';\nimport VariableDeclaration from './VariableDeclaration.js';\nimport VariableDeclarator from './VariableDeclarator.js';\n\nexport default {\n\tArrayExpression,\n\tArrowFunctionExpression,\n\tAssignmentExpression,\n\tAwaitExpression,\n\tBinaryExpression,\n\tBreakStatement,\n\tCallExpression,\n\tCatchClause,\n\tClassBody,\n\tClassDeclaration,\n\tClassExpression,\n\tContinueStatement,\n\tDoWhileStatement: LoopStatement,\n\tExportNamedDeclaration,\n\tExportDefaultDeclaration,\n\tForStatement,\n\tForInStatement,\n\tForOfStatement,\n\tFunctionDeclaration,\n\tFunctionExpression,\n\tIdentifier,\n\tIfStatement,\n\tImport,\n\tImportDeclaration,\n\tImportDefaultSpecifier,\n\tImportSpecifier,\n\tJSXAttribute,\n\tJSXClosingElement,\n\tJSXClosingFragment,\n\tJSXElement,\n\tJSXExpressionContainer,\n\tJSXFragment,\n\tJSXOpeningElement,\n\tJSXOpeningFragment,\n\tJSXSpreadAttribute,\n\tLiteral,\n\tMemberExpression,\n\tNewExpression,\n\tObjectExpression,\n\tProperty,\n\tReturnStatement,\n\tSuper,\n\tTaggedTemplateExpression,\n\tTemplateElement,\n\tTemplateLiteral,\n\tThisExpression,\n\tUpdateExpression,\n\tVariableDeclaration,\n\tVariableDeclarator,\n\tWhileStatement: LoopStatement\n};\n","export default {\n\tProgram: ['body'],\n\tLiteral: []\n};\n","import types from './types/index.js';\nimport BlockStatement from './BlockStatement.js';\nimport Node from './Node.js';\nimport keys from './keys.js';\n\nconst statementsWithBlocks = {\n\tIfStatement: 'consequent',\n\tForStatement: 'body',\n\tForInStatement: 'body',\n\tForOfStatement: 'body',\n\tWhileStatement: 'body',\n\tDoWhileStatement: 'body',\n\tArrowFunctionExpression: 'body'\n};\n\nexport default function wrap(raw, parent) {\n\tif (!raw) return;\n\n\tif ('length' in raw) {\n\t\tlet i = raw.length;\n\t\twhile (i--) wrap(raw[i], parent);\n\t\treturn;\n\t}\n\n\t// with e.g. shorthand properties, key and value are\n\t// the same node. We don't want to wrap an object twice\n\tif (raw.__wrapped) return;\n\traw.__wrapped = true;\n\n\tif (!keys[raw.type]) {\n\t\tkeys[raw.type] = Object.keys(raw).filter(\n\t\t\tkey => typeof raw[key] === 'object'\n\t\t);\n\t}\n\n\t// special case – body-less if/for/while statements. TODO others?\n\tconst bodyType = statementsWithBlocks[raw.type];\n\tif (bodyType && raw[bodyType].type !== 'BlockStatement') {\n\t\tconst expression = raw[bodyType];\n\n\t\t// create a synthetic block statement, otherwise all hell\n\t\t// breaks loose when it comes to block scoping\n\t\traw[bodyType] = {\n\t\t\tstart: expression.start,\n\t\t\tend: expression.end,\n\t\t\ttype: 'BlockStatement',\n\t\t\tbody: [expression],\n\t\t\tsynthetic: true\n\t\t};\n\t}\n\n\traw.parent = parent;\n\traw.program = parent.program || parent;\n\traw.depth = parent.depth + 1;\n\traw.keys = keys[raw.type];\n\traw.indentation = undefined;\n\n\tfor (const key of keys[raw.type]) {\n\t\twrap(raw[key], raw);\n\t}\n\n\traw.program.magicString.addSourcemapLocation(raw.start);\n\traw.program.magicString.addSourcemapLocation(raw.end);\n\n\tconst type =\n\t\t(raw.type === 'BlockStatement' ? BlockStatement : types[raw.type]) || Node;\n\traw.__proto__ = type.prototype;\n}\n","import MagicString from 'magic-string';\nimport BlockStatement from './BlockStatement.js';\nimport wrap from './wrap.js';\n\nexport default function Program(source, ast, transforms, options) {\n\tthis.type = 'Root';\n\n\t// options\n\tthis.jsx = options.jsx || 'React.createElement';\n\tthis.jsxFragment = options.jsxFragment || 'React.Fragment';\n\tthis.options = options;\n\n\tthis.source = source;\n\tthis.magicString = new MagicString(source);\n\n\tthis.ast = ast;\n\tthis.depth = 0;\n\n\twrap((this.body = ast), this);\n\tthis.body.__proto__ = BlockStatement.prototype;\n\n\tthis.templateLiteralQuasis = Object.create(null);\n\tfor (let i = 0; i < this.body.body.length; ++i) {\n\t\tif (!this.body.body[i].directive) {\n\t\t\tthis.prependAt = this.body.body[i].start;\n\t\t\tbreak;\n\t\t}\n\t}\n\tthis.objectWithoutPropertiesHelper = null;\n\n\tthis.indentExclusionElements = [];\n\tthis.body.initialise(transforms);\n\n\tthis.indentExclusions = Object.create(null);\n\tfor (const node of this.indentExclusionElements) {\n\t\tfor (let i = node.start; i < node.end; i += 1) {\n\t\t\tthis.indentExclusions[i] = true;\n\t\t}\n\t}\n\n\tthis.body.transpile(this.magicString, transforms);\n}\n\nProgram.prototype = {\n\texport(options = {}) {\n\t\treturn {\n\t\t\tcode: this.magicString.toString(),\n\t\t\tmap: this.magicString.generateMap({\n\t\t\t\tfile: options.file,\n\t\t\t\tsource: options.source,\n\t\t\t\tincludeContent: options.includeContent !== false\n\t\t\t})\n\t\t};\n\t},\n\n\tfindNearest() {\n\t\treturn null;\n\t},\n\n\tfindScope() {\n\t\treturn null;\n\t},\n\n\tgetObjectWithoutPropertiesHelper(code) {\n\t\tif (!this.objectWithoutPropertiesHelper) {\n\t\t\tthis.objectWithoutPropertiesHelper = this.body.scope.createIdentifier('objectWithoutProperties');\n\t\t\tcode.prependLeft(this.prependAt, `function ${this.objectWithoutPropertiesHelper} (obj, exclude) { ` +\n\t\t\t\t`var target = {}; for (var k in obj) ` +\n\t\t\t\t`if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) ` +\n\t\t\t\t`target[k] = obj[k]; return target; }\\n`\n\t\t\t);\n\t\t}\n\t\treturn this.objectWithoutPropertiesHelper;\n\t}\n};\n","export const matrix = {\n\tchrome: {\n\t\t    48: 0b00010010101000110011111,\n\t\t    49: 0b00010011111001111111111,\n\t\t    50: 0b00010111111001111111111,\n\t\t    51: 0b00010111111001111111111,\n\t\t    52: 0b00011111111001111111111,\n\t\t    53: 0b00011111111001111111111,\n\t\t    54: 0b00011111111001111111111,\n\t\t    55: 0b01011111111001111111111,\n\t\t    56: 0b01011111111001111111111,\n\t\t    57: 0b01011111111001111111111,\n\t\t    58: 0b01111111111001111111111,\n\t\t    59: 0b01111111111001111111111,\n\t\t    60: 0b11111111111001111111111,\n\t\t    61: 0b11111111111001111111111,\n\t\t    62: 0b11111111111001111111111,\n\t\t    63: 0b11111111111001111111111,\n\t\t    64: 0b11111111111001111111111,\n\t\t    65: 0b11111111111001111111111,\n\t\t    66: 0b11111111111001111111111,\n\t\t    67: 0b11111111111001111111111,\n\t\t    68: 0b11111111111001111111111,\n\t\t    69: 0b11111111111001111111111,\n\t\t    70: 0b11111111111001111111111,\n\t\t    71: 0b11111111111001111111111\n\t},\n\tfirefox: {\n\t\t    43: 0b00010011101000110111011,\n\t\t    44: 0b00010011101000110111011,\n\t\t    45: 0b00010011101000110111111,\n\t\t    46: 0b00010111101000110111111,\n\t\t    47: 0b00010111101000111111111,\n\t\t    48: 0b00010111101000111111111,\n\t\t    49: 0b00010111101000111111111,\n\t\t    50: 0b00010111101000111111111,\n\t\t    51: 0b00010111101001111111111,\n\t\t    52: 0b01111111111001111111111,\n\t\t    53: 0b01111111111001111111111,\n\t\t    54: 0b01111111111001111111111,\n\t\t    55: 0b11111111111001111111111,\n\t\t    56: 0b11111111111001111111111,\n\t\t    57: 0b11111111111001111111111,\n\t\t    58: 0b11111111111001111111111,\n\t\t    59: 0b11111111111001111111111,\n\t\t    60: 0b11111111111001111111111,\n\t\t    61: 0b11111111111001111111111,\n\t\t    62: 0b11111111111001111111111,\n\t\t    63: 0b11111111111001111111111,\n\t\t    64: 0b11111111111001111111111\n\t},\n\tsafari: {\n\t\t     8: 0b00010000000000000001001,\n\t\t     9: 0b00010010001000011011101,\n\t\t    10: 0b00110111111001111111111,\n\t\t'10.1': 0b01111111111001111111111,\n\t\t    11: 0b01111111111001111111111,\n\t\t'11.1': 0b11111111111001111111111,\n\t\t    12: 0b11111111111001111111111\n\t},\n\tie: {\n\t\t     8: 0b00000000000000000000000,\n\t\t     9: 0b00010000000000000000001,\n\t\t    10: 0b00010000000000000000001,\n\t\t    11: 0b00010000000000000000001 // no let/const in for loops\n\t},\n\tedge: {\n\t\t    12: 0b00010010101000010011011,\n\t\t    13: 0b00010111101000110011111,\n\t\t    14: 0b00111111101001111111111,\n\t\t    15: 0b01111111101001111111111,\n\t\t    16: 0b01111111101001111111111,\n\t\t    17: 0b01111111101001111111111,\n\t\t    18: 0b01111111101001111111111,\n\t\t    19: 0b01111111101001111111111\n\t},\n\tnode: {\n\t\t'0.10': 0b00010000000000000000001,\n\t\t'0.12': 0b00010000000000010000001,\n\t\t     4: 0b00010010001000110011111,\n\t\t     5: 0b00010010001000110011111,\n\t\t     6: 0b00010111111001111111111,\n\t\t     8: 0b01111111111001111111111,\n\t\t '8.3': 0b11111111111001111111111,\n\t\t '8.7': 0b11111111111001111111111,\n\t\t'8.10': 0b11111111111001111111111\n\t}\n};\n\nexport const features = [\n\t'getterSetter',\n\t'arrow',\n\t'classes',\n\t'computedProperty',\n\t'conciseMethodProperty',\n\t'defaultParameter',\n\t'destructuring',\n\t'forOf',\n\t'generator',\n\t'letConst',\n\t'moduleExport',\n\t'moduleImport',\n\t'numericLiteral',\n\t'parameterDestructuring',\n\t'spreadRest',\n\t'stickyRegExp',\n\t'templateString',\n\t'unicodeRegExp',\n\n\t// ES2016\n\t'exponentiation',\n\n\t// additional transforms, not from\n\t// https://featuretests.io\n\t'reservedProperties',\n\n\t'trailingFunctionCommas',\n\t'asyncAwait',\n\t'objectRestSpread'\n];\n","import { Parser } from 'acorn';\nimport acornJsx from 'acorn-jsx';\nimport acornDynamicImport from 'acorn-dynamic-import';\nimport Program from './program/Program.js';\nimport { features, matrix } from './support.js';\nimport getSnippet from './utils/getSnippet.js';\n\nconst parser = Parser.extend(acornDynamicImport, acornJsx());\n\nconst dangerousTransforms = ['dangerousTaggedTemplateString', 'dangerousForOf'];\n\nexport function target(target) {\n\tconst targets = Object.keys(target);\n\tlet bitmask = targets.length\n\t\t? 0b11111111111111111111111\n\t\t: 0b00010000000000000000001;\n\n\tObject.keys(target).forEach(environment => {\n\t\tconst versions = matrix[environment];\n\t\tif (!versions)\n\t\t\tthrow new Error(\n\t\t\t\t`Unknown environment '${environment}'. Please raise an issue at https://github.com/bublejs/buble/issues`\n\t\t\t);\n\n\t\tconst targetVersion = target[environment];\n\t\tif (!(targetVersion in versions))\n\t\t\tthrow new Error(\n\t\t\t\t`Support data exists for the following versions of ${environment}: ${Object.keys(\n\t\t\t\t\tversions\n\t\t\t\t).join(\n\t\t\t\t\t', '\n\t\t\t\t)}. Please raise an issue at https://github.com/bublejs/buble/issues`\n\t\t\t);\n\t\tconst support = versions[targetVersion];\n\n\t\tbitmask &= support;\n\t});\n\n\tconst transforms = Object.create(null);\n\tfeatures.forEach((name, i) => {\n\t\ttransforms[name] = !(bitmask & (1 << i));\n\t});\n\n\tdangerousTransforms.forEach(name => {\n\t\ttransforms[name] = false;\n\t});\n\n\treturn transforms;\n}\n\nexport function transform(source, options = {}) {\n\tlet ast;\n\tlet jsx = null;\n\n\ttry {\n\t\tast = parser.parse(source, {\n\t\t\tecmaVersion: 10,\n\t\t\tpreserveParens: true,\n\t\t\tsourceType: 'module',\n\t\t\tallowAwaitOutsideFunction: true,\n\t\t\tallowReturnOutsideFunction: true,\n\t\t\tallowHashBang: true,\n\t\t\tonComment: (block, text) => {\n\t\t\t\tif (!jsx) {\n\t\t\t\t\tconst match = /@jsx\\s+([^\\s]+)/.exec(text);\n\t\t\t\t\tif (match) jsx = match[1];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\toptions.jsx = jsx || options.jsx;\n\t} catch (err) {\n\t\terr.snippet = getSnippet(source, err.loc);\n\t\terr.toString = () => `${err.name}: ${err.message}\\n${err.snippet}`;\n\t\tthrow err;\n\t}\n\n\tconst transforms = target(options.target || {});\n\tObject.keys(options.transforms || {}).forEach(name => {\n\t\tif (name === 'modules') {\n\t\t\tif (!('moduleImport' in options.transforms))\n\t\t\t\ttransforms.moduleImport = options.transforms.modules;\n\t\t\tif (!('moduleExport' in options.transforms))\n\t\t\t\ttransforms.moduleExport = options.transforms.modules;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(name in transforms)) throw new Error(`Unknown transform '${name}'`);\n\t\ttransforms[name] = options.transforms[name];\n\t});\n\tif (options.objectAssign === true) options.objectAssign = 'Object.assign';\n\treturn new Program(source, ast, transforms, options).export(options);\n}\n\nexport { version as VERSION } from '../package.json';\n"]},"metadata":{},"sourceType":"module"}